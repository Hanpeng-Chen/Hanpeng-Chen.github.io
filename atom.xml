<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码视界</title>
  
  <subtitle>Hanpeng Chen&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenhanpeng.com/"/>
  <updated>2021-06-29T09:30:38.385Z</updated>
  <id>http://www.chenhanpeng.com/</id>
  
  <author>
    <name>Hanpeng Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文学会Vue3新特性</title>
    <link href="http://www.chenhanpeng.com/learn-vue3/"/>
    <id>http://www.chenhanpeng.com/learn-vue3/</id>
    <published>2021-06-29T09:26:36.000Z</published>
    <updated>2021-06-29T09:30:38.385Z</updated>
    
    <content type="html"><![CDATA[<p>Vue3.0 周边生态现在已经完善得差不多了，新项目可以开始使用Vue3来开发了，今天我们先来学习Vue3的一些新特性。</p><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><h3 id="为什么选择Composition-API"><a href="#为什么选择Composition-API" class="headerlink" title="为什么选择Composition API"></a>为什么选择Composition API</h3><p>Composition API翻译成中文就是组合式API。有的人可能会疑惑为什么要用Composition API？原来Vue2中的options API不是也能实现吗？</p><p>我们先来Vue3官方文档中的例子：</p><p>假设我们的应用中有一个显示某个用户的仓库列表的视图。此外，我们还希望有搜索和筛选功能。实现此视图组件的代码可能如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    user: &#123; </span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      repositories: [], <span class="comment">// 1</span></span><br><span class="line">      filters: &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">      searchQuery: <span class="string">''</span> <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredRepositories () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">    repositoriesMatchingSearchQuery () &#123; ... &#125;, <span class="comment">// 2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    user: <span class="string">'getUserRepositories'</span> <span class="comment">// 1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getUserRepositories () &#123;</span><br><span class="line">      <span class="comment">// 使用 `this.user` 获取用户仓库</span></span><br><span class="line">    &#125;, <span class="comment">// 1</span></span><br><span class="line">    updateFilters () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.getUserRepositories() <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该组件有以下几个职责：</p><ul><li>从假定的外部 API 获取该用户的仓库，并在用户有任何更改时进行刷新</li><li>使用 searchQuery 字符串搜索仓库</li><li>使用 filters 对象筛选仓库</li></ul><p>使用 (data、computed、methods、watch) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，逻辑关注点的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210627221817.png" alt></p><p>这是一个大型组件的示例，其中逻辑关注点按颜色进行分组。</p><p>这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块。</p><p>如果能够将同一个逻辑关注点相关代码收集在一起会更好。而这正是组合式 API 使我们能够做到的。</p><blockquote><p><code>Vue3</code>兼容大部分<code>Vue2</code>语法，所以在<code>Vue3</code>中写Vue2语法是没问题的（废除的除外）。</p></blockquote><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>setup是Vue3新增的一个选项，是使用Composition API的入口。</p><h4 id="setup的执行时机"><a href="#setup的执行时机" class="headerlink" title="setup的执行时机"></a>setup的执行时机</h4><p><code>setup</code>只在初始化时执行一次，所有的 Composition API 函数都在这里使用。</p><p><code>setup</code>是在生命周期<code>beforeCreate</code>之前执行。我们通过下面的代码来验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'---------beforeCreate--------'</span>);</span><br><span class="line">&#125;,</span><br><span class="line">setup() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'---------setup--------'</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ---------setup--------</span></span><br><span class="line"><span class="comment">// ---------beforeCreate--------</span></span><br></pre></td></tr></table></figure><p>由上面的执行结果我们可以推断出，setup执行时，组件对象还没有创建，此时<code>this</code>是undefined，因此在setup函数中不能通过<code>this</code>对象访问<code>data/computed/methods/props</code>。</p><h4 id="setup参数"><a href="#setup参数" class="headerlink" title="setup参数"></a>setup参数</h4><p>setup有两个可选参数：</p><ul><li>props：组件传入的属性（响应式对象，且可以监听）</li><li>context：上下文对象。setup中不能访问Vue2中最常用的<code>this</code>对象，所以context中就提供了this中最常用的三个属性：<code>attrs</code>、<code>slot</code> 和<code>emit</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRef &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">setup(props) &#123;</span><br><span class="line">  <span class="keyword">const</span> title = toRef(props, <span class="string">'title'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于props是响应式的，所以<strong>不能使用 ES6 解构</strong>，解构会消除prop的响应性。如果需要解构prop，可以在setup函数中使用<code>toRefs</code>函数来完成此操作。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    <span class="comment">// Attribute (非响应式对象)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line">    <span class="comment">// 插槽 (非响应式对象)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.slots)</span><br><span class="line">    <span class="comment">// 触发事件 (方法)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p><code>reactive</code>函数接受一个普通对象，返回一个响应式数据对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  result: computed(<span class="function"><span class="params">()</span> =&gt;</span> data.count + <span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="ref-和-isRef"><a href="#ref-和-isRef" class="headerlink" title="ref 和 isRef"></a>ref 和 isRef</h3><ul><li><p>ref：接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property .value。</p></li><li><p>isRef：检查值是否为一个 ref 对象。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'count is ref：'</span>, isRef(count))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'count: '</span>, count)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'count.value：'</span>, count.value)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 <code>ref</code>。</p><p>我们通过<code>reactive</code>创建的对象，如果在模板中使用，就必须以<code>xxxx.xxx</code>的形式，但如果用到的地方比较多就比较麻烦。如果用ES6解构，就会失去响应式。</p><p>如果我们利用toRefs可以将一个响应式 reactive 对象的所有原始属性转换为响应式的ref属性。</p><p>前面提到的<code>setup</code>函数的<code>props</code>要解构可以使用<code>toRefs</code>。</p><p>示例代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;p&gt;number: &#123;&#123;number&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import &#123; toRefs, reactive &#125; from 'vue'</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  setup() &#123;</span></span><br><span class="line"><span class="regexp">    const state = reactive(&#123;</span></span><br><span class="line"><span class="regexp">      number: 0,</span></span><br><span class="line"><span class="regexp">      date: '20210628'</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">    const state2 = toRefs(state)</span></span><br><span class="line"><span class="regexp">    setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      state.number++ </span></span><br><span class="line"><span class="regexp">    &#125;, 1000)</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      ...state2</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="computed函数"><a href="#computed函数" class="headerlink" title="computed函数"></a>computed函数</h3><p>与Vue2中的 computed 配置功能一致，返回的是一个 ref 类型的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    plusOne: computed(<span class="function"><span class="params">()</span> =&gt;</span> state.count + <span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...toRefs(state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch函数"><a href="#watch函数" class="headerlink" title="watch函数"></a>watch函数</h3><p>监视指定的一个或多个响应式数据，一旦数据变化，就自动执行监视回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch, ref, reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> name = ref(<span class="string">'前端极客技术'</span>)</span><br><span class="line">    <span class="keyword">const</span> otherName = reactive(&#123;</span><br><span class="line">      firstName: <span class="string">'前端'</span>,</span><br><span class="line">      lastName: <span class="string">'技术'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    watch(name, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(newValue, oldValue)</span><br><span class="line">    &#125;)</span><br><span class="line">    watch(</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> otherName.firstName + otherName.lastName</span><br><span class="line">      &#125;,</span><br><span class="line">      value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      name.value = <span class="string">'前端极客'</span></span><br><span class="line">      otherName.firstName = <span class="string">'前端极客'</span></span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>为了根据响应式状态自动应用和重新应用副作用，我们可以使用 watchEffect 方法。它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">  <span class="comment">// -&gt; logs 1</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>通过下面的图来看下Vue2和Vue3生命周期钩子的对比：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210628224421.png" alt></p><ul><li>Vue3新增了setup</li><li>Vue2中的beforeDestroy名称变更为beforeUnmount</li><li>Vue2中的destroyed变更为 unmounted</li><li>Vue3.x 还新增用于调试的钩子函数onRenderTriggered和onRenderTricked</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  onBeforeMount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--onBeforeMount'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--onMounted'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUpdate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--onBeforeUpdate'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUpdated(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--onUpdated'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUnmount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--onBeforeUnmount'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'--onUnmounted'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getCurrentInstance"><a href="#getCurrentInstance" class="headerlink" title="getCurrentInstance"></a>getCurrentInstance</h3><p>getCurrentInstance 支持访问内部组件实例，用于高阶用法或库的开发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> internalInstance = getCurrentInstance()</span><br><span class="line"></span><br><span class="line">    internalInstance.appContext.config.globalProperties <span class="comment">// 访问 globalProperties</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getCurrentInstance 只能在 setup 或生命周期钩子中调用。</p><p>如需在 setup 或生命周期钩子外使用，请先在 setup 中调用 getCurrentInstance() 获取该实例然后再使用。</p></blockquote><h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><p>Teleport是Vue3中新增的特性，翻译成中文就是传送的意思。<code>Teleport</code>提供了一种简洁的方式，让组件的<code>html</code>在父组件界面外的特定标签下插入显示。也就是我们可以把 子组件 或者 dom节点 插入到任何你想插入到的地方去。</p><p>语法：</p><blockquote><p>使用<code>to</code>属性，指定要插入的节点。其值为选择器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;body&quot;&gt;&lt;/teleport&gt;</span><br></pre></td></tr></table></figure><p>我们使用Teleport实现一个模态窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;modalOpen = true&quot;&gt;</span><br><span class="line">    弹出一个全屏模态窗口&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  &lt;teleport to=&quot;body&quot;&gt;</span><br><span class="line">    &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是一个模态窗口!</span><br><span class="line">        我的父元素是&quot;body&quot;！</span><br><span class="line">        &lt;button @click=&quot;modalOpen = false&quot;&gt;Close&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/teleport&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref &#125; from &apos;vue&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const modalOpen = ref(true)</span><br><span class="line">    return &#123;</span><br><span class="line">      modalOpen</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.modal &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0; right: 0; bottom: 0; left: 0;</span><br><span class="line">  background-color: rgba(0,0,0,.5);</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.modal div &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  background-color: white;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  padding: 5px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><blockquote><p>Suspense 是一个试验性的新特性并且其 API 可能随时更改。它不应该被用在生产环境。</p></blockquote><p>在正确渲染组件之前进行一些异步请求是很常见的事。组件通常会在本地处理这种逻辑，绝大多数情况下这是非常完美的做法。</p><p>该 <code>&lt;suspense&gt;</code> 组件提供了另一个方案，允许等待整个组件树处理完毕而不是单个组件。</p><p>这个 <code>&lt;suspense&gt;</code> 组件有两个插槽。它们都只接收一个子节点。default 插槽里的节点会尽可能展示出来。如果不能，则展示 fallback 插槽里的节点。</p><p>常见的一个用例：用到了异步组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;suspense&gt;</span><br><span class="line">    &lt;template #default&gt;</span><br><span class="line">      &lt;async-demo /&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template #fallback&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Loading...</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;defineAsyncComponent&#125; from &apos;vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    AsyncDemo: defineAsyncComponent(() =&gt; import(&apos;./AsyncDemo.vue&apos;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;AsyncDemo&lt;/h2&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;AsyncDemo&apos;,</span><br><span class="line">  setup () &#123;</span><br><span class="line">     return new Promise((resolve) =&gt; &#123;</span><br><span class="line">       setTimeout(() =&gt; &#123;</span><br><span class="line">         resolve(&#123;</span><br><span class="line">           msg: &apos;async import&apos;</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;, 2000)</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/vue3-suspense-demo.gif" alt></p><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p>在Vue2中，<code>template</code>中只允许有一个根节点，但是在Vue3中，可以直接写多个根节点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="破坏性变化"><a href="#破坏性变化" class="headerlink" title="破坏性变化"></a>破坏性变化</h2><ul><li>Global API 改为应用程序实例调用</li><li>Global and internal APIs重构为可做摇树优化</li><li>model选项和v-bind的sync 修饰符被移除，统一为v-model参数形式</li><li>渲染函数API修改</li><li>函数式组件仅能通过简单函数方式创建</li><li>废弃在SFC的template上使用functional或者添加functional选项的方式声明函数式组件</li><li>异步组件要求使用defineAsyncComponent 方法创建</li><li>组件data选项应该总是声明为函数</li><li>自定义组件白名单执行于编译时</li><li>is属性仅限于用在component标签上</li><li><code>$scopedSlots</code> 属性被移除，都用$slots代替</li><li>特性强制策略变更</li><li>自定义指令API和组件一致</li><li>一些transition类名修改:<ul><li>v-enter -&gt; v-enter-from</li><li>v-leave -&gt; v-leave-from</li></ul></li><li>watch 选项 和$watch 不再支持点分隔符字符串路径, 使用计算函数作为其参数</li><li>Vue 2.x中应用程序根容器的 outerHTML 会被根组件的模板替换 (或被编译为template)。Vue 3.x现在使用应用根容器的innerHTML取代.</li></ul><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><ul><li>移除keyCode 作为 v-on 修饰符</li><li>on,on, on,off and $once 移除</li><li>Filters移除</li><li>Inline templates attributes移除</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文只是介绍了Vue3中的一些常用的新特性，更多具体内容需要大家详细阅读Vue3的官方文档：</p><p><a href="https://v3.cn.vuejs.org/" target="_blank" rel="noopener">https://v3.cn.vuejs.org/</a></p><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><ol><li><p><strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p></li><li><p>关注公众号：<strong>前端极客技术</strong>，我们一起学习一起进步。</p></li></ol></blockquote><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/%E5%89%8D%E7%AB%AF%E6%9E%81%E5%AE%A2%E6%8A%80%E6%9C%AF%E4%BA%8C%E7%BB%B4%E7%A0%81.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue3.0 周边生态现在已经完善得差不多了，新项目可以开始使用Vue3来开发了，今天我们先来学习Vue3的一些新特性。&lt;/p&gt;
&lt;h2 id=&quot;Composition-API&quot;&gt;&lt;a href=&quot;#Composition-API&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue3" scheme="http://www.chenhanpeng.com/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>vue项目配合nginx开启gzip提升页面打开速度</title>
    <link href="http://www.chenhanpeng.com/use-gzip-in-vue-project/"/>
    <id>http://www.chenhanpeng.com/use-gzip-in-vue-project/</id>
    <published>2021-05-20T07:01:05.000Z</published>
    <updated>2021-05-21T03:39:49.268Z</updated>
    
    <content type="html"><![CDATA[<p>用Vue开发移动端H5，可能很多同学会遇到最后打包上线，用户第一次打开可能有3s，甚至更久的白屏时间，白屏时间过长是很容易导致用户流失的，所以是必须要解决的问题。</p><p>经排查后发现是因为打包后的app.js太大，以及引用的一些插件安装包加载比较慢。</p><p>针对这种情况有很多解决方案：</p><ul><li>路由懒加载</li><li>打包文件中去掉map文件</li><li>CDN引入第三方库</li><li>代码压缩</li><li>分包</li><li>预渲染</li><li>开启Gzip</li></ul><p>gzip压缩一种非常方便，且效果明显的解决方法，使用gzip压缩可以减小60%以上的体积。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/summer/20210520152024.png" alt></p><p>从上图我们可以看到gzip压缩后的文件体积基本减小了60%左右，效果喜人。</p><p>下面我们主要看下如何开启Gzip打包，已经nginx如何配置开启Gzip。</p><h2 id="gzip介绍"><a href="#gzip介绍" class="headerlink" title="gzip介绍"></a>gzip介绍</h2><p>gzip属于在线压缩，在资源通过http发送报文给客户端的过程中，进行压缩，可以减少客户端带宽占用，减少文件传输大小。</p><p>html、js、css文件，甚至Json数据都可以用其来进行压缩。</p><p>但是不是每个浏览器都支持gzip的，如果知道客户端是否支持gzip呢，请求头中有个Accept-Encoding来标识对压缩的支持。客户端http请求头声明浏览器支持的压缩方式，服务端配置启用压缩，压缩的文件类型，压缩方式。当客户端请求到服务端的时候，服务器解析请求头，如果客户端支持gzip压缩，响应时对请求的资源进行压缩并返回给客户端，浏览器按照自己的方式解析，在http响应头，我们可以看到content-encoding:gzip，这是指服务端使用了gzip的压缩方式。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/summer/20210520152903.png" alt></p><p>那么怎么看有没有用gzip压缩的文件呢，打开f12，查看network，按照下面的方式过滤，如果content-encoding是gzip，说明返回的是gzip。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/summer/20210520153445.png" alt></p><p>nginx的gzip分为两种：</p><ul><li>nginx动态压缩，对每个请求先压缩再输出</li><li>nginx静态压缩，使用现成的扩展名为.gz的预压缩文件</li></ul><h2 id="nginx动态压缩配置-gzip"><a href="#nginx动态压缩配置-gzip" class="headerlink" title="nginx动态压缩配置 gzip"></a>nginx动态压缩配置 gzip</h2><p>gzip使用环境:http、server、location、if(x)，一般把它定义在nginx.conf的http{…..}之间</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_min_length    <span class="number">1</span>k;</span><br><span class="line">    gzip_buffers        <span class="number">4</span> <span class="number">8</span>k;</span><br><span class="line">    gzip_http_version  <span class="number">1.0</span>;</span><br><span class="line">    gzip_comp_level    <span class="number">4</span>;</span><br><span class="line">    gzip_proxied        any;</span><br><span class="line">    gzip_types          text/css</span><br><span class="line">                        text/javascript</span><br><span class="line">                        text/xml</span><br><span class="line">                        text/plain</span><br><span class="line">                        image/x-icon</span><br><span class="line">                        application/javascript</span><br><span class="line">                        application/x-javascript</span><br><span class="line">                        application/json;</span><br><span class="line">    gzip_vary          on;</span><br><span class="line">    gzip_disable        <span class="string">"MSIE [1-6]\."</span>;</span><br><span class="line">    #以下的配置省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx -s reload ：修改配置后重新加载生效</p><h3 id="配置项说明"><a href="#配置项说明" class="headerlink" title="配置项说明"></a>配置项说明</h3><ul><li>gzip：on为启用，off为关闭</li><li>gzip_min_length：设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。</li><li>gzip_buffers：获取多少内存用于缓存压缩结果，‘4 16k’表示以16k*4为单位获得</li><li>gzip_comp_level：gzip压缩比（1~9），越小压缩效果越差，但是越大处理越慢，所以一般取中间值;</li><li>gzip_types：对特定的MIME类型生效,其中’text/html’被系统强制启用</li><li>gzip_http_version：识别http协议的版本,早起浏览器可能不支持gzip自解压,用户会看到乱码</li><li>gzip_vary：启用应答头”Vary: Accept-Encoding”</li><li>gzip_proxied：nginx做为反向代理时启用,off(关闭所有代理结果的数据的压缩),expired(启用压缩,如果header头中包括”Expires”头信息),no-cache(启用压缩,header头中包含”Cache-Control:no-cache”),no-store(启用压缩,header头中包含”Cache-Control:no-store”),private(启用压缩,header头中包含”Cache-Control:private”),no_last_modefied(启用压缩,header头中不包含”Last-Modified”),no_etag(启用压缩,如果header头中不包含”Etag”头信息),auth(启用压缩,如果header头中包含”Authorization”头信息)</li><li>gzip_disable：(IE5.5和IE6 SP1使用msie6参数来禁止gzip压缩 )指定哪些不需要gzip压缩的浏览器(将和User-Agents进行匹配),依赖于PCRE库</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>开启gzip，资源下载体积减小了，下载效率提升了，但是在线gzip比较占用CPU，和 <code>gzip_static</code> 相比还是不太友好。</p><h2 id="nginx静态压缩配置gzip-static"><a href="#nginx静态压缩配置gzip-static" class="headerlink" title="nginx静态压缩配置gzip_static"></a>nginx静态压缩配置gzip_static</h2><p>在前端代码打包构建bundle的时候，一般都有根据一定的算法自动压缩代码成gz文件的webpack插件。</p><p>当我们不在 nginx 开启 gzip_static的时候，发现生产的gz文件并没有被运行。</p><p>gzip_static是会自动执行gz文件的，这样的就避免了通过gzip自动压缩。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  gzip_static  on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何判断gzip-static是否生效"><a href="#如何判断gzip-static是否生效" class="headerlink" title="如何判断gzip_static是否生效"></a>如何判断gzip_static是否生效</h3><p>在请求的response headers里面的Etag里面，没有<code>W/</code>就表明使用的是我们自己的 .gz 文件。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/summer/20210521113526.png" alt></p><h3 id="Vue项目打包-gz文件"><a href="#Vue项目打包-gz文件" class="headerlink" title="Vue项目打包.gz文件"></a>Vue项目打包.gz文件</h3><h4 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1. 安装插件"></a>1. 安装插件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install compression-webpack-plugin -D</span><br></pre></td></tr></table></figure><h4 id="2-在vue-config-js中配置"><a href="#2-在vue-config-js中配置" class="headerlink" title="2. 在vue.config.js中配置"></a>2. 在vue.config.js中配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">        test: <span class="regexp">/\.js$|\.html$|\.css/</span>,</span><br><span class="line">        threshold: <span class="number">10240</span>,</span><br><span class="line">        deleteOriginalAssets: <span class="literal">false</span>,</span><br><span class="line">        algorithm: <span class="string">'gzip'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态压缩和静态压缩结合使用"><a href="#动态压缩和静态压缩结合使用" class="headerlink" title="动态压缩和静态压缩结合使用"></a>动态压缩和静态压缩结合使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    gzip_static  on;</span><br><span class="line">    gzip_proxied expired no-cache no-store private auth;</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_min_length    <span class="number">1</span>k;</span><br><span class="line">    gzip_buffers        <span class="number">4</span> <span class="number">8</span>k;</span><br><span class="line">    gzip_http_version  <span class="number">1.0</span>;</span><br><span class="line">    gzip_comp_level    <span class="number">8</span>;</span><br><span class="line">    gzip_types          application/javascript text/css image/gif;</span><br><span class="line">    gzip_vary          on;</span><br><span class="line">    gzip_disable        <span class="string">"MSIE [1-6]\."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先尝试使用静态压缩，如果有则返回 .gz 的预压缩文件，否则尝试动态压缩。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>vue重新打包部署后，nginx配置后重新加载，再打开页面速度是不是快了很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用Vue开发移动端H5，可能很多同学会遇到最后打包上线，用户第一次打开可能有3s，甚至更久的白屏时间，白屏时间过长是很容易导致用户流失的，所以是必须要解决的问题。&lt;/p&gt;
&lt;p&gt;经排查后发现是因为打包后的app.js太大，以及引用的一些插件安装包加载比较慢。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="解决方案" scheme="http://www.chenhanpeng.com/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="vue" scheme="http://www.chenhanpeng.com/tags/vue/"/>
    
      <category term="解决方案" scheme="http://www.chenhanpeng.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="gzip压缩" scheme="http://www.chenhanpeng.com/tags/gzip%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>面试经常提到的重排和重绘，你真的了解吗？</title>
    <link href="http://www.chenhanpeng.com/reflow-and-repaint/"/>
    <id>http://www.chenhanpeng.com/reflow-and-repaint/</id>
    <published>2021-05-17T15:46:03.000Z</published>
    <updated>2021-05-18T00:42:17.866Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章 <a href>「浏览器渲染流程」你知道HTML、CSS、JS文件在浏览器中是如何转化成页面的吗？</a> 学习了浏览器的页面渲染流程，在文章的最后我们提到了两个和渲染流程有关的概念：重排和重绘。理解这两个概念对我们做Web性能优化会有很大的帮助。</p><h2 id="重排-reflow"><a href="#重排-reflow" class="headerlink" title="重排(reflow)"></a>重排(reflow)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当更新了元素的几何属性，那么浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排，也称为“回流”。</p><p>例如我们通过JS或CSS修改了元素的宽度和高度，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。</p><p>渲染树的节点发生改变，影响了该节点的几何属性，导致该节点位置发生变化，此时就会触发浏览器重排并重新生成渲染树。重排意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。</p><p>重排需要更新完整的渲染流水线，所以开销也是最大的。</p><h3 id="常见的引起重排属性和方法"><a href="#常见的引起重排属性和方法" class="headerlink" title="常见的引起重排属性和方法"></a>常见的引起重排属性和方法</h3><p>任何会改变元素的位置和尺寸大小的操作，都会触发重排。常见的例子如下：</p><ul><li>添加或删除可见的DOM元素</li><li>元素尺寸改变</li><li>内容变化，比如在input框中输入文字</li><li>浏览器窗口尺寸改变</li><li>计算offsetTop、offsetLeft等布局信息</li><li>设置style属性的值</li><li>激活CSS伪类，例如 :hover</li><li>查询某些属性或调用某些方法</li></ul><h4 id="几何属性"><a href="#几何属性" class="headerlink" title="几何属性"></a>几何属性</h4><p>几何属性：包括布局、尺寸等可用数学几何衡量的属性。</p><ul><li>布局：display、float、position、list、table、flex、columns、grid</li><li>尺寸：margin、padding、border、width、height</li></ul><h4 id="获取布局信息的属性或方法"><a href="#获取布局信息的属性或方法" class="headerlink" title="获取布局信息的属性或方法"></a>获取布局信息的属性或方法</h4><p>获取布局信息的属性如下：</p><ul><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ul><p>看到这里有的人可能会疑惑，我们只是获取这些属性值，并没有改变它，为什么会触发重排？</p><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会<strong>强制清空队列</strong>，因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。</p><p>所以我们应避免频繁使用上述的属性。</p><h3 id="重排的影响范围"><a href="#重排的影响范围" class="headerlink" title="重排的影响范围"></a>重排的影响范围</h3><p>浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围的DOM重新排列，影响的范围分两种：</p><h4 id="全局范围"><a href="#全局范围" class="headerlink" title="全局范围"></a>全局范围</h4><p>从根节点html开始对整个渲染树重新布局。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>BDing<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>male<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>loving<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中的p节点发生重排时，它的父节点div和body也会发生重排，甚至h5和ol节点也会受到影响。</p><h4 id="局部范围"><a href="#局部范围" class="headerlink" title="局部范围"></a>局部范围</h4><p>对渲染树的某部分或某一渲染对象进行重新布局。</p><p>例如：讲一个DOM元素的宽高等几何信息写死，然后在DOM元素内部触发重排，就只会重新渲染该DOM元素内部的元素，而不会影响到外界。</p><h2 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(repaint)</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>更新了元素的绘制属性，但没有改变布局，重新把元素外观绘制出来的过程叫做重绘。例如更改某些元素的背景颜色。</p><p>重绘并没有引起元素几何属性的改变，所以就直接进入绘制阶段，然后执行之后的一系列子阶段。</p><p>和重排相比，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p><p>重排一定会伴随重绘，重绘却不一定伴随重排。</p><h3 id="外观属性"><a href="#外观属性" class="headerlink" title="外观属性"></a>外观属性</h3><p>包括界面、文字等可用状态向量描述的属性</p><ul><li>界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip、border-radius、background-size、visibility</li><li>文字：text、font、word</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>重排和重绘在操作节点样式时频繁出现，同时也存在很大程度上的性能问题。重排成本比重绘成本高得多，因为一个节点的重排可能导致子节点、兄弟节点或祖先节点的重排，所以我们要尽可能减少重排次数、重排范围。</p><h3 id="使用visibility-hidden替换display-none"><a href="#使用visibility-hidden替换display-none" class="headerlink" title="使用visibility:hidden替换display:none"></a>使用visibility:hidden替换display:none</h3><p>通过下面四个方面来看看两者有什么区别：</p><ul><li><p>占位表现</p><ul><li>display:none：不占据空间</li><li>visibility:hidden：占据空间</li></ul></li><li><p>触发影响</p><ul><li>display:none：触发重排重绘</li><li>visibility:hidden：触发重绘</li></ul></li><li><p>过渡影响</p><ul><li>display:none：影响过渡不影响动画</li><li>visibility:hidden：过渡和动画都不影响</li></ul></li><li><p>株连效果</p><ul><li>display:none：自身及其子节点全都不可见</li><li>visibility:hidden：自身及其子节点都不可见，但可声明子节点visibility:visible单独显示</li></ul></li></ul><h3 id="避免使用Table布局"><a href="#避免使用Table布局" class="headerlink" title="避免使用Table布局"></a>避免使用Table布局</h3><p>Table布局可能很小的一个改动就会造成整个table重排。</p><p>通常可用 ul、li、span等标签取代 table 系列标签生成表格</p><h3 id="避免设置多层内联样式"><a href="#避免设置多层内联样式" class="headerlink" title="避免设置多层内联样式"></a>避免设置多层内联样式</h3><p>浏览器的CSS解析器解析css文件时，对CSS规则是从右到左匹配查找，样式层级过多会影响重排重绘效率。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  span &#123;</span></span><br><span class="line"><span class="undefined">    color: red;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  div &gt; a &gt; span &#123;</span></span><br><span class="line"><span class="undefined">    color: red;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>百度搜索<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。</p><h3 id="将频繁重绘或重排的节点设置为图层"><a href="#将频繁重绘或重排的节点设置为图层" class="headerlink" title="将频繁重绘或重排的节点设置为图层"></a>将频繁重绘或重排的节点设置为图层</h3><p>上一篇文章中我们构建完布局树之后，我们会进行分层，将页面分为很多个图层，如果不对图层添加关联，图层之间是不会相互影响的。</p><p>因此，在浏览器中将频繁重排或重绘的节点设置为一张新图层，那么新图层就能够阻止节点的渲染行为影响别的节点。</p><p>设置新图层的方法：</p><ul><li>将节点设置为video或iframe</li><li>为节点添加 will-change 属性</li></ul><h3 id="使用requestAnimationFrame作为动画帧"><a href="#使用requestAnimationFrame作为动画帧" class="headerlink" title="使用requestAnimationFrame作为动画帧"></a>使用requestAnimationFrame作为动画帧</h3><p>动画速度越快，重排次数越多，浏览器刷新频率为60Hz，即每16.6ms更新一次，而requestAnimationFrame()正是以16.6ms的速度更新一次。所以可用requestAnimationFrame()代替setInterval()。</p><h3 id="对于复杂动画效果-使用绝对定位让其脱离文档流"><a href="#对于复杂动画效果-使用绝对定位让其脱离文档流" class="headerlink" title="对于复杂动画效果,使用绝对定位让其脱离文档流"></a>对于复杂动画效果,使用绝对定位让其脱离文档流</h3><p>对于复杂动画效果，由于会经常的引起重排重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的重排。</p><h3 id="动态改变类而不改变样式"><a href="#动态改变类而不改变样式" class="headerlink" title="动态改变类而不改变样式"></a>动态改变类而不改变样式</h3><p>不要尝试每次操作DOM去改变节点样式，这样会频繁触发重排。</p><p>更好的方式是使用新的类名预定义节点样式，在执行逻辑操作时收集并确认最终更换的类名集合，在适合时机一次性动态替换原来的类名集合。</p><p>具体的实现可以看下HTML DOM元素属性 <code>classList</code>。</p><h3 id="避免触发同步布局事件"><a href="#避免触发同步布局事件" class="headerlink" title="避免触发同步布局事件"></a>避免触发同步布局事件</h3><p>先来看下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> top = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>).style.top;</span><br><span class="line">  <span class="built_in">console</span>.log(top)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。</p><p>上面代码中每次循环操作DOM都会发生重排，应该在循环外使用变量保存一些不会变化的DOM映射值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> top = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>).style.top;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(top)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改DOM</h3><p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少重排重绘次数：</p><ul><li><ol><li>使元素脱离文档流</li></ol></li><li><ol start="2"><li>对其进行多次修改</li></ol></li><li><ol start="3"><li>将元素带回到文档中。</li></ol></li></ul><p>该过程的第一步和第三步可能会引起重排，但是经过第一步之后，对DOM的所有修改都不会引起重排，因为它已经不在渲染树了。</p><p>有三种方式可以让DOM脱离文档流：</p><ul><li><p>隐藏要操作的dom<br>在要操作dom之前，通过display隐藏dom，当操作完成之后，再将dom的display属性置为可见，因为不可见的元素不会触发重排和重绘。</p></li><li><p>通过使用<code>DocumentFragment</code>创建一个dom碎片，在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排。</p></li><li><p>复制节点，在副本上工作，然后替换它。</p></li></ul><blockquote><p>当然我们也可以使用框架来实现批量修改DOM，比如Vue、React。</p></blockquote><h3 id="CSS3硬件加速（GPU加速）"><a href="#CSS3硬件加速（GPU加速）" class="headerlink" title="CSS3硬件加速（GPU加速）"></a>CSS3硬件加速（GPU加速）</h3><p>使用CSS3硬件加速，可以让 <code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起重拍重绘，但对于动画的其它属性，比如background-color这些，还是会引起重排重绘的，不过它还是可以提升这些动画的性能。</p><p>常见的触发CSS3硬件加速的CSS属性有：</p><ul><li>transform</li><li>opacity</li><li>filters</li><li>will-change</li></ul><p><strong>启动硬件加速注意点：</strong></p><ul><li>如果为太多元素使用CSS3硬件加速，会导致内存占用较大，也会从另一方面导致性能问题</li><li>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</li></ul><p>我们通过下面这个例子来看验证一下CSS3硬件加速这个优化方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    #container &#123;</span></span><br><span class="line"><span class="undefined">      width: 300px;</span></span><br><span class="line"><span class="undefined">      height: 300px;</span></span><br><span class="line"><span class="undefined">      position: absolute;</span></span><br><span class="line"><span class="undefined">      border: 1px solid burlywood;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .rect &#123;</span></span><br><span class="line"><span class="undefined">      width: 100px;</span></span><br><span class="line"><span class="undefined">      height: 100px;</span></span><br><span class="line"><span class="undefined">      left: 0;</span></span><br><span class="line"><span class="undefined">      top: 0;</span></span><br><span class="line"><span class="undefined">      background-color: gray;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .animate .rect &#123;</span></span><br><span class="line"><span class="undefined">      animation: run-around 4s ease-in-out infinite;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    @keyframes run-around &#123;</span></span><br><span class="line"><span class="undefined">      0% &#123;</span></span><br><span class="line"><span class="undefined">        transform: translate3d(0, 0, 0);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      25% &#123;</span></span><br><span class="line"><span class="undefined">        transform: translate3d(200px, 0, 0);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      50% &#123;</span></span><br><span class="line"><span class="undefined">        transform: translate3d(200px, 200px, 0);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">      75% &#123;</span></span><br><span class="line"><span class="undefined">        transform: translate3d(0, 200px, 0);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"container"</span>)</span></span><br><span class="line"><span class="javascript">      el.classList.contains(<span class="string">'animate'</span>) ? el.classList.remove(<span class="string">'animate'</span>) : el.classList.add(<span class="string">'animate'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"start()"</span>&gt;</span>开启/停止动画<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rect"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过Chrome浏览器的Performance捕获了一段时间的重排重绘情况，结果如下：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210517202335.png" alt></p><p>当动画进行的时候，没有发生任何的重排或重绘。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的学习，我们可以总结出以下几点：</p><ul><li>重排是因为元素的几何属性更改触发的</li><li>重绘是由于元素的绘制属性更改触发的</li><li>触发重排也一定会触发重绘，触发重绘不一定会触发重排</li><li>重排的成本高于重绘</li><li>减少重排次数、重排范围是Web性能优化的基本思路</li></ul><p>文章到这里正文内容就结束了，你是否已经清楚什么是重排和重绘？为什么减少重排重绘能够优化Web性能？欢迎留言讨论。</p><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><ol><li><p><strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p></li><li><p>关注公众号：<strong>前端极客技术</strong>，我们一起学习一起进步。</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章 &lt;a href&gt;「浏览器渲染流程」你知道HTML、CSS、JS文件在浏览器中是如何转化成页面的吗？&lt;/a&gt; 学习了浏览器的页面渲染流程，在文章的最后我们提到了两个和渲染流程有关的概念：重排和重绘。理解这两个概念对我们做Web性能优化会有很大的帮助。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://www.chenhanpeng.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="重排和重绘" scheme="http://www.chenhanpeng.com/tags/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>前端必读书籍推荐和海量前端学习资源分享</title>
    <link href="http://www.chenhanpeng.com/fe-books-recommendation-and-share/"/>
    <id>http://www.chenhanpeng.com/fe-books-recommendation-and-share/</id>
    <published>2021-05-16T07:00:08.000Z</published>
    <updated>2021-05-18T01:15:04.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML和CSS书籍推荐"><a href="#HTML和CSS书籍推荐" class="headerlink" title="HTML和CSS书籍推荐"></a>HTML和CSS书籍推荐</h2><h3 id="《Head-First-HTML与CSS-第2版-》"><a href="#《Head-First-HTML与CSS-第2版-》" class="headerlink" title="《Head First HTML与CSS(第2版)》"></a>《Head First HTML与CSS(第2版)》</h3><p>豆瓣评分 9.2。是前端入门的经典书籍，手把手教学，内容幽默有趣，丰富的案例让你从 0 开始学前端。前端初学者首选书籍，工作多年的前端也可以阅读。</p><h3 id="《精通CSS：高级Web标准解决方案-第3版-》"><a href="#《精通CSS：高级Web标准解决方案-第3版-》" class="headerlink" title="《精通CSS：高级Web标准解决方案(第3版)》"></a>《精通CSS：高级Web标准解决方案(第3版)》</h3><p>豆瓣评分 7.6。前端大神Winter在最近公开推荐过这本书，将它和《JavaScript高级程序设计（第4版）》列为前端必读。书中介绍了涉及字体、网页布局、响应式Web设计、表单、动画等方面的实用技巧，并讨论了如何实现稳健、灵活、无障碍访问的Web设计，以及在技术层面如何实现跨浏览器方案和后备方案。</p><h3 id="《CSS权威指南-第三版-》"><a href="#《CSS权威指南-第三版-》" class="headerlink" title="《CSS权威指南(第三版)》"></a>《CSS权威指南(第三版)》</h3><p>豆瓣评分 8.5。这本书也是非常的经典了，2007 年的书了，但是无不影响这本书作为 CSS 的经典著作，把原理讲得非常的通透，除了 w3c 标准，算最权威的一本了，毕竟权威指南，可以当做开发工具书来查阅。</p><h3 id="《CSS揭秘》"><a href="#《CSS揭秘》" class="headerlink" title="《CSS揭秘》"></a>《CSS揭秘》</h3><p>豆瓣评分9.4。神书，47 个 css 技巧让你在面对各种 css 问题的时候游刃有余。豆瓣评分 9.4 ，是 css 书籍中评分最高的了，css 进阶必备。</p><p>以上PDF版电子书下载：</p><blockquote><p>关注公众号：【前端极客技术】，发送【学习资源】，即可获取网盘下载链接。</p></blockquote><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/fegeek_qrcode.png" alt></p><h2 id="JavaScript书籍推荐"><a href="#JavaScript书籍推荐" class="headerlink" title="JavaScript书籍推荐"></a>JavaScript书籍推荐</h2><h3 id="《JavaScript高级程序设计-第4版-》"><a href="#《JavaScript高级程序设计-第4版-》" class="headerlink" title="《JavaScript高级程序设计(第4版)》"></a>《JavaScript高级程序设计(第4版)》</h3><p>豆瓣评分 9.2。俗称红宝书，是JavaScript入门书籍最佳选择之一。Zakas大神把概念深入浅出，将JavaScript的语法要点讲清楚明白。作为一名前端开发，这本书至少要通读一遍。而且看完这本，后续看其它进阶书籍会比较好。</p><h3 id="《JavaScript权威指南》"><a href="#《JavaScript权威指南》" class="headerlink" title="《JavaScript权威指南》"></a>《JavaScript权威指南》</h3><p>豆瓣评分 8.8。犀牛书是每个FE都绕不过的一本书，可以先大致通读几遍，也可以把其当作工具书，时时翻阅。</p><h3 id="《你不知道的JavaScript》"><a href="#《你不知道的JavaScript》" class="headerlink" title="《你不知道的JavaScript》"></a>《你不知道的JavaScript》</h3><p>豆瓣评分 9.3。堪称JavaScript的神书，分为上中下三册。书中的闭包、异步这些内容讲得很通透，读完有一种醍醐灌顶的感觉，值得花时间好好看一遍。</p><h3 id="《ES6-标准入门（第3版）》"><a href="#《ES6-标准入门（第3版）》" class="headerlink" title="《ES6 标准入门（第3版）》"></a>《ES6 标准入门（第3版）》</h3><p>还有阮一峰老师的开源书籍《ES6标准入门》也是值得推荐的。是一本开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。虽然是开源书籍，但是有条件的可以购买实体书，支持一下阮一峰老师。</p><p>开源书籍地址：<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a></p><h3 id="《JavaScript-DOM高级程序设计》"><a href="#《JavaScript-DOM高级程序设计》" class="headerlink" title="《JavaScript DOM高级程序设计》"></a>《JavaScript DOM高级程序设计》</h3><p>通过学习本书，可以理解一个JS的库如何产生，自己动手写一个简单的自己的JS库，如果你打算研究其他的JS库或者正在研究其他的JS库，那么这本书会使你的理解达到新的高度，进阶高级必读，写库必读。</p><h3 id="《JavaScript-DOM编程艺术-第2版-》"><a href="#《JavaScript-DOM编程艺术-第2版-》" class="headerlink" title="《JavaScript DOM编程艺术(第2版)》"></a>《JavaScript DOM编程艺术(第2版)》</h3><p>豆瓣评分 8.7。本 书在简洁明快地讲述JavaScript和DOM的基本知识之后，通过几个实例演示了专业水准的网页开发技术，透彻阐述了平稳退化等一批至关重要的 JavaScript编程原则和最佳实践。</p><h3 id="《javascript设计模式与开发实践》"><a href="#《javascript设计模式与开发实践》" class="headerlink" title="《javascript设计模式与开发实践》"></a>《javascript设计模式与开发实践》</h3><p>前端设计模式类的书本来就很少，这本是腾讯前端AlloyTeam团队出品，综合讲述前端的设计模式，设计原则，编程技巧，代码重构等等。AlloyTeam有自己的资源站，感兴趣的读者可以自行搜索，资源还有博客非常多，质量也很高。</p><p>以上PDF版电子书下载：</p><blockquote><p>关注公众号：【前端极客技术】，发送【学习资源】，即可获取网盘下载链接。</p></blockquote><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/fegeek_qrcode.png" alt></p><h2 id="其他书籍推荐"><a href="#其他书籍推荐" class="headerlink" title="其他书籍推荐"></a>其他书籍推荐</h2><ul><li>《深入 React 技术栈》</li><li>《React 进阶之路》</li><li>《Web性能权威指南》</li><li>《深入浅出Node.js》</li></ul><h2 id="视频教程推荐"><a href="#视频教程推荐" class="headerlink" title="视频教程推荐"></a>视频教程推荐</h2><h3 id="极客时间付费课程"><a href="#极客时间付费课程" class="headerlink" title="极客时间付费课程"></a>极客时间付费课程</h3><ul><li>重学前端</li><li>浏览器工作原理与实践</li><li>JavaScript核心原理解析</li><li>Node.js开发实战</li><li>React实战进阶45讲</li><li>算法训练营</li></ul><h3 id="其他视频教程"><a href="#其他视频教程" class="headerlink" title="其他视频教程"></a>其他视频教程</h3><ul><li>黄轶老师的《Vue.js源码全方位深入解析》</li><li>React源码深度解析</li><li>前端面试之道</li></ul><h2 id="PDF电子书和视频教程资源下载"><a href="#PDF电子书和视频教程资源下载" class="headerlink" title="PDF电子书和视频教程资源下载"></a>PDF电子书和视频教程资源下载</h2><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210516211520.png" alt><br><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210516211542.png" alt><br><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210516211552.png" alt></p><p>上面电子书和视频教程获取方式：</p><blockquote><p>关注公众号：【前端极客技术】，发送【学习资源】，即可获取网盘下载链接。</p></blockquote><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/fegeek_qrcode.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTML和CSS书籍推荐&quot;&gt;&lt;a href=&quot;#HTML和CSS书籍推荐&quot; class=&quot;headerlink&quot; title=&quot;HTML和CSS书籍推荐&quot;&gt;&lt;/a&gt;HTML和CSS书籍推荐&lt;/h2&gt;&lt;h3 id=&quot;《Head-First-HTML与CSS-第2版-
      
    
    </summary>
    
      <category term="技术杂谈" scheme="http://www.chenhanpeng.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="书籍推荐" scheme="http://www.chenhanpeng.com/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
      <category term="资源分享" scheme="http://www.chenhanpeng.com/tags/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>「浏览器渲染流程」你知道HTML、CSS、JS文件在浏览器中是如何转化成页面的吗？</title>
    <link href="http://www.chenhanpeng.com/how-to-render-page-on-the-browser/"/>
    <id>http://www.chenhanpeng.com/how-to-render-page-on-the-browser/</id>
    <published>2021-05-12T23:55:41.000Z</published>
    <updated>2021-05-14T02:06:56.827Z</updated>
    
    <content type="html"><![CDATA[<p>在前面一篇文章：<a href>「高频面试题」浏览器从输入url到页面展示中间发生了什么</a> 中，我们有对浏览器的渲染流程做了一个概括性的介绍，今天这篇文章我们将深入学习这部分内容。</p><p>对于很多前端开发来说，平常做工主要专注于业务开发，对浏览器的渲染阶段可能不是很了解。实际上这个阶段很重要，了解浏览器的渲染过程，能让我们知道我们写的HTML、CSS、JS代码是如何被解析，并最终渲染成一个页面的，在页面性能优化的时候有相应的解决思路。</p><p>我们先来看一个问题：</p><blockquote><p>HTML、CSS、JS文件在浏览器中是如何转化成页面的？</p></blockquote><p>如果你回答不上来，那就往下看吧。</p><p>按照渲染的时间顺序，渲染过程可以分为下面几个子阶段：构建DOM树、样式计算、布局阶段、分层、栅格化和合成显示。</p><p>下面详细看下每个子阶段都做了哪些事情。</p><h2 id="1-构建DOM树"><a href="#1-构建DOM树" class="headerlink" title="1. 构建DOM树"></a>1. 构建DOM树</h2><p>HTML文档描述一个页面的结构，但是浏览器无法直接理解和使用HTML，所以需要通过<code>HTML解析器</code>将HTML转换成浏览器能够理解的结构——DOM树。</p><p>HTML文档中所有内容皆为节点，各节点之间有层级关系，彼此相连，构成DOM树。</p><p>构建过程：读取HTML文档的字节(Bytes)，将字节转换成字符(Chars)，依据字符确定标签(Tokens)，将标签转换成节点(Nodes)，以节点为基准构建DOM树。参考下图：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210512074020.png" alt></p><p>打开Chrome的开发者工具，在控制台输入 <code>document</code> 后回车，就能看到一个完整的DOM树结构，如下图所示：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/summer/20210512112935.png" alt></p><p>在控制台打印出来的DOM结构和HTML内容几乎一样，但和HTML不同的是，<strong>DOM是保存在内存中的树状结构</strong>，可以通过JavaScript来查询或修改其内容。</p><h2 id="2-样式计算"><a href="#2-样式计算" class="headerlink" title="2. 样式计算"></a>2. 样式计算</h2><p>样式计算这个阶段，是为了计算出DOM节点中每个元素的表现样式。</p><h3 id="2-1-解析CSS"><a href="#2-1-解析CSS" class="headerlink" title="2.1 解析CSS"></a>2.1 解析CSS</h3><p>CSS样式可以通过下面三种方式引入：</p><ul><li>通过link引用外部的CSS文件</li><li>style 标签内的CSS</li><li>元素的style属性内嵌的CSS</li></ul><p>和HTML一样，浏览器无法直接理解纯文本的CSS样式，需要通过<code>CSS解析器</code>将CSS解析成 <code>styleSheets</code> 结构，也就是我们常说的 <code>CSSOM树</code>。</p><p>styleSheets结构同样具备查询和修改功能：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.styleSheets</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/summer/20210512115223.png" alt></p><h3 id="2-2-属性值标准化"><a href="#2-2-属性值标准化" class="headerlink" title="2.2 属性值标准化"></a>2.2 属性值标准化</h3><p>属性值标准化看字面意思有点不好理解，我们通过下面一个例子来看看什么是属性值标准化：</p><p>在写CSS样式的时候，我们在设置color属性值的时候，经常会用white、red等，但是这种值浏览器的渲染引擎不容易理解，所以需要将所有值转换成渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p><blockquote><p>white标准化后的值为 rgb(255, 255, 255)</p></blockquote><h3 id="2-3-计算DOM树中每个节点的样式"><a href="#2-3-计算DOM树中每个节点的样式" class="headerlink" title="2.3 计算DOM树中每个节点的样式"></a>2.3 计算DOM树中每个节点的样式</h3><p>完成样式的属性值标准化后，就需要计算每个节点的样式属性，这个阶段CSS有两个规则我们需要清楚：</p><ul><li>继承规则：每个DOM节点都包含有父节点的样式</li><li>层叠规则：层叠是CSS的一个基本特征，是一个定义了如何合并来自多个源的属性值的算法。</li></ul><p>样式计算阶段是为了计算出DOM节点中每个元素的具体样式，在计算过程中需要遵守CSS的继承和层叠两个规则。</p><p>该阶段最终输出的内容是每个DOM节点的样式，并被保存在 ComputedStyle 的结构中。</p><h2 id="3-布局阶段"><a href="#3-布局阶段" class="headerlink" title="3. 布局阶段"></a>3. 布局阶段</h2><p>经过上面的两个步骤，我们已经拿到了DOM树和DOM树中元素的样式，接下来需要计算DOM树中可见元素的几何位置，这个计算过程就是布局。</p><h3 id="3-1-创建布局树"><a href="#3-1-创建布局树" class="headerlink" title="3.1 创建布局树"></a>3.1 创建布局树</h3><p>在DOM树中包含了一些不可见的元素，例如 head 标签，设置了 display:none 属性的元素，所以我们需要额外构建一棵只包含可见元素的布局树。</p><p>构建过程：从DOM树的根节点开始遍历，将所有可见的节点加到布局树中，忽略不可见的节点。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210513075023.png" alt></p><h3 id="3-2-布局计算"><a href="#3-2-布局计算" class="headerlink" title="3.2 布局计算"></a>3.2 布局计算</h3><p>到这里我们就有了一棵构建好的布局树，就可以开始计算布局树节点的坐标位置了。从根节点开始遍历，结合上面计算得到的样式，确定每个节点对象在页面上的具体大小和位置，将这些信息保存在布局树中。</p><p>布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。</p><h2 id="4-分层"><a href="#4-分层" class="headerlink" title="4. 分层"></a>4. 分层</h2><p>现在我们已经有了布局树，也知道了每个元素的具体位置信息，但是还不能开始绘制页面，因为页面中会有像3D变换、页面滚动、或者用 z-index 进行z轴排序等复杂效果，为了更方便实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树(LayerTree)。</p><p>在Chrome浏览器中，我们可以打开开发者工具，选择 Elements-Layers 标签，就可以看到页面的分层情况，如下图所示：<br><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210513062531.png" alt></p><p>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</p><p>到这里，我们构建了两棵树：布局树和图层树。下面我们来看下这两颗树之间的关系：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210513062934.png" alt></p><p>正常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。</p><p>那节点要满足什么条件才会被提升为一个单独的图层？只要满足下面其中一个条件即可：</p><ul><li><ol><li>拥有层叠上下文属性的元素会被提升为单独的一个图层</li></ol></li><li><ol start="2"><li>需要剪裁(clip)的地方也会被创建为图层。</li></ol></li></ul><h2 id="5-图层绘制"><a href="#5-图层绘制" class="headerlink" title="5. 图层绘制"></a>5. 图层绘制</h2><p>构建好图层树之后，渲染引擎就会对图层树中的每个图层进行绘制。</p><p>渲染引擎实现图层绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后将这些指令按照顺序组成一个待绘制列表。</p><h2 id="6-栅格化-raster-操作"><a href="#6-栅格化-raster-操作" class="headerlink" title="6. 栅格化(raster)操作"></a>6. 栅格化(raster)操作</h2><p>绘制一个图层时会生成一个绘制列表，这只是用来记录绘制顺序和绘制指令的列表，实际上绘制操作是由渲染引擎中的合成线程来完成的。</p><p>通过下图来看下渲染主线程和合成线程之间的关系：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210513064421.png" alt></p><p>当图层的绘制列表准备好后，主线程会把该绘制列表提交给合成线程，合成线程开始工作。</p><p>首先合成线程会将图层划分为图块(tile)，图块大小通常是 256<em>256 或者 512</em>512。</p><p>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210513064851.png" alt></p><h2 id="7-合成和显示"><a href="#7-合成和显示" class="headerlink" title="7. 合成和显示"></a>7. 合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p><p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>一个完整的渲染流程可以总结如下：</p><ul><li><p>1、渲染进程将HTML内容转换为浏览器能够读懂的DOM树结构。</p></li><li><p>2、渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</p></li><li><p>3、创建布局树，并计算元素的布局信息。</p></li><li><p>4、对布局树进行分层，并生成分层树。</p></li><li><p>5、为每个图层生成绘制列表，并将其提交到合成线程。</p></li><li><p>6、合成线程将图层分图块，并栅格化将图块转换成位图。</p></li><li><p>7、合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。</p></li></ul><p>渲染过程中还有两个我们经常听到的概念：重排和重绘。在这篇文章中就不细说，下一篇文章再详细介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前面一篇文章：&lt;a href&gt;「高频面试题」浏览器从输入url到页面展示中间发生了什么&lt;/a&gt; 中，我们有对浏览器的渲染流程做了一个概括性的介绍，今天这篇文章我们将深入学习这部分内容。&lt;/p&gt;
&lt;p&gt;对于很多前端开发来说，平常做工主要专注于业务开发，对浏览器的渲染阶段可能
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://www.chenhanpeng.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="渲染流程" scheme="http://www.chenhanpeng.com/tags/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>在cloudflare上创建一个免费的在线代理来解决gitalk授权登录报403问题</title>
    <link href="http://www.chenhanpeng.com/create-own-cors-anywhere-to-resolve-the-request-with-403/"/>
    <id>http://www.chenhanpeng.com/create-own-cors-anywhere-to-resolve-the-request-with-403/</id>
    <published>2021-04-21T03:30:11.000Z</published>
    <updated>2021-05-14T02:06:56.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2021-04-28-更新"><a href="#2021-04-28-更新" class="headerlink" title="2021.04.28 更新"></a>2021.04.28 更新</h2><p>针对403的问题，gitalk开发团队已经对其做了修复，解决方法如下：</p><p>更新版本到 1.7.2 或者修改配置增加 proxy: ‘<a href="https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token&#39;" target="_blank" rel="noopener">https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token&#39;</a></p><p>当然我们也可以自己动手搭建代理，如果有兴趣的话可以直接下拉看下面的 <a href="#create-cors-by-self">利用cloudflare worker搭建在线代理</a></p><hr><h2 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h2><p>前两天突然发现个人博客的gitalk评论功能出了问题，点击使用Github登录一直失败，打开控制台一查，发现下面这个请求报403。</p><blockquote><p><a href="https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token" target="_blank" rel="noopener">https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token</a></p></blockquote><p>cors-anywhere是一个用来解决跨域问题而生的反向代理，是一个开源框架。</p><blockquote><p><a href="https://github.com/Rob--W/cors-anywhere/issues/301" target="_blank" rel="noopener">PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301</a></p></blockquote><p>从Github上这个issue上我们可以知道，gitalk中用到的 <code>cors-anywhere.herokuapp.com</code> 这个网站原本是用来演示用的，从2021.1.31开始不再作为开放的代理服务，作者建议开发者自己维护一个代理网站。</p><h2 id="初步解决方案（不稳定不建议使用）"><a href="#初步解决方案（不稳定不建议使用）" class="headerlink" title="初步解决方案（不稳定不建议使用）"></a>初步解决方案（不稳定不建议使用）</h2><p>在gitalk的issue中看到别人分享的一个在线代理，先拿来用下：</p><blockquote><p><a href="https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token" target="_blank" rel="noopener">https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token</a></p></blockquote><p>我们现在配置文件_config.yml的gitalk配置项中加一个proxy：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">   enable: <span class="literal">true</span></span><br><span class="line">   clientID: </span><br><span class="line">   clientSecret: </span><br><span class="line">   accessToken: </span><br><span class="line">   repo: blog-comments</span><br><span class="line">   owner: Hanpeng-Chen</span><br><span class="line">   admin: [<span class="string">'Hanpeng-Chen'</span>]</span><br><span class="line">   perPage: <span class="number">10</span></span><br><span class="line">   distractionFreeMode: <span class="literal">true</span></span><br><span class="line">   language: zh-CN</span><br><span class="line">   proxy: https:<span class="comment">//netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token</span></span><br></pre></td></tr></table></figure></p><p>在gitalk.ejs中加上proxy配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">    <span class="comment">// Gitalk配置</span></span><br><span class="line">    language: <span class="string">"&lt;%= config.language%&gt;"</span>,</span><br><span class="line">    clientID: <span class="string">"&lt;%= theme.gitalk.clientID%&gt;"</span>,</span><br><span class="line">    clientSecret: <span class="string">"&lt;%= theme.gitalk.clientSecret%&gt;"</span>,</span><br><span class="line">    repo: <span class="string">"&lt;%= theme.gitalk.repo%&gt;"</span>,</span><br><span class="line">    owner: <span class="string">"&lt;%= theme.gitalk.owner%&gt;"</span>,</span><br><span class="line">    admin: [<span class="string">"&lt;%= theme.gitalk.admin%&gt;"</span>],</span><br><span class="line">    id: md5(location.pathname),</span><br><span class="line">    distractionFreeMode: <span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.gitalk.distractionFreeMode</span>%&gt;</span>,</span></span><br><span class="line"><span class="xml">    proxy: "<span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.gitalk.proxy</span> %&gt;</span>"</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure></p><p>重新部署后，点击Github登录，这次没有没有报403的问题，但是出现了下面“Error：Network Error”。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/summer/20210421101906.png" alt><br><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/summer/20210421102116.png" alt></p><p>查看了对应请求的应答码 <code>429</code>，表示请求太多，我个人估计是白嫖这个在线代理的人太多导致的。</p><p>既然白嫖的代理不能用，那我们就自己搭一个在线代理吧。</p><div id="create-cors-by-self"></div><h2 id="利用cloudflare-worker搭建在线代理"><a href="#利用cloudflare-worker搭建在线代理" class="headerlink" title="利用cloudflare worker搭建在线代理"></a>利用cloudflare worker搭建在线代理</h2><p>利用CloudFlare Worker创建在线代理，不需要我们有服务器，也不需要搭建Node.js服务，只需要注册一个CloudFlare账号，创建一个Worker，部署一个JS脚本就可以了，简单方便，下面我们就来看看如何创建吧。</p><p>首先你需要一个 CloudFlare 的账号，如果还没有的话就先注册一个吧：<a href="https://dash.cloudflare.com/" target="_blank" rel="noopener">点我注册</a></p><p>选择Workers，创建一个免费的Worker。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/summer/20210421095610.png" alt></p><p>免费版本每天10万次请求也足以应对个人使用或者是小范围分享了。</p><p>填写自己喜欢的二级域名，然后创建worker。</p><p>进入github项目的 <a href="https://github.com/Hanpeng-Chen/cloudflare-cors-anywhere/blob/master/index.js" target="_blank" rel="noopener">index.js</a>，复制代码。</p><p>清除脚本编辑器中的示例代码，将复制的代码粘贴进去。</p><blockquote><p>这里有个点需要注意：我们可以设置请求的黑白名单，这里的白名单我只设置了自己博客域名，大家可以根据自己的情况修改，当然也可以设置为<code>whitelist = [ &quot;.*&quot; ]</code>，这样的话知道你代理地址的人都可以用了，然而免费版本的每天只有10万次请求，如果用的人多了很容易就用完了，所以还是建议大家设置 whitelist。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blacklist = [ ];           <span class="comment">// regexp for blacklisted urls</span></span><br><span class="line"><span class="comment">// whitelist = [ ".*" ];     // regexp for whitelisted origins</span></span><br><span class="line">whitelist = [ <span class="string">"^http.?://www.chenhanpeng.com$"</span>, <span class="string">"chenhanpeng.com$"</span> ]</span><br></pre></td></tr></table></figure><p>修改好之后，点击 保存并部署，如果部署正常的话，我们就可以使用我们创建的在线代理了。</p><p>从右侧获取到你的worker域名并记下来，在上面提到的proxy配置项修改为如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy: https:<span class="comment">//cloudflare-cors-anywhere.hanpengchen.workers.dev/?https://github.com/login/oauth/access_token</span></span><br></pre></td></tr></table></figure><p>重新部署我们的博客，再次点击 使用Github登录，这次登录成功，没有报错，至此，个人在线代理就搭建成功了，博客的评论功能也能正常使用了，撒花！！！</p><h2 id="在线代理的原理了解"><a href="#在线代理的原理了解" class="headerlink" title="在线代理的原理了解"></a>在线代理的原理了解</h2><p>传统在线代理都是在服务端替换 HTML/JS/CSS 等资源中的 URL。这不仅需要对内容做大量的分析和处理，还需对流量进行解压和再压缩，消耗大量 CPU 资源。并且由于逻辑较复杂，通常使用 Python/PHP 等编程语言自己实现。</p><p>为降低服务端开销，本项目使用浏览器的一个黑科技 —— Service Worker。它能让 JS 拦截网页产生的请求，并能自定义返回内容，相当于在浏览器内部实现一个反向代理。这使得绝大部分的内容处理都可以在浏览器上完成，服务器只需纯粹的转发流量。</p><p>要是还有其它问题的话，欢迎留言讨论。</p><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术</strong>，我们一起学习一起进步。</p></blockquote><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/%E5%89%8D%E7%AB%AF%E6%9E%81%E5%AE%A2%E6%8A%80%E6%9C%AF%E4%BA%8C%E7%BB%B4%E7%A0%81.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2021-04-28-更新&quot;&gt;&lt;a href=&quot;#2021-04-28-更新&quot; class=&quot;headerlink&quot; title=&quot;2021.04.28 更新&quot;&gt;&lt;/a&gt;2021.04.28 更新&lt;/h2&gt;&lt;p&gt;针对403的问题，gitalk开发团队已经对其做了修
      
    
    </summary>
    
      <category term="技术杂谈" scheme="http://www.chenhanpeng.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="gitalk" scheme="http://www.chenhanpeng.com/tags/gitalk/"/>
    
      <category term="在线代理" scheme="http://www.chenhanpeng.com/tags/%E5%9C%A8%E7%BA%BF%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JS中的apply、call、bind你掌握了吗？一起来手写实现这三个方法吧</title>
    <link href="http://www.chenhanpeng.com/handwriting-apply-call-bind/"/>
    <id>http://www.chenhanpeng.com/handwriting-apply-call-bind/</id>
    <published>2021-04-20T23:35:39.000Z</published>
    <updated>2021-04-21T01:17:31.279Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Hanpeng_Chen</p><p>公众号：<strong>前端极客技术</strong></p></blockquote><p>apply、call和bind这三个方法在函数原型链中是比较重要的概念，和this关键字密切相关。如果你对这三个方法还不是很清楚的话，那么认真地阅读这篇文章吧，让我们一起来彻底掌握它们吧！</p><p>在开始介绍apply/call/bind 这三个方法之前，我们需要先来了解一下JS中的this指向问题。</p><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>在ES5中，我们只要牢记一句话：this永远指向最后调用它的那个对象，那么对于this的指向问题就比较好理解了。</p><h3 id="直接函数调用"><a href="#直接函数调用" class="headerlink" title="直接函数调用"></a>直接函数调用</h3><p>我们先来看一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global name'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'function name'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'in function'</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'out function'</span>, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></p><p>在浏览器控制台执行结果如下图所示：<br><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210420214029.png" alt></p><p>我们可以看到在全局环境中直接调用函数getName()相当于<code>window.getName()</code>，调用它的是全局对象window，所以this对象指向全局对象，也就是window对象。</p><h3 id="对象函数调用"><a href="#对象函数调用" class="headerlink" title="对象函数调用"></a>对象函数调用</h3><p>我们再看下面这个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global name'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'object name'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// &#123;name: "object name", getName: ƒ&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// object name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure></p><p>在上面这个例子中，函数 getName 时对象 obj 调用的，所以在 getName 函数中打印的 this 是 obj 对象本身，this.name 是 <code>object name</code>。</p><p>我们将上面的代码进行如下改造：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"global name"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"object name"</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.getName = getName;</span><br><span class="line">obj.getName(); <span class="comment">// object name</span></span><br><span class="line">getName(); <span class="comment">// global name</span></span><br></pre></td></tr></table></figure></p><p>在上面代码中，我们将 <code>getName</code> 函数的指针赋值给 <code>obj.getName</code>，<code>obj.getName()</code> 是对象函数调用方法，this指向obj本身，所以打印的this.name是 object name。</p><p>而全局环境调用<code>getName()</code>，等同于 <code>window.getName()</code>，打印的也就是 global name。</p><p>从上面两个示例我们可以总结出：对象函数调用，this指针指向调用函数的对象本身。</p><h3 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h3><p>接下来我们来看下构造函数里面this指针的指向问题，还是先看下面的示例代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewObject</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> NewObject(<span class="string">'obj'</span>)</span><br></pre></td></tr></table></figure></p><p>从上面例子我们可以看出：构造函数中的this指向新创建的对象本身，所以上面例子打印出来的name为 obj。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>直接函数调用，this指针指向全局环境；</li><li>对象函数调用，this指针指向调用函数的对象本身；</li><li>构造函数调用，this指针指向新创建的对象本身。</li></ul><h2 id="改变this的指向的几种方法"><a href="#改变this的指向的几种方法" class="headerlink" title="改变this的指向的几种方法"></a>改变this的指向的几种方法</h2><p>改变this的指向的方法主要有以下几种：</p><ul><li>使用ES6中的箭头函数</li><li>在函数内部使用 _this = this</li><li>使用apply、call、bind</li><li>new实例化一个对象</li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数中的this只取决于它外面的第一个不是箭头函数的函数的this，并且箭头函数的this一旦绑定了上下文，就不会被任何代码改变。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo()()()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><h3 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 _this = this</h3><p>先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global name'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj name'</span>,</span><br><span class="line">  fn1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  fn2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      _this.fn1()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn2() <span class="comment">// obj name</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，如果fn2函数不通过_this变量保存上下文，而是在setTimeout延时函数中直接使用this的话，这时的this指向的是window，但是window对象上并没有定义fn1函数，程序就会报错。</p><h3 id="new实例化一个对象"><a href="#new实例化一个对象" class="headerlink" title="new实例化一个对象"></a>new实例化一个对象</h3><p>这个我们在上面构造函数调用中已经介绍过了，new实例化一个对象，this指针指向新创建的对象本身。</p><p>接下来我们一起来看看apply、call、bind的使用及其原理。</p><h2 id="apply、call、bind-基本介绍"><a href="#apply、call、bind-基本介绍" class="headerlink" title="apply、call、bind 基本介绍"></a>apply、call、bind 基本介绍</h2><p><strong>基本语法：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn.apply(thisArg, [p1, p2, ...])</span><br><span class="line">fn.call(thisArg, p1, p2, ...)</span><br><span class="line">fn.bind(thisArg, p1, p2, ...)</span><br></pre></td></tr></table></figure></p><p>这三个方法是挂在Function对象上的，<strong>调用这三个方法的必须是一个函数。</strong></p><p>这三个方法的共有作用：<strong>改变函数fn的this指向</strong>。</p><p>call和apply的区别在于:传参的写法不同，apply的第2个参数是数组，call则是从第2个至第n个都是给fn的传参。</p><p>bind和上面两个方法又有所不同，bind虽然改变了fn的this指向，但不是马上执行，而apply和call是在改变了this指向后立即执行。</p><h2 id="apply-call-bind的核心理念：借用方法"><a href="#apply-call-bind的核心理念：借用方法" class="headerlink" title="apply/call/bind的核心理念：借用方法"></a>apply/call/bind的核心理念：借用方法</h2><p>我们先来看下面apply、call、bind这三个方法的简单示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  name: <span class="string">'dog'</span>,</span><br><span class="line">  getDetail: <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> has <span class="subst">$&#123;count&#125;</span> legs`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bird = &#123;</span><br><span class="line">  name: <span class="string">'bird'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> frog = &#123;</span><br><span class="line">  name: <span class="string">'frog'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog.getDetail(<span class="number">4</span>)); <span class="comment">// dog has 4 legs</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.getDetail.apply(bird, [<span class="number">2</span>])); <span class="comment">// bird has 2 legs</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.getDetail.call(frog, <span class="number">3</span>)); <span class="comment">// frog has 3 legs</span></span><br><span class="line"><span class="keyword">let</span> bird1 = dog.getDetail.bind(bird);</span><br><span class="line"><span class="built_in">console</span>.log(bird1(<span class="number">2</span>)); <span class="comment">// bird has 2 legs</span></span><br></pre></td></tr></table></figure></p><p>在上面代码中，dog对象有一个 <code>getDetail</code> 的方法，对象bird和frog也需要临时使用同样的方法，那么这时候我们可以借用dog对象的getDetail方法，这样既能达到目的，也能节省重复定义，节约内存空间。</p><p>这就是这三个方法的核心理念：借用方法。</p><h2 id="手写实现apply、call和bind"><a href="#手写实现apply、call和bind" class="headerlink" title="手写实现apply、call和bind"></a>手写实现apply、call和bind</h2><p>在大厂面试中，手写实现一个apply/call/bind是一道高频面试题，接下来我们一起来实现这三个方法：</p><h3 id="apply的实现"><a href="#apply的实现" class="headerlink" title="apply的实现"></a>apply的实现</h3><p>根据上面apply的原理和其借用方法的理念，我们来整理一下实现 apply 方法的思路：</p><ol><li><p>通过设置context的属性，将函数的this指向隐式绑定到 context上；</p></li><li><p>通过隐式绑定执行函数并传递参数；</p></li><li><p>删除临时属性，返回函数执行结果。</p></li></ol><p>具体实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="built_in">Object</span>(context) <span class="comment">// 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn(...args)'</span>);</span><br><span class="line">  <span class="comment">// 删除添加的函数</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，实现apply的关键在于 <code>eval</code> 这行代码。其中显示了用context这个临时变量来指定上下文，然后还是通过执行 <code>eval</code> 来执行 <code>context.fn</code> 这个函数，最后返回result。</p><p>如果不使用eval，我们还有下面的实现方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="built_in">Object</span>(context); <span class="comment">// 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给context新增一个独一无二的属性以免覆盖原来属性</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 通过隐式绑定的方式调用函数</span></span><br><span class="line">  <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">  <span class="comment">// 删除添加的函数</span></span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用Symbol临时存储函数，避免了跟上下文对象的原属性冲突的风险。</p><h3 id="call的实现"><a href="#call的实现" class="headerlink" title="call的实现"></a>call的实现</h3><p>call和apply基本原理差不多，只是参数存在区别，这里我们不再细说，直接看call方法的实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="built_in">Object</span>(context)</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn(...args)'</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind的实现"><a href="#bind的实现" class="headerlink" title="bind的实现"></a>bind的实现</h3><p>bind方法和其它两个方法的区别在于：bind方法是返回一个函数，而其它两个方法是直接返回执行结果。</p><p>实现思路和call基本相同，因为bind不需要返回执行结果，所以不需要用eval，而是需要通过返回一个函数的方式将结果返回，之后再执行这个结果，得到想要的结果。</p><p>具体实现思路如下：</p><ol><li><p>拷贝源函数：</p><ul><li>通过变量存储源函数</li><li>使用 <code>Object.create</code> 复制源函数的prototype给fbound</li></ul></li><li><p>返回拷贝的函数</p></li><li><p>调用拷贝的函数</p><ul><li>new调用判断：通过 <code>instanceof</code> 判断函数是否通过 new 调用，来决定绑定的 context</li><li>绑定 this，传递参数</li><li>返回源函数的执行结果</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'this must be a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.call(<span class="keyword">this</span> <span class="keyword">instanceof</span> fbound ? <span class="keyword">this</span> : <span class="built_in">Object</span>(context), ...args, ...arguments);</span><br><span class="line">    <span class="comment">// return self.call(this instanceof fbound ? this : Object(context), args.concat(Array.prototype.slice.call(arguments)))</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">    fbound.prototype = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.prototype);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到，实现 bind 的核心在于返回的时候需要返回一个函数，故这里的 fbound 需要返回，但是在返回的过程中原型链对象上的属性不能丢失。因此这里需要用Object.create 方法，将 this.prototype 上面的属性挂到 fbound 的原型上面，最后再返回 fbound。这样调用 bind 方法接收到函数的对象，再通过执行接收的函数，即可得到想要的结果。</p><p>看到这里，apply、call、bind这三个方法的实现你是否已经完全掌握了？如果没有的话那就自己动手多写几次吧！</p><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术</strong>，我们一起学习一起进步。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：Hanpeng_Chen&lt;/p&gt;
&lt;p&gt;公众号：&lt;strong&gt;前端极客技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;apply、call和bind这三个方法在函数原型链中是比较重要的概念，和this关键字密切相关。如果你
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
      <category term="原理源码" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://www.chenhanpeng.com/tags/JavaScript/"/>
    
      <category term="手写源码" scheme="http://www.chenhanpeng.com/tags/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>一起搞清楚JS中的new到底做了什么，并模拟实现一个new</title>
    <link href="http://www.chenhanpeng.com/js-new/"/>
    <id>http://www.chenhanpeng.com/js-new/</id>
    <published>2021-04-13T15:00:06.000Z</published>
    <updated>2021-04-21T01:17:30.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Hanpeng_Chen</p><p>公众号：<strong>前端极客技术</strong></p></blockquote><p>new关键字对于前端开发者来说是比较常见的操作，在互联网大厂的面试中，有时候会要求手写实现new。接下来我们一起看看new到底做了什么？如何模拟实现？</p><h2 id="new原理介绍"><a href="#new原理介绍" class="headerlink" title="new原理介绍"></a>new原理介绍</h2><h3 id="new概念"><a href="#new概念" class="headerlink" title="new概念"></a>new概念</h3><p>关于new关键字，MDN上是这样描述的：</p><blockquote><p><code>new</code>关键字创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p></blockquote><p>上面这句话也许有些难懂，我们先来看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Parent = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Parent(<span class="string">'张三'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child.getName());</span><br><span class="line"><span class="built_in">console</span>.log(child.age);</span><br></pre></td></tr></table></figure><p>从这个例子中，我们可以看到：实例child可以访问到Parent构造函数里的属性，也可以访问到Parent.prototype中的属性。</p><p>从输出结果可以看出：child是一个通过Parent这个构造函数生成的一个实例对象。</p><blockquote><p>那么关于new关键字的作用，我们可以理解为就是执行一个构造函数，返回一个实例对象，在new的过程中，根据构造函数的情况，来确定是否可以接受参数传递。</p></blockquote><h3 id="不使用new关键字会发生什么"><a href="#不使用new关键字会发生什么" class="headerlink" title="不使用new关键字会发生什么"></a>不使用new关键字会发生什么</h3><p>我们对上面代码进行改造一下，去掉new，会有什么变化？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Parent = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child1 = Parent(<span class="string">'张三'</span>, <span class="number">25</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.name) <span class="comment">// Cannot read property 'name' of undefined</span></span><br></pre></td></tr></table></figure><p>从上面代码我们可以看到，没有使用new关键词，返回的结果是<code>undefined</code>。我们直接打印age可以获取到值，是因为JavaScript代码在默认情况下this的指向是window。</p><h3 id="构造函数返回一个对象会发生什么？"><a href="#构造函数返回一个对象会发生什么？" class="headerlink" title="构造函数返回一个对象会发生什么？"></a>构造函数返回一个对象会发生什么？</h3><p>如果构造函数中有return一个对象的操作，结果会发生什么变化？我们再来看下面这段改造后的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">age</span>: <span class="number">30</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Parent(<span class="string">'张三'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123; age: 30 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>从上述代码的执行结果看到：如果构造函数return出来的是一个和this无关的对象时，new命令会直接返回这个新对象，而不是生成一个绑定了最新this的新对象并返回出来。</p><p>如果构造函数return回来的不是一个对象，那么还是会按照new的实现步骤，返回新生成的对象。我们通过下面的代码验证一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Chinese'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Parent(<span class="string">'张三'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// Parent &#123; name: '张三' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure></p><h3 id="小结：new到底做了什么？"><a href="#小结：new到底做了什么？" class="headerlink" title="小结：new到底做了什么？"></a>小结：new到底做了什么？</h3><p>new在这个生成实例过程中到底进行了哪些步骤来实现？我将其总结为下面几个步骤：</p><ul><li>创建一个空的简单JavaScript对象，即 <code>{}</code>；</li><li>将构造函数的作用域赋给新对象（this指向新对象）；</li><li>执行构造函数中的代码（为新对象添加属性）；</li><li>如果该函数没有返回对象，则返回this。</li></ul><h2 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h2><p>结合上面的内容，我们一起来手写实现new。</p><p>在开始写代码之前，我们先确定new被调用后大致做了那几件事：</p><ul><li>让实例可以访问到私有属性；</li><li>让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性；</li><li>构造函数返回的最后结果是引用数据类型。</li></ul><p>知道了new被调用后做了哪些事情，那么我们就可以开始手写实现它了。实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">ctor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> ctor !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'ctor must be a function'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建新的对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 让新创建的对象可以访问构造函数原型（constructor.prototype）所在原型链上的属性；</span></span><br><span class="line">  newObj.__proto__ = <span class="built_in">Object</span>.create(ctor.prototype);</span><br><span class="line">  <span class="comment">// 将构造函数的作用域赋给新对象（this指向新对象）；</span></span><br><span class="line">  <span class="comment">// 执行构造函数中的代码</span></span><br><span class="line">  <span class="keyword">let</span> res = ctor.apply(newObj, [...args]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isObject = <span class="keyword">typeof</span> res === <span class="string">'object'</span> &amp;&amp; res !== <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> isFunction = <span class="keyword">typeof</span> res === <span class="string">'function'</span>;</span><br><span class="line">  <span class="keyword">return</span> isObject || isFunction ? res : newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对我们上面模拟实现的new方法进行测试，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Parent = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = _new(Parent, <span class="string">'zhangsan'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// Parent &#123; name: 'zhangsan', age: 25 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age); <span class="comment">// 25 </span></span><br><span class="line"><span class="built_in">console</span>.log(p.getName()); <span class="comment">// zhangsan</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">age</span>: <span class="number">30</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = _new(Parent1, <span class="string">'lisi'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1); <span class="comment">// &#123; age: 30 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent2</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Chinese'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p2 = _new(Parent2, <span class="string">'wangwu'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p2); <span class="comment">// Parent &#123; name: 'wangwu' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name); <span class="comment">// wangwu</span></span><br></pre></td></tr></table></figure></p><p>从测试结果可以看出，我们模拟实现的_new方法和原生的new关键字调用结果是一样的。</p><p>到这里手写模拟实现new就结束了，你学会了吗？</p><p>如有发现不妥或可改进之处，欢迎留言指出。</p><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术</strong>，我们一起学习一起进步。</p></blockquote><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/%E5%89%8D%E7%AB%AF%E6%9E%81%E5%AE%A2%E6%8A%80%E6%9C%AF%E4%BA%8C%E7%BB%B4%E7%A0%81.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：Hanpeng_Chen&lt;/p&gt;
&lt;p&gt;公众号：&lt;strong&gt;前端极客技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;new关键字对于前端开发者来说是比较常见的操作，在互联网大厂的面试中，有时候会要求手写实现new。接下来
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
      <category term="原理源码" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://www.chenhanpeng.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一起手写实现符合Promise/A+规范的Promise源码</title>
    <link href="http://www.chenhanpeng.com/handwriting-promise-accord-with-promise-a-plus-specification/"/>
    <id>http://www.chenhanpeng.com/handwriting-promise-accord-with-promise-a-plus-specification/</id>
    <published>2021-03-28T02:09:59.000Z</published>
    <updated>2021-04-21T01:17:31.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Hanpeng_Chen</p><p>公众号：<strong>前端极客技术</strong></p></blockquote><p>Promise是JavaScript中异步编程的核心内容，也是前端面试的高频问题。关于Promise的基本用法这里不再详细介绍，接下来我们一起来实现一个符合 Promise/A+ 规范的Promise。</p><p>在开始写代码之前，我们要知道Promise/A+规范都有哪些内容。</p><h2 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise/A+ 规范"></a>Promise/A+ 规范</h2><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">https://promisesaplus.com/</a></p><p>上面是Promise/A+规范的官方地址，是一个英文版本，大家可以自行点击阅读。下面我把规范中比较关键的点进行说明：</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><blockquote><ol><li><p>promise 是一个具有then方法的对象或函数，它的行为符合该规范。</p></li><li><p>thenable 是一个定义了then方法的对象或函数。</p></li><li><p>value 可以是任何一个合法的JavaScript的值，包括undefined、thenable、promise。</p></li><li><p>exception 是一个异常，是在Promise里面可以用throw语句抛出的值。</p></li><li><p>reason 是一个Promise里reject之后返回的拒绝原因。</p></li></ol></blockquote><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul><li><ol><li>一个Promise有三种状态：pending、fulfilled、rejected。</li></ol></li><li><ol start="2"><li>当状态为pending时，可以转换为 fulfilled 或者 rejected。</li></ol></li><li><ol start="3"><li>当状态为 fulfilled 时，就不能再变为其他状态，必须返回一个不能再改变的值。</li></ol></li><li><ol start="4"><li>当状态为 rejected 时，就不能再变为其他状态，必须有一个promise被reject的原因，原因值也不能改变。</li></ol></li></ul><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><p>Promise必须拥有一个then方法，来访问最终的结果。</p><p>then方法有两个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p><p><strong>onFulfilled 和 onRejected</strong><br>onFulfilled和onRejected两个都是可选参数，两者都必须是函数类型。</p><p>如果onFulfilled是函数，必须在promise变成fulfilled时，调用 onFulfilled，参数是promise的value，onFulfilled只能被调用一次。</p><p>如果onRejected是函数，必须在promise变成rejected时，调用 onRejected，参数是promise的reason，onRejected只能被调用一次。</p><p><strong>then方法可以被多次调用</strong><br>then方法可以被一个Promise调用多次，<strong>且必须返回一个Promise对象</strong>。</p><p>如果promise变成了 fulfilled态，所有的onFulfilled回调都需要按照then的顺序执行</p><p>如果promise变成了 rejected态，所有的onRejected回调都需要按照then的顺序执行</p><p>Promise/A+规范的主要部分就是上面这些，接下来我们一起动手实现一个Promise。</p><h2 id="实现-Promise"><a href="#实现-Promise" class="headerlink" title="实现 Promise"></a>实现 Promise</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Promise构造函数接受一个 executor 函数，executor函数执行完同步或异步操作后，调用它的两个参数resolve和reject。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.status = PENDING;</span><br><span class="line">  self.data = <span class="literal">undefined</span>; <span class="comment">// Promise的值</span></span><br><span class="line">  self.onResolvedCallback = []; <span class="comment">// Promise resolve时的回调函数</span></span><br><span class="line">  self.onRejectedCallback = []; <span class="comment">// Promise rejected的回调函数集</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise构造函数中定义了resolve和reject两个函数，下面一起来看看这两个函数如何实现？</p><p>从规范中我们知道：resolve和reject函数主要是返回对应状态的值value或者reason，并将Promise内部的状态从pending变成对应的状态，并且在这个状态改变之后是不可逆的。</p><p>那么这两个函数要如何实现，可以看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      self.status = FULFILLED;</span><br><span class="line">      self.data = value;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line">        self.onResolvedCallback[i](value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">      self.status = REJECTED;</span><br><span class="line">      self.data = reason;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">        self.onRejectedCallback[i](reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="then方法的实现"><a href="#then方法的实现" class="headerlink" title="then方法的实现"></a>then方法的实现</h3><p>then方法接收两个参数，分别是Promise成功的回调 onFulfilled 和 失败的回调 onRejected。</p><p>如果调用then时，promise已经成功，则执行onFulfilled，并将value值作为参数传递进去；</p><p>如果promise已经失败，执行onRejected，将失败的原因reason作为参数传递进去。</p><p>如果promise的状态是pending，需要将onFulfilled和onRejected函数存放起来，等待状态确定后，再依次将对应的函数执行(发布订阅)</p><p>promise 可以then多次，promise 的then 方法返回一个 promise</p><p>我们把then方法实现的思路过了一遍，下面来看其实现代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据规范，如果then的参数不是function，则需要忽略它</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">    <span class="comment">// 如果promise状态确定为fulfilled，调用onFulFilled，但代码执行中可能会抛出，所以将其包裹在try/catch代码块中</span></span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onFulfilled(self.data)</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onRejected(self.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.data);</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.data)</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里一个符合Promise/A+规范的then方法基本实现了。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>在Promise/A+规范中，onFulfilled和onRejected两个函数需要异步调用。</p><p>并且规范中提到，要支持不同的Promise进行交互，关于不同的Promise交互详细说明点击下方链接查看：</p><p><a href="https://promisesaplus.com/#point-46" target="_blank" rel="noopener">https://promisesaplus.com/#point-46</a></p><p>基于上面两点，我们对上面实现的then方法中执行Promise的方法进行优化，在处理Promise进行resolve或reject时，加上 setTimeout(fn, 0)</p><p>优化后的完整代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.status = PENDING;</span><br><span class="line">  self.data = <span class="literal">undefined</span>; <span class="comment">// Promise的值</span></span><br><span class="line">  self.onResolvedCallback = []; <span class="comment">// Promise resolve时的回调函数</span></span><br><span class="line">  self.onRejectedCallback = []; <span class="comment">// Promise rejected的回调函数集</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">        self.status = FULFILLED;</span><br><span class="line">        self.data = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line">          self.onResolvedCallback[i](value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">        self.status = REJECTED;</span><br><span class="line">        self.data = reason;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">          self.onRejectedCallback[i](reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据规范，如果then的参数不是function，则需要忽略它</span></span><br><span class="line">  onFulfilled =</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">"function"</span> ? onFulfilled : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> r;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">    <span class="comment">// 如果promise状态确定为fulfilled，调用onFulFilled，但代码执行中可能会抛出，所以将其包裹在try/catch代码块中</span></span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.data);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.data);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(self.data);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(self.data);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> then;</span><br><span class="line">  <span class="keyword">let</span> thenCalledOrThrow = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaining cycle detected for promise'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.status === PENDING) &#123;</span><br><span class="line">      x.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        resolvePromise(promise2, v, resolve, reject)</span><br><span class="line">      &#125;, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((x !== <span class="literal">null</span>) &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(x, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>; <span class="comment">// 已经调用过</span></span><br><span class="line">          thenCalledOrThrow = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>;</span><br><span class="line">          thenCalledOrThrow = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>;</span><br><span class="line">      thenCalledOrThrow = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>有专门的测试脚本可以测试我们写的Promise是否符合Promise/A+规范。</p><p>首先在Promise实现的代码中，暴露一个deferred方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.defer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">  dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    dfd.resolve = resolve;</span><br><span class="line">    dfd.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Promise源码的目录执行npm安装和执行测试命令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -g promises-aplus-tests</span><br><span class="line"></span><br><span class="line">promises-aplus-tests <span class="built_in">Promise</span>.js</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210323235204.png" alt></p><p>promises-aplus-tests中共有872条测试用例。从上面的执行结果可以看出，我们手写的Promise通过所有用例。</p><h2 id="Promise其他方法的实现"><a href="#Promise其他方法的实现" class="headerlink" title="Promise其他方法的实现"></a>Promise其他方法的实现</h2><p>原生的Promise还提供了一些其他方法，比如：</p><ul><li>Promise.resolve()</li><li>Promise.reject()</li><li>Promise.prototype.catch()</li><li>Promise.prototype.finally()</li><li>Promise.all()</li><li>Promise.race()</li><li>…</li></ul><p>在面试中也经常碰到面试官要求手写实现这些方法，接下来我们一起看看这几个方法如何实现：</p><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promise.resolve(value)方法返回一个给定值解析后的Promise对象。</p><blockquote><ul><li><p>如果 value 是个 thenable 对象，返回的promise会“跟随”这个thenable的对象，采用它的最终状态</p></li><li><p>如果传入的value本身就是promise对象，那么Promise.resolve将不做任何修改、原封不动地返回这个promise对象。</p></li><li><p>其他情况，直接返回以该值为成功状态的promise对象。</p></li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> value.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        value.then(resolve, reject)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>Promise.reject方法和Promise.resolve不同，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h3><p>Promise.prototype.catch 用于指定出错时的回调，是特殊的then方法，catch之后，可以继续.then<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h3><p>不管成功还是失败，都会走到finally中,并且finally之后，还可以继续then。并且会将值原封不动的传递给后面的then.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all(promises) 返回一个promise对象</p><p>如果传入的参数是一个空的可迭代对象，那么此promise对象回调完成(resolve),只有此情况，是同步执行的，其它都是异步返回的。</p><p>如果传入的参数不包含任何 promise，则返回一个异步完成.</p><p>promises 中所有的promise都promise都“完成”时或参数中不包含 promise 时回调完成。</p><p>如果参数中有一个promise失败，那么Promise.all返回的promise对象失败</p><p>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  promises = <span class="built_in">Array</span>.from(promises); <span class="comment">// 将可迭代对象转换成数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">processValue</span>(<span class="params">i, value</span>) </span>&#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          processValue(i, data);</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。</p><p>如果传的参数数组是空，则返回的 promise 将永远等待。</p><p>如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  promises = <span class="built_in">Array</span>.from(promises);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(data);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文所有源代码：<a href="https://github.com/Hanpeng-Chen/html-js-demo-code/tree/main/handwriting-promise" target="_blank" rel="noopener">handwriting-promise</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次写难免遇到各种问题，只要对照规范多写几次，自己总结一下，你也可以很快写出通过测试的Promise源码。</p><p>如果你能根据PromiseA+的规范，写出符合规范的源码，那么我想，对于面试中的Promise相关的问题，都能够给出比较完美的答案。</p><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术</strong>，我们一起学习一起进步。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：Hanpeng_Chen&lt;/p&gt;
&lt;p&gt;公众号：&lt;strong&gt;前端极客技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Promise是JavaScript中异步编程的核心内容，也是前端面试的高频问题。关于Promise的基
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
      <category term="原理源码" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="JavaScript" scheme="http://www.chenhanpeng.com/tags/JavaScript/"/>
    
      <category term="原理源码" scheme="http://www.chenhanpeng.com/tags/%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>「高频面试题」浏览器从输入url到页面展示中间发生了什么</title>
    <link href="http://www.chenhanpeng.com/what-happens-when-you-type-in-a-url/"/>
    <id>http://www.chenhanpeng.com/what-happens-when-you-type-in-a-url/</id>
    <published>2021-03-17T23:57:40.000Z</published>
    <updated>2021-04-21T01:17:30.120Z</updated>
    
    <content type="html"><![CDATA[<p>“在浏览器中，从输入URL到页面展示，中间发生了什么？”这是一道经典的高频面试题，其中涉及了网络、操作系统、web等一系列的知识。接下来我们一起来看看要怎么回答这道题。</p><p>整个过程可以大致描述为：</p><h2 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h2><p>用户输入URL，浏览器会根据用户输入的信息判断是搜索内容还是请求的URL。如果是搜索内容，就将搜索内容+默认搜索引擎来合成新的带搜索关键字的URL。如果判断输入内容符合URL规则，地址栏会根据规则，把内容加上协议，合成为完整的URL。</p><h3 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h3><table><thead><tr><th>协议</th><th>默认端口号</th><th>传输协议</th></tr></thead><tbody><tr><td>http</td><td>80</td><td>超文本传输协议</td></tr><tr><td>https</td><td>443</td><td>在http的基础上进行了安全设置(SSL/TSL)证书认证</td></tr><tr><td>ftp</td><td>21</td><td>主要用于客户端电脑和服务器端的文件传输</td></tr></tbody></table><h3 id="URL的编码"><a href="#URL的编码" class="headerlink" title="URL的编码"></a>URL的编码</h3><p>因为网络标准规定了URL只能是字母和数字，还有一些特殊符号（-_.~ ! * ‘ ( ) ; : @ &amp; = + $ , / ? # [ ]，</p><p>对于一些特殊字符，在客户端和服务端传递的时候，需要进行编码和解码。</p><ul><li><p>encodeURI、decodeURI：对中文、空格等编码解码，适合给URL本身编码</p></li><li><p>encodeURIComponent、decodeURIComponent：对中文、空格 : /等编码解码，编码范围更广，适合给参数编码。</p></li><li><p>escape unescape 主要用于客户端不同页面之间的数据传输的时候，信息的编码解码（如：cookie）</p></li></ul><h2 id="检查缓存"><a href="#检查缓存" class="headerlink" title="检查缓存"></a>检查缓存</h2><p>接下来就进入页面资源请求过程。</p><p>这时，浏览器进程会通过进程间通信把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。</p><p>首先，网络进程会先查找本地缓存是否缓存了该资源。如果有缓存资源且缓存在有效期内，直接返回资源给浏览器进程；如果在缓存中没有找到该资源，那么直接进入网络请求流程。</p><p>这一步中的缓存是指强缓存，具体内容可以参考：<a href="https://juejin.cn/post/6915190788628905997" target="_blank" rel="noopener">一文彻底掌握HTTP缓存</a>。</p><p>发起网络请求的第一步就是要进行DNS解析。</p><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><blockquote><p>DNS解析：就是根据浏览器识别出来的URL地址中的域名，到DNS服务器上，查找服务器外网IP的过程。</p></blockquote><p>DNS解析也是有缓存的：浏览器解析过一次，一般就会在本地记录一下解析记录。所以每一次DNS解析：本地DNS服务器解析(递归)、根/顶级/权威域名服务器解析(迭代)</p><h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><p>DNS的域名查找：客户端和浏览器，本地DNS之间的查询方式是递归查询；本地DNS服务器和根域及子域之间的查询方式是迭代查询。</p><p>在客户端输入URL后，会有一个递归查找的过程，从浏览器缓存中查找 -&gt; 本地的hosts文件查找 -&gt; 本地DNS解析器缓存查找 -&gt; 本地DNS服务器查找，在这个过程中任何一步找到了都会结束查找流程。</p><p>递归查找过程如下图所示：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210311233929.png" alt></p><p>如果在本地DNS服务器中也没有查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下图：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210311234116.png" alt></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>减少DNS请求次数：页面中尽可能少用过多域名。HTTP有并发性，但它的并发性是受到源的限制的，同一个源一次最多并发4-7个。</li><li>DNS预获取（DNS Prefetch）：在不能减少DNS解析记录的情况下，可以把DNS预解析。处理方法如下：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//g.alicdn.com"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="建立TCP连接，三次握手"><a href="#建立TCP连接，三次握手" class="headerlink" title="建立TCP连接，三次握手"></a>建立TCP连接，三次握手</h2><p>DNS解析获取到服务器的IP+端口后，接下来就是要建立TCP链接，这里就涉及到我们常说的“三次握手”。</p><p>首先，判断是不是https，如果是，则HTTPS其实是HTTP + SSL/TLS 两部分组成，也就是在HTTP基础上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。</p><p>进行三次握手，建立TCP连接：</p><ul><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手：服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为 x+1；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTAB_LISHED状态，完成TCP三次握手。</li></ul><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210317232206.png" alt></p><ul><li>seq序号：用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记</li><li>ack确认序号：只有ACK标志位为1，确认序号字段才有效，ack=seq+1</li></ul><p>标识位：</p><ul><li>ACK：确认标识，用于表示对数据包的成功接收</li><li>SYN：同步标识，表示TCP连接已初始化，发起一个新连接</li><li>FIN：完成标识，释放一个连接，用于拆除上一个SYN标识。一个完整的TCP连接过程一定有SYN和FIN包。</li></ul><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>TCP 连接建立之后，浏览器端会构建请求行、 请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。如果是 HTTPS，还需要进行 TSL 协商。</p><p>服务器接收到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304；若无效则重新返回资源，状态码为200。</p><p>这里会涉及HTTP的协商缓存，具体内容可以参考：<a href="https://juejin.cn/post/6915190788628905997" target="_blank" rel="noopener">一文彻底掌握HTTP缓存</a></p><h2 id="关闭TCP连接，四次挥手"><a href="#关闭TCP连接，四次挥手" class="headerlink" title="关闭TCP连接，四次挥手"></a>关闭TCP连接，四次挥手</h2><ul><li><p>第一次挥手：主机1（可以是客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态，表示主机1没有数据要发送给主机2了；</p></li><li><p>第二次挥手：主机2接收到主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number + 1；主机1进入 FIN_WAIT_2状态；主机2告诉主机1，我同意你的关闭请求；</p></li><li><p>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p></li><li><p>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段后，就关闭连接；此时，主机1等待主机2 MSL后依然没有收到回复，则证明主机2已正常关闭，那好，主机1也可以关闭连接了。</p></li></ul><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210317233152.png" alt></p><h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><p>浏览器拿到资源会根据资源类型进行处理，比如是 gzip 压缩后的文件则进行解压缩，如果响应头 Content-type 是 text/html，则开始解析HTML。</p><p>按照渲染的时间顺序，流水线可以分为下面几个子阶段：构建DOM树、样式计算、布局阶段、分层、栅格化和显示。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/spring/20210312110156.png" alt></p><p>1、渲染进程将HTML内容转换为浏览器能够读懂的DOM树结构。</p><p>2、渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</p><p>3、创建布局树，并计算元素的布局信息。</p><p>4、对布局树进行分层，并生成分层树。</p><p>5、为每个图层生成绘制列表，并将其提交到合成线程。</p><p>6、合成线程将图层分图块，并栅格化将图块转换成位图。</p><p>7、合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。</p><h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>浏览器从网络或硬盘中获得HTML字节数据后，会先将HTML的原始字节数据转换为文件指定编码的字符，然后浏览器会根据HTML规范来将字符串转换为各种令牌标签，如html、body等，最终解析成一个树状的对象模型，就是DOM树。</p><p>具体步骤如下：</p><ul><li>转码：读取接收到的HTML二进制数据，按指定编码格式将字节转换为HTML字符串</li><li>Tokens化：解析HTML，将HTML字符串转换为结构清晰的Tokens，每个Token都有特殊的含义，同时又自己的一套规则</li><li>构建Nodes：每一个Node都添加特定的属性或属性访问器，通过指针能够确定Node的父、子、兄弟关系和所属treeScope</li><li>构建DOM树：最重要的工作就是建立起每个节点的父子兄弟关系。</li></ul><p>解析过程中遇到图片、link、script会启动下载。</p><p>script标签会阻塞 DOM 树的构建，所以一般将 script 放在底部，或者添加 async 、defer 标识。</p><p>css 下载时异步，不会阻塞浏览器构建 DOM 树，但是会阻塞渲染，布局阶段会等待 css 下载解析完毕后才进行。</p><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。</p><p>样式计算过程主要有两步：</p><ul><li><p>属性值标准化：先将所有值转换为渲染引擎容易理解的、标准化的计算值。在CSS文本中有很多属性值，如em、blue、bold等等，这些类型值不容易被渲染引擎理解，所以需要进行转换。</p></li><li><p>处理样式的继承和层叠，计算出DOM树中每个节点的具体样式。</p></li></ul><p>CSS样式来源主要有3种：</p><ul><li>通过link引用的外部css文件</li><li>style标签内的css</li><li>元素的style属性内嵌的css</li></ul><h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><p>布局过程，即排除script、meta等功能化、非视觉节点，排除 display:none 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。</p><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p><h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><p>渲染引擎实现图层的绘制：把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。</p><p>绘制列表中的指令非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。</p><h3 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h3><p>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。</p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。</p><h3 id="页面渲染优化："><a href="#页面渲染优化：" class="headerlink" title="页面渲染优化："></a>页面渲染优化：</h3><ul><li>HTML文档结构层次尽量少，最好不深于六层；</li><li>脚本尽量后放，放在前即可；</li><li>少量首屏样式内联放在标签内</li><li>样式结构层次尽量简单</li><li>在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流；</li><li>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</li><li>动画尽量使用在绝对定位或固定定位的元素上；</li><li>隐藏在屏幕外，或在页面滚动时，尽量停止动画；</li><li>尽量缓存DOM查找，查找器尽量简洁；</li><li>涉及多域名的网站，可以开启域名预解析。</li></ul><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术</strong>，我们一起学习一起进步。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“在浏览器中，从输入URL到页面展示，中间发生了什么？”这是一道经典的高频面试题，其中涉及了网络、操作系统、web等一系列的知识。接下来我们一起来看看要怎么回答这道题。&lt;/p&gt;
&lt;p&gt;整个过程可以大致描述为：&lt;/p&gt;
&lt;h2 id=&quot;URL解析&quot;&gt;&lt;a href=&quot;#URL
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://www.chenhanpeng.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode系列」42.接雨水</title>
    <link href="http://www.chenhanpeng.com/null/"/>
    <id>http://www.chenhanpeng.com/null/</id>
    <published>2021-03-05T02:37:45.000Z</published>
    <updated>2021-04-21T01:17:31.832Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Hanpeng_Chen</p><p>公众号：<strong>前端极客技术</strong></p><p>博客：<a href="http://www.chenhanpeng.com">官网</a>、<a href="https://juejin.cn/user/1063982988795911/posts" target="_blank" rel="noopener">掘金</a></p></blockquote><p>今天我们来做一道LeetCode上的题目，原题链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">42.接雨水</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例1：</strong><br><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210302213550.png" alt></p><blockquote><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</p><p>输出：6</p><p>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p></blockquote><p><strong>示例2：</strong></p><blockquote><p>输入：height = [4,2,0,3,2,5]</p><p>输出：9</p></blockquote><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p><strong>思路</strong></p><p>根据示例1的图片我们可以比较清晰理解题目：每个柱子宽度为1，所以我们只要计算出每个柱子上面可以积蓄雨水的体积，最后进行求和即可得出总的雨水体积。</p><p>对于每个柱子上面的蓄水量，根据木桶原理，我们只要找出下雨后水能达到的最高位置，即两边最大高度的较小值减去当前高度的值。</p><p><strong>求解步骤：</strong></p><ul><li>初始化sum = 0</li><li>从左往右遍历数组：<ul><li>初始化两边最大高度分别为0： left_max = 0, right_max = 0</li><li>从当前元素向左遍历并更新：<ul><li>left_max = Math.max(left_max, height[k])</li></ul></li><li>从当前元素向右遍历并更新：<ul><li>right_max = Math.max(right_max, height[k])</li></ul></li><li>将Math.min(left_max, right_max) - height[i]累加到sum中</li></ul></li></ul><p><strong>实现代码：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trap = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = height.length;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = i; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">            left_max = <span class="built_in">Math</span>.max(left_max, height[k])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = i; k &lt; len; k++) &#123;</span><br><span class="line">            right_max = <span class="built_in">Math</span>.max(right_max, height[k])</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (<span class="built_in">Math</span>.min(left_max, right_max) - height[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>复杂度分析</strong></p><p>该方法用到了双重遍历，所以时间复杂度为：O(n^2)；空间复杂度为：O(1)</p><h3 id="暴力求解优化"><a href="#暴力求解优化" class="headerlink" title="暴力求解优化"></a>暴力求解优化</h3><p>上面的暴力解法中，每次为了找到位置i的左右最大值，都要向左和向右遍历一次，因此出现了双重遍历。如果我们提前将每个位置的左右最大值查出并存储起来，后面遍历数组的时候直接去相应的值，那么就不会出现双重遍历的情况，时间复杂度也就降为：O(n)。</p><p><strong>步骤</strong></p><ul><li>找到数组中i的到最左端最高的柱子高度 left_max;</li><li>找到数组中i到最右端最高的柱子的高度right_max;</li><li>遍历数组：<ul><li>累加  Math.min(left_max[i], right_max[i]) - height[i]</li></ul></li></ul><p><strong>实现代码</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trap = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!height || height.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left_max = [];</span><br><span class="line">    <span class="keyword">let</span> right_max = [];</span><br><span class="line">    <span class="keyword">let</span> len = height.length;</span><br><span class="line">    left_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        left_max[i] = <span class="built_in">Math</span>.max(height[i], left_max[i - <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    right_max[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right_max[i] = <span class="built_in">Math</span>.max(height[i], right_max[i + <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">Math</span>.min(left_max[i], right_max[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：总共用了三次遍历，每次O(n)，所以总的时间复杂度为O(n)</li><li>空间复杂度：使用了额外的O(n)空间来存left_max和right_max数组，所以空间复杂度为O(n)</li></ul><p>该解法是通过空间换时间的方式来减少运行时间。</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>接下来我来介绍另一种比较好的解法：双指针解法。</p><p>在暴力解法的核心主要是查找出左右两边的最大值，但是我们仔细分析会发现，只要 right_max[i] &gt; left_max[i]，柱子i位置的最大存水量就由left_max决定；反之如果 left_max[i] &gt; right_max[i]，则由right_max决定。</p><p>根据这个思路，我们还是先从左往右扫描数组，我们可以认为如果一侧有更高的柱子（例如右侧），积水的高度依赖于当前方向的高度（从左到右）。当我们发现另一侧（右侧）的条形块高度不是最高的，我们则开始从相反的方向遍历（从右到左）。</p><p>此时我们维护左右两个指针，通过两个指针交替进行遍历，实现一次遍历完成。</p><p>对于位置left而言，它左边的最大值一定是left_max，右边的最大值大于等于right_max。如果此时left_max &lt; right_max，那么它就能计算出它的位置能存多少水，无论右边将来会不会出现更大的值，都不影响计算出的结果，所以当height[left] &lt; height[right] 时，我们去处理left指针。反之，我们去处理right指针。</p><p><strong>步骤：</strong></p><ul><li>初始化left指针为0，right指针为height.length - 1;</li><li>while left &lt; right时：<ul><li>if height[left] &lt; right[right]:<ul><li>left_max = Math.max(left_max, height[left])</li><li>累加 left_max - height[left] 到sum中</li><li>left++</li></ul></li><li>else<ul><li>right_max = Math.max(right_max, height[right])</li><li>sum += right_max - height[right]</li><li>right–</li></ul></li></ul></li></ul><p><strong>实现代码</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trap = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            left_max = <span class="built_in">Math</span>.max(left_max, height[left]);</span><br><span class="line">            sum += left_max - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right_max = <span class="built_in">Math</span>.max(right_max, height[right]);</span><br><span class="line">            sum += right_max - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术(FrontGeek)</strong>，我们一起学习一起进步。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：Hanpeng_Chen&lt;/p&gt;
&lt;p&gt;公众号：&lt;strong&gt;前端极客技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;博客：&lt;a href=&quot;http://www.chenhanpeng.com&quot;&gt;官网&lt;/a&gt;、&lt;a href=&quot;https://ju
      
    
    </summary>
    
      <category term="算法" scheme="http://www.chenhanpeng.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://www.chenhanpeng.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
      <category term="面试" scheme="http://www.chenhanpeng.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="LeetCode题解" scheme="http://www.chenhanpeng.com/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>「面试必备」一文吃透JavaScript继承</title>
    <link href="http://www.chenhanpeng.com/inheritance-in-javascript/"/>
    <id>http://www.chenhanpeng.com/inheritance-in-javascript/</id>
    <published>2021-02-28T15:53:15.000Z</published>
    <updated>2021-04-21T01:17:31.420Z</updated>
    
    <content type="html"><![CDATA[<p>继承在各种编程语言中都充当着至关重要的角色，在JavaScript中也被经常用在前端工程基础库的底层搭建上，是JavaScript需要重点学习的一块内容。</p><p>继承可以使得子类具有父类的各种方法和属性。ES6中推出了class这个概念，方便了我们学习和理解，但class只是一个语法糖，实际底层的实现还是原来的那一套：利用原型链和构造函数来实现继承，接下来我们一起来看看在JavaScript中都有哪些实现继承的方法。</p><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>原型链继承是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p>该方法主要涉及构造函数、原型和实例，三者之间存在着一定的关系：</p><blockquote><p>每一个构造函数都有一个prototype属性，指向函数的原型对象；每一个原型对象都有一个constructor属性，指向构造函数；每一个实例都有一个 <strong>proto</strong> 属性，指向构造函数的原型对象。</p></blockquote><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210228225313.png" alt></p><p>我们先来看下面一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"parent"</span>;</span><br><span class="line">  <span class="keyword">this</span>.interest = [<span class="string">"eat"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child.name, child.type);</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，定义了 Parent 和 Child 两个对象，两个对象之间实现了继承，这种继承方式是通过创建Parent的实例，并将该实例赋给 Child.prototype 实现的。该方法实现的本质就是重写了原型对象。</p><p>从上面的代码看，在子类的实例中可以访问到父类的属性和方法，看似这种继承方式没什么问题，我们接着看下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.interest.push(<span class="string">"run"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child.interest, child1.interest); <span class="comment">// [ 'eat', 'run' ] [ 'eat', 'run' ]</span></span><br></pre></td></tr></table></figure></p><p>上面代码中我又新创建了一个子类实例 <code>child1</code>，并改变了 <code>interest</code> 属性，但是原来的 <code>child</code> 的interest属性也跟着变了。</p><p>出现这个问题的原因很简单：因为两个实例使用的是同一个原型对象，它们的内存空间是共享的。当一个发生变化时，另一个也随之变化，这就是使用原型链继承方式的一个缺点。</p><p>还有一个缺点就是：没有办法在不影响所有对象实例的情况下，给父类的构造函数传递参数。</p><p>因为上面的问题，实践中很少会单独使用原型链继承。</p><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>为了解决原型属性共享问题，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术，有时候也叫伪造对象或经典继承。</p><p>借助构造函数的基本思想就是：利用call或apply把父类中通过this指定的属性和方法复制到子类创建的实例中。因为this对象是在运行时基于函数的执行环境绑定的。</p><p>我们通过下面代码来了解：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.interest = [<span class="string">"eat"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="string">'child1'</span>);</span><br><span class="line">child1.interest.push(<span class="string">"run"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.interest); <span class="comment">// [ 'eat', 'run' ]</span></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> Child(<span class="string">'child2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.interest); <span class="comment">// [ 'eat' ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p><p>从上面代码的执行结果来看，该方法解决了原型链继承的弊端，但仍存在问题：父类原型对象上一旦存在父类之前自己定义的方法，子类将无法继承这些方法。</p><p>我们可以总结出构造函数实现继承具有如下优缺点：<br><strong>优点：</strong></p><ul><li>它使父类的引用类型属性不会被共享；</li><li>可以向父类的构造函数传参。</li></ul><p><strong>缺点：</strong></p><ul><li>只能继承父类的实例属性和方法，不能继承原型属性或方法。</li></ul><h2 id="组合继承（原型链-构造函数）"><a href="#组合继承（原型链-构造函数）" class="headerlink" title="组合继承（原型链+构造函数）"></a>组合继承（原型链+构造函数）</h2><p>组合继承（combination inheritance），也叫作伪经典继承。是将原型链和借用构造函数的技术组合在一起，发挥二者之长的一种继承方式。</p><p>组合继承方法的思路是将公共的属性和方法放在父类的 prototype 上，然后利用原型链继承来实现公共的属性和方法的继承，而对于那种每个实例都可自定义修改的属性采取构造函数继承的方法来实现每个实例都独有一份这样的属性。</p><p>代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"parent"</span>;</span><br><span class="line">  <span class="keyword">this</span>.interest = [<span class="string">"eat"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">"child type"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.interest.push(<span class="string">"run"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.interest, child2.interest); <span class="comment">// [ 'eat', 'run' ] [ 'eat' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.getName()); <span class="comment">// parent</span></span><br></pre></td></tr></table></figure></p><p>从代码执行结果来看，组合继承避免了原型链继承和构造函数继承的缺陷，融合了二者的优点。</p><p>但组合继承有一个问题：就是无论什么情况下，都会调用两次超类型的构造函数，即Parent执行了两次，第一次是改变 Child的prototype的时候，第二次是通过call方法调用Parent的时候。</p><p>上面介绍的三种方法主要是围绕构造函数的方式，如果是JavaScript的普通对象，要如何实现继承？</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>该方法的原理就是借助原型，可以基于已有的对象创建新对象，节省了创建自定义类型这一步。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">W</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  W.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> W();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ES5中新增了 Object.create() 方法规范化了原型式继承，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数）。</p><p>通过下面的代码我们一起看看普通对象时怎样实现继承的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent = &#123;</span><br><span class="line">  name: <span class="string">"parent"</span>,</span><br><span class="line">  interest: [<span class="string">"eat"</span>],</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> parent1 = <span class="built_in">Object</span>.create(parent);</span><br><span class="line">parent1.name = <span class="string">"parent1"</span>;</span><br><span class="line">parent1.interest.push(<span class="string">"sleep"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> parent2 = <span class="built_in">Object</span>.create(parent);</span><br><span class="line">parent2.name = <span class="string">"parent2"</span>;</span><br><span class="line">parent2.interest.push(<span class="string">"run"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parent1.name); <span class="comment">// parent1</span></span><br><span class="line"><span class="built_in">console</span>.log(parent1.name === parent1.getName()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(parent1.interest); <span class="comment">// [ 'eat', 'sleep', 'run' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(parent2.name); <span class="comment">// parent</span></span><br><span class="line"><span class="built_in">console</span>.log(parent2.name === parent2.getName()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(parent2.interest); <span class="comment">// [ 'eat', 'sleep', 'run' ]</span></span><br></pre></td></tr></table></figure></p><p>从上面代码执行结果你会发现存在引用类型数据共享问题，因为Object.create方法是可以为一些对象实现浅拷贝的。</p><p>关于浅拷贝的内容可以看我之前写的文章：<a href="https://juejin.cn/post/6932310945088290830/" target="_blank" rel="noopener">这一次，彻底掌握JavaScript的深浅拷贝</a></p><p>原型式继承的缺点：多个实例的引用类型属性指向相同的内存，存在篡改的可能。</p><p>接下来我们看下在原型式继承基础上进行优化的另一种继承方式：寄生式继承。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承时原型式继承的加强版，利用原型式继承可以获得一份目标对象的浅拷贝的能力再进行增强，添加一些方法，这样的继承方式称为寄生式继承。</p><p>寄生式继承的优缺点和原型式继承一样，但对于普通对象的继承方式来说，寄生式继承相比于原型式继承，在父类的基础上添加了更多的方法。下面我们一起来看下其实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent = &#123;</span><br><span class="line">  name: <span class="string">"parent"</span>,</span><br><span class="line">  interest: [<span class="string">"eat"</span>, <span class="string">"run"</span>],</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="built_in">Object</span>.create(original);</span><br><span class="line">  clone.getInterest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.interest;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> parent1 = clone(parent);</span><br><span class="line"><span class="built_in">console</span>.log(parent1.getName()); <span class="comment">// parent</span></span><br><span class="line"><span class="built_in">console</span>.log(parent1.getInterest()); <span class="comment">// [ 'eat', 'run' ]</span></span><br></pre></td></tr></table></figure><p>从上面代码可以看到，parent1是通过寄生式继承生成的实例，不仅有getName方法，还拥有getInterest方法。</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>实质上，寄生组合继承是寄生式继承的加强版。这是为了避免组合继承中无可避免地要调用两次父类构造函数的最佳方案，也是所有继承方式中相对最优的继承方式。</p><p>代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 改用Object.create可以减少组合继承中多进行一次构造函数</span></span><br><span class="line">  child.prototype = <span class="built_in">Object</span>.create(parent.prototype);</span><br><span class="line">  child.prototype.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"parent"</span>;</span><br><span class="line">  <span class="keyword">this</span>.interest = [<span class="string">"eat"</span>, <span class="string">"run"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">"child type"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clone(Parent, Child);</span><br><span class="line"></span><br><span class="line">Child.prototype.getInterest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.interest;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.interest.push(<span class="string">"sleep"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.getInterest()); <span class="comment">// [ 'eat', 'run', 'sleep' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.getName()); <span class="comment">// parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.getInterest()); <span class="comment">// [ 'eat', 'run' ]</span></span><br></pre></td></tr></table></figure></p><p>通过这段代码可以看出来，这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销。</p><p>ES6新增了Class语法糖，并提供了继承的关键字extends，接下来我们看下extends的用法和底层实现逻辑。</p><h2 id="ES6的Class继承"><a href="#ES6的Class继承" class="headerlink" title="ES6的Class继承"></a>ES6的Class继承</h2><p>Class可以通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p><p>大多数浏览器的ES5实现中，每一个对象都有 <strong>proto</strong> 属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype和<strong>proto</strong>两个属性，因此同时存在两条继承链:</p><ul><li>子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类；</li><li>子类的prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="string">"zhangsan"</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child.getName());</span><br><span class="line"><span class="built_in">console</span>.log(child.getAge());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Child.__proto__ === Parent); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype.__proto__ === Parent.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在实际项目开发过程中，因为浏览器兼容性问题，我们都会利用babel将ES6的代码编译成ES5。那接下来我们来看看extends编译成ES5语法是什么样子的，下面是转译的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123; <span class="string">"@babel/helpers - typeof"</span>; <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span>) &#123; _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> obj; &#125;; &#125; <span class="keyword">else</span> &#123; _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; obj.constructor === <span class="built_in">Symbol</span> &amp;&amp; obj !== <span class="built_in">Symbol</span>.prototype ? <span class="string">"symbol"</span> : <span class="keyword">typeof</span> obj; &#125;; &#125; <span class="keyword">return</span> _typeof(obj); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">left, right</span>) </span>&#123; <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">"undefined"</span> &amp;&amp; right[<span class="built_in">Symbol</span>.hasInstance]) &#123; <span class="keyword">return</span> !!right[<span class="built_in">Symbol</span>.hasInstance](left); &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> left <span class="keyword">instanceof</span> right; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123; value: subClass, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (superClass) _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123; _setPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf || <span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123; o.__proto__ = p; <span class="keyword">return</span> o; &#125;; <span class="keyword">return</span> _setPrototypeOf(o, p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createSuper</span>(<span class="params">Derived</span>) </span>&#123; <span class="keyword">var</span> hasNativeReflectConstruct = _isNativeReflectConstruct(); <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">_createSuperInternal</span>(<span class="params"></span>) </span>&#123; <span class="keyword">var</span> Super = _getPrototypeOf(Derived), result; <span class="keyword">if</span> (hasNativeReflectConstruct) &#123; <span class="keyword">var</span> NewTarget = _getPrototypeOf(<span class="keyword">this</span>).constructor; result = <span class="built_in">Reflect</span>.construct(Super, <span class="built_in">arguments</span>, NewTarget); &#125; <span class="keyword">else</span> &#123; result = Super.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); &#125; <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, result); &#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123; <span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>)) &#123; <span class="keyword">return</span> call; &#125; <span class="keyword">return</span> _assertThisInitialized(self); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_assertThisInitialized</span>(<span class="params">self</span>) </span>&#123; <span class="keyword">if</span> (self === <span class="keyword">void</span> <span class="number">0</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"this hasn't been initialised - super() hasn't been called"</span>); &#125; <span class="keyword">return</span> self; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_isNativeReflectConstruct</span>(<span class="params"></span>) </span>&#123; <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">"undefined"</span> || !<span class="built_in">Reflect</span>.construct) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">if</span> (<span class="built_in">Reflect</span>.construct.sham) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Proxy</span> === <span class="string">"function"</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">try</span> &#123; <span class="built_in">Boolean</span>.prototype.valueOf.call(<span class="built_in">Reflect</span>.construct(<span class="built_in">Boolean</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)); <span class="keyword">return</span> <span class="literal">true</span>; &#125; <span class="keyword">catch</span> (e) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123; _getPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.getPrototypeOf : <span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123; <span class="keyword">return</span> o.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(o); &#125;; <span class="keyword">return</span> _getPrototypeOf(o); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123; <span class="keyword">if</span> (!_instanceof(instance, Constructor)) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target, props</span>) </span>&#123; <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123; <span class="keyword">var</span> descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>; descriptor.configurable = <span class="literal">true</span>; <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>; <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123; <span class="keyword">if</span> (protoProps) _defineProperties(Constructor.prototype, protoProps); <span class="keyword">if</span> (staticProps) _defineProperties(Constructor, staticProps); <span class="keyword">return</span> Constructor; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = <span class="comment">/*#__PURE__*/</span><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Parent, [&#123;</span><br><span class="line">    key: <span class="string">"getName"</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = <span class="comment">/*#__PURE__*/</span><span class="function"><span class="keyword">function</span> (<span class="params">_Parent</span>) </span>&#123;</span><br><span class="line">  _inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _super = _createSuper(Child);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Child);</span><br><span class="line"></span><br><span class="line">    _this = _super.call(<span class="keyword">this</span>, name);</span><br><span class="line">    _this.age = age;</span><br><span class="line">    <span class="keyword">return</span> _this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Child, [&#123;</span><br><span class="line">    key: <span class="string">"getAge"</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Child;</span><br><span class="line">&#125;(Parent);</span><br></pre></td></tr></table></figure><p>从编译后的代码可以看到，采用的也是寄生组合式继承方式，这也证明了这种方式是较优的解决继承的方式。</p><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术(FrontGeek)</strong>，我们一起学习一起进步。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继承在各种编程语言中都充当着至关重要的角色，在JavaScript中也被经常用在前端工程基础库的底层搭建上，是JavaScript需要重点学习的一块内容。&lt;/p&gt;
&lt;p&gt;继承可以使得子类具有父类的各种方法和属性。ES6中推出了class这个概念，方便了我们学习和理解，但cl
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="继承" scheme="http://www.chenhanpeng.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>这一次彻底掌握JavaScript的深浅拷贝</title>
    <link href="http://www.chenhanpeng.com/javascript-shallow-copy-and-deep-copy/"/>
    <id>http://www.chenhanpeng.com/javascript-shallow-copy-and-deep-copy/</id>
    <published>2021-02-22T15:30:45.000Z</published>
    <updated>2021-04-21T01:17:31.764Z</updated>
    
    <content type="html"><![CDATA[<p>关于拷贝这个问题，也是前端面试中的一道经典面试题，我们在日常开发中也常碰到需要用到深拷贝或浅拷贝的场景。接下来我们通过这篇文章，彻底掌握JavaScript的深浅拷贝。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在开始讲深浅拷贝之前，我们要先知道JavaScript的数据类型，主要有下图所示的8种：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210222225118.png" alt></p><p>Object是引用类型，其他7种为基础类型。</p><p>JavaScript的数据类型最后都会在初始化之后放在不同的内存中，因此上面的数据类型大致可以分为两类来进行存储：</p><ul><li>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量</li><li>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。</li></ul><p>接下来我们先来看看浅拷贝。</p><blockquote><p>欢迎关注公众号：<strong>前端极客技术(FrontGeek)</strong></p></blockquote><h2 id="浅拷贝的原理和实现"><a href="#浅拷贝的原理和实现" class="headerlink" title="浅拷贝的原理和实现"></a>浅拷贝的原理和实现</h2><p>浅拷贝的定义：</p><blockquote><p>创建一个对象接受要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，可能会影响到另一个对象。</p></blockquote><p>我们来看看JavaScript中都有哪些实现浅拷贝的方法。</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>object.assign 是 ES6 中 object 的一个方法，该方法可以用于 JS 对象的合并等多个用途，其中一个用途就是可以进行浅拷贝。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。</p><blockquote><p>object.assign 的语法为：Object.assign(target, …sources)</p></blockquote><p>object.assign 的示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> source = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line">source.a.b = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(source); <span class="comment">// &#123; a: &#123; b: 10 &#125; &#125;; </span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123; a: &#123; b: 10 &#125; &#125;;</span></span><br></pre></td></tr></table></figure><p>从上面代码中我们可以看到，首先通过 Object.assign 将 source 拷贝到 target 对象中，将 source 对象中的 b 属性由 1 修改为 10。从执行结果可以看出target和source两个对象中的 b 属性都变为 10 了，证明 Object.assign 暂时实现了我们想要的拷贝效果。</p><p>使用Object.assign方法实现浅拷贝时有几点需要注意：</p><ul><li>Object.assign方法不会拷贝对象的继承属性</li><li>Object.assign方法不会拷贝对象的不可枚举的属性</li><li>可以拷贝Symbol类型的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, <span class="attr">sym</span>: <span class="built_in">Symbol</span>(<span class="number">1</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"innumerable"</span>, &#123;</span><br><span class="line">  value: <span class="string">"不可枚举属性"</span>,</span><br><span class="line"></span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj2, obj1);</span><br><span class="line">obj1.a.b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"obj1"</span>, obj1); <span class="comment">// obj1 &#123; a: &#123; b: 10 &#125;, sym: Symbol(1) &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"obj2"</span>, obj2); <span class="comment">// obj1 &#123; a: &#123; b: 10 &#125;, sym: Symbol(1) &#125;</span></span><br></pre></td></tr></table></figure><p>从上面的样例代码中可以看到，利用 object.assign 也可以拷贝 Symbol 类型的对象，但是如果到了对象的第二层属性 obj1.a.b 这里的时候，前者值的改变也会影响后者的第二层属性的值，说明其中依旧存在着访问共同堆内存的问题，也就是说这种方法还不能进一步复制，而只是完成了浅拷贝的功能。</p><h3 id="扩展运算符方法"><a href="#扩展运算符方法" class="headerlink" title="扩展运算符方法"></a>扩展运算符方法</h3><p>我们也可以利用JS的扩展运算符，在构造对象的同时完成浅拷贝的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123;<span class="attr">c</span>: <span class="number">10</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj&#125;</span><br><span class="line">obj2.a = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="number">10</span>, <span class="number">20</span>]]</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr]</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br></pre></td></tr></table></figure><p>扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便。</p><h3 id="concat拷贝数组"><a href="#concat拷贝数组" class="headerlink" title="concat拷贝数组"></a>concat拷贝数组</h3><p>数组的concat方法也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中元素的属性，因为它会影响拷贝之后连接的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat();</span><br><span class="line">newArr[<span class="number">1</span>]= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br></pre></td></tr></table></figure><h3 id="slice拷贝数组"><a href="#slice拷贝数组" class="headerlink" title="slice拷贝数组"></a>slice拷贝数组</h3><p>slice方法也比较有局限性，因为它仅仅针对数组类型。</p><p>slice方法会返回一个新的数组对象，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原数组的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">val</span>: <span class="number">4</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">2</span>].val = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">//[ 1, 2, &#123; val: 1000 &#125; ]</span></span><br></pre></td></tr></table></figure><p>从上面的代码中可以看出，这就是浅拷贝的限制所在了——它只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。这一讲的后面我会介绍深拷贝相关的内容。</p><h3 id="手工实现一个浅拷贝"><a href="#手工实现一个浅拷贝" class="headerlink" title="手工实现一个浅拷贝"></a>手工实现一个浅拷贝</h3><p>除了上面提到的方法，我们也可以手写一个浅拷贝方法，思路如下：</p><ul><li>对基础数据类型做一个最基本的拷贝；</li><li>对引用类型开辟一个新的存储，并拷贝一层对象属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowCopy = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">"object"</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> copyTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">        copyTarget[key] = target[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="深拷贝的原理和实现"><a href="#深拷贝的原理和实现" class="headerlink" title="深拷贝的原理和实现"></a>深拷贝的原理和实现</h2><p>浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。</p><p>这两个对象是相互独立、不受影响的，彻底实现了内存上的分离。总的来说，深拷贝的原理可以总结如下：</p><blockquote><p>将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不完全改变源对象，二者实现真正的分离。</p></blockquote><p>知道了深拷贝的原理后，我们来看下都有哪些深拷贝的方法：</p><h3 id="乞丐版：JSON-stringify"><a href="#乞丐版：JSON-stringify" class="headerlink" title="乞丐版：JSON.stringify"></a>乞丐版：JSON.stringify</h3><p>JSON.stringify() 方法是开发中常用的也是最简单的深拷贝方法，其实就是将一个对象序列化为JSON的字符串，并将对象中的内容转换为字符串，最后再用JSON.parse()方法将JSON字符串生成一个新的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">obj.b.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，通过 JSON.stringify 可以初步实现一个对象的深拷贝，通过改变 obj 的 a 属性，其实可以看出 newObj 这个对象也不受影响。</p><p>我们来看看下面几种使用JSON.stringify方法进行深拷贝的情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="number">1</span>) &#125;; </span><br><span class="line">  <span class="keyword">this</span>.obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">this</span>.und = <span class="literal">undefined</span>; </span><br><span class="line">  <span class="keyword">this</span>.reg = <span class="regexp">/123/</span>; </span><br><span class="line">  <span class="keyword">this</span>.date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>); </span><br><span class="line">  <span class="keyword">this</span>.NaN = <span class="literal">NaN</span>;</span><br><span class="line">  <span class="keyword">this</span>.infinity = <span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">this</span>.sym = <span class="built_in">Symbol</span>(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> Obj();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1,<span class="string">'innumerable'</span>,&#123; </span><br><span class="line">  enumerable:<span class="literal">false</span>,</span><br><span class="line">  value:<span class="string">'innumerable'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj1'</span>,obj1);</span><br><span class="line"><span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(obj1);</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj2'</span>,obj2);</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210222231521.png" alt></p><p>从上面的执行结果来看，JSON.stringify方法来实现深拷贝并不完美，下面我们一起来看看JSON.stringify实现深拷贝存在的问题：</p><ul><li>拷贝的对象如果有函数、undefined、symbol这几种类型，经过JSON.stringify序列化之后的字符串中这个键值对会消失；</li><li>拷贝Date引用类型会变成字符串</li><li>无法拷贝不可枚举的属性</li><li>无法拷贝对象的原型链</li><li>拷贝RegExp引用类型会变成空对象</li><li>对象中含有 NaN、Infinity、-Infinity，JSON序列化的结果会变成null</li><li>无法拷贝对象的循环应用，即对象成环，例如<code>obj[key]=obj</code></li></ul><p>用 JSON.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。</p><p>如果深拷贝方法要支持Function、Symbol等类型的拷贝，我们只能自己手动实现一个深拷贝方法。</p><h3 id="手写实现深拷贝（基础版）"><a href="#手写实现深拷贝（基础版）" class="headerlink" title="手写实现深拷贝（基础版）"></a>手写实现深拷贝（基础版）</h3><p>接下来我们自己实现一个深拷贝方法，思路如下：</p><blockquote><p>通过for in遍历传入参数的属性值，如果值时引用类型则再次递归调用该方法，如果时基础类型就直接复制。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> copyTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target[key] === <span class="string">"object"</span>) &#123;</span><br><span class="line">      copyTarget[key] = deepCopy(target[key]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      copyTarget[key] = target[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copyTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = deepCopy(obj1);</span><br><span class="line">obj1.a.b = <span class="number">100</span>;</span><br><span class="line">obj1.c = <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure><p>上面我们通过递归的方式实现了深拷贝，但仍存在一些问题没有解决：</p><ul><li>无法复制不可枚举的属性以及Symbol类型；</li><li>只针对普通的引用类型的值做了递归复制，但对于Array、Date、RegExp、Error、Function这些引用类型并不能正确地拷贝。</li><li>对象的属性里面成环，即循环引用没有解决。</li></ul><p>接下来我们一起来改进这个深拷贝方法：</p><h3 id="改进版的深拷贝方法"><a href="#改进版的深拷贝方法" class="headerlink" title="改进版的深拷贝方法"></a>改进版的深拷贝方法</h3><p>针对上面说的几点问题，一起来看看有什么解决方法：</p><ul><li>针对不可枚举属性和Symbol类型，可以使用 <code>Reflect.ownKeys</code> 方法；</li><li>参数为Date、RegExp类型时，直接生成一个新的实例返回；</li><li>利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object.create() 方法创建一个新对象，并继承传入原对象的原型链；</li><li>利用 WeakMap 类型作为 Hash表，因为WeakMap时弱引用类型，可以有效防止内存泄漏，作为检测循环引用很有帮助，如果存在循环，则引用直接返回WeakMap存储的值。</li></ul><p>根据上面的内容，我们重新写一下深拷贝方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">// 日期对象直接返回一个新的日期对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj.constructor === <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="comment">// 如果是正则对象直接返回一个新的正则对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj.constructor === <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="comment">// 如果循环引用了就用WeakMap来解决</span></span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历传入参数所有键的特性</span></span><br><span class="line">  <span class="keyword">let</span> allDesc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj);</span><br><span class="line">  <span class="comment">// 继承原型链</span></span><br><span class="line">  <span class="keyword">let</span> copyObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), allDesc);</span><br><span class="line">  hash.set(obj, copyObj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123;</span><br><span class="line">    copyObj[key] = (isComplexDataType(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">'function'</span>) ? deepCopy(obj[key], hash) : obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copyObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isComplexDataType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是验证代码</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  num: <span class="number">0</span>,</span><br><span class="line">  str: <span class="string">''</span>,</span><br><span class="line">  boolean: <span class="literal">true</span>,</span><br><span class="line">  unf: <span class="literal">undefined</span>,</span><br><span class="line">  nul: <span class="literal">null</span>,</span><br><span class="line">  obj: &#123; <span class="attr">name</span>: <span class="string">'我是一个对象'</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  arr: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'我是一个函数'</span>) &#125;,</span><br><span class="line">  date: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>),</span><br><span class="line">  reg: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'/我是一个正则/ig'</span>),</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'1'</span>)]: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'innumerable'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">'不可枚举属性'</span> &#125;</span><br><span class="line">);</span><br><span class="line">obj = <span class="built_in">Object</span>.create(obj, <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj))</span><br><span class="line">obj.loop = obj    <span class="comment">// 设置loop成循环引用的属性</span></span><br><span class="line"><span class="keyword">let</span> cloneObj = deepCopy(obj)</span><br><span class="line">cloneObj.arr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj'</span>, obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'cloneObj'</span>, cloneObj)</span><br></pre></td></tr></table></figure></p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>尽管使用深拷贝可以完全克隆一个新的对象，不会产生副作用，但是因为深拷贝方法用到递归，性能方面不如浅拷贝，在实际开发过程中，我们要根据实际情况进行选择。</p><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术(FrontGeek)</strong>，我们一起学习一起进步。</p></blockquote><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/%E5%89%8D%E7%AB%AF%E6%9E%81%E5%AE%A2%E6%8A%80%E6%9C%AF%E4%BA%8C%E7%BB%B4%E7%A0%81.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于拷贝这个问题，也是前端面试中的一道经典面试题，我们在日常开发中也常碰到需要用到深拷贝或浅拷贝的场景。接下来我们通过这篇文章，彻底掌握JavaScript的深浅拷贝。&lt;/p&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="深浅拷贝" scheme="http://www.chenhanpeng.com/tags/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>【面试题】Vue2 中如何检测数组变化</title>
    <link href="http://www.chenhanpeng.com/how-to-observe-array-in-vue2/"/>
    <id>http://www.chenhanpeng.com/how-to-observe-array-in-vue2/</id>
    <published>2021-02-04T14:36:47.000Z</published>
    <updated>2021-04-21T01:17:29.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要对数组进行单独处理"><a href="#为什么要对数组进行单独处理" class="headerlink" title="为什么要对数组进行单独处理"></a>为什么要对数组进行单独处理</h2><p>我们都知道在Vue2中，对响应式处理利用的是 <code>Object.defineProperty</code> 对数据进行拦截。如果数据是数组，我们还是用defineProperty的方法进行拦截的话，需要对数组每一层每一位都进行依赖收集和更新时的notify，这样消耗的性能将指数倍增加，因为我们无法预估一个数组有多少层有多少位。</p><p>考虑性能原因，没有用 defineProperty 对数组的每一项进行拦截，而是选择对下面7个数组方法进行重写：</p><ul><li>push</li><li>shift</li><li>pop</li><li>splice</li><li>unshift</li><li>sort</li><li>reverse</li></ul><p>为什么是上面7个方法？因为我们要监控的是原数组的数据变化，使用上面7个方法对数组进行操作，会改变原数组，而其他方法并不会改变原数组。</p><h2 id="如何重写数组方法"><a href="#如何重写数组方法" class="headerlink" title="如何重写数组方法"></a>如何重写数组方法</h2><p>我们先来看Vue2中关于重写数组方法的源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123; <span class="comment">// 重写7个方法</span></span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="comment">// 获取数组原方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="comment">// def方法重新定义arrayMethods的method方法，然后将新的取值方法赋值</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是去除数组参数方法，触发一次notify将会重新计算</span></span><br><span class="line">    <span class="comment">// 如果仅仅是数字数据，任何操作只需要再次执行一次notify则可以</span></span><br><span class="line">    <span class="comment">// 但是如果新增的是一个对象类型，就需要重新监听</span></span><br><span class="line">    <span class="comment">// 为什么用角标和length属性不能监听的原因是因为无法触发obj的get方法，所以没法动态监听</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify() <span class="comment">// &#123;a,b,c&#125;   observer =&gt; dep</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以知道：vue2对push、splice等方法进行重写，如果加入新对象，会调用observe方法对新对象进行劫持。最后在向外抛出数组变化前，通知观察者进行视图更新。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><p>在Vue2中只有通过上面说的7中变异方法修改数组才会触发数组对应的watcher进行更新，如果我们修改数组的索引和长度是无法监控到的，也就无法实现视图更新。如果想更改索引更新数据，可以通过 <code>Vue.$set()</code> 来进行处理。</p></li><li><p>数组中数据如果是对象类型，也会进行递归劫持。</p></li></ul><blockquote><p>欢迎关注我的微信公众号：<strong>前端极客技术(FrontGeek)</strong></p></blockquote><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术(FrontGeek)</strong>，我们一起学习一起进步。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要对数组进行单独处理&quot;&gt;&lt;a href=&quot;#为什么要对数组进行单独处理&quot; class=&quot;headerlink&quot; title=&quot;为什么要对数组进行单独处理&quot;&gt;&lt;/a&gt;为什么要对数组进行单独处理&lt;/h2&gt;&lt;p&gt;我们都知道在Vue2中，对响应式处理利用的是 &lt;co
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="vue" scheme="http://www.chenhanpeng.com/tags/vue/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【面试题】说一说你对Vue2 响应式原理的理解？</title>
    <link href="http://www.chenhanpeng.com/interview-vue-reactivity-in-depth/"/>
    <id>http://www.chenhanpeng.com/interview-vue-reactivity-in-depth/</id>
    <published>2021-01-29T15:08:57.000Z</published>
    <updated>2021-04-21T01:17:30.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然Vue3已经正式发布，但目前Vue2还是开发主力，所以近期面试Vue2相关内容还是比较常见的，今天我们一起来看看下面这个问题：</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>面试官：说一说你对Vue2 响应式原理的理解？</p></blockquote><h2 id="无法让面试官满意的回答"><a href="#无法让面试官满意的回答" class="headerlink" title="无法让面试官满意的回答"></a>无法让面试官满意的回答</h2><p>碰到面试官问你这个问题，你可能会做如下回答：</p><blockquote><p>Vue是非侵入性的响应式系统，遍历对象并使用Object.defineProperty对对象的属性进行数据劫持，当数据发生变化时，触发数据劫持的setter函数，通知组件实例的watcher需要进行视图更新，以此来实现响应式。</p></blockquote><p>上面的答案虽然提到 <code>Object.defineProperty</code> 这一关键点，但并不能让面试官满意，因为有一些关键的细节并没有回答出来，比如：Vue是在什么时候进行数据劫持？又是如何实现在数据更新时通知视图更新的？</p><h2 id="让面试官满意的回答"><a href="#让面试官满意的回答" class="headerlink" title="让面试官满意的回答"></a>让面试官满意的回答</h2><p>下面我们一起来过一下Vue2 的响应式流程：</p><ul><li><p>在<code>init</code>数据初始化的时候，对象内部通过 <code>defineReactive</code> 方法，使用 <code>Object.defineProperty</code> 将属性进行劫持（这时候只会劫持已经存在的属性）。如果数据是数组类型， Vue2中是通过重写数组方法来实现。多层对象是通过递归来实现劫持的。</p></li><li><p>在初始化流程中的编译阶段，当<code>render function</code> 被渲染的时候，会读取Vue实例中和视图相关的响应式数据，此时会触发 <code>getter</code> 函数进行 <strong>依赖收集</strong>（将观察者<code>Watcher</code>对象存放到当前闭包的订阅者<code>Dep</code>的<code>subs</code>中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。</p></li><li><p>当数据发生变化或者视图导致的数据发生变化时，会触发数据劫持的<code>setter</code>函数，<code>setter</code>会通知初始化依赖收集中的<code>Dep</code>中和视图相应的 <code>Watcher</code> ，告知需要重新渲染视图，<code>Watcher</code> 就会再次通过 <code>update</code> 方法来更新视图。</p></li></ul><p>上面的回答基本将Vue2的响应式原理说清楚了，虽然还有一些细节的内容没说，但如果你们清晰的将上面三个流程说出来，面试官就能知道你已经理解了Vue2的响应式原理，面试评分自然不会低。</p><p>因为Vue3已经发布，所以在这个基础上，面试官可能还会问：Vue3 在响应式原理上都做了哪些优化方案？这个问题我们后续在做解答。</p><p>感谢读完这篇文章，如果感觉写得还可以的话，关注公众号，点个赞，我们一起学习、准备面试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;虽然Vue3已经正式发布，但目前Vue2还是开发主力，所以近期面试Vue2相关内容还是比较常见的，今天我们一起来看看下面这个问题：&lt;/p&gt;

      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="vue" scheme="http://www.chenhanpeng.com/tags/vue/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【面试真题系列】Vue中的v-if和v-show有什么区别？</title>
    <link href="http://www.chenhanpeng.com/interview-vue-v-if-v-show/"/>
    <id>http://www.chenhanpeng.com/interview-vue-v-if-v-show/</id>
    <published>2021-01-21T14:07:53.000Z</published>
    <updated>2021-04-21T01:17:30.059Z</updated>
    
    <content type="html"><![CDATA[<p>在回答这个问题前，我们先来看下Vue文档中对这两个指令的说明：</p><ul><li>v-if：用于条件性地渲染一块内容。这块内容只会在指令的表达式返回truthy值的时候被渲染。</li><li>v-show：用于根据条件展示元素的指令。</li></ul><h2 id="v-if和v-show的共同点"><a href="#v-if和v-show的共同点" class="headerlink" title="v-if和v-show的共同点"></a>v-if和v-show的共同点</h2><p>两者的作用效果是相同的，都能控制元素在页面是否显示。</p><p>在用法上也相同：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">if</span>=<span class="string">"show"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;div v-show=<span class="string">"show"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h2 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h2><p>两者的区别主要表现在下面四个方面：</p><ul><li>编译过程</li><li>编译条件</li><li>性能消耗</li><li>应用场景</li></ul><p><strong>编译过程</strong><br>v-if 是真正的条件渲染，因为它会确保切换过程中条件块内的<code>事件监听器</code>和 <code>子组件</code>适当地被销毁和重建。</p><p>v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由 true 变为false的时候触发组件的beforeDestroy、destroyed钩子。</p><p>v-show的元素始终会被渲染并保留在DOM中，只是简单切换元素的CSS属性<code>display</code>进行隐藏或显示。</p><p><strong>编译条件</strong><br>v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直到条件第一次变为真时，才会开始渲染条件块。</p><p>v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p><strong>性能消耗</strong><br>v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。</p><p><strong>应用场景</strong><br>如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p><blockquote><p>欢迎关注我的微信公众号：<strong>前端极客技术(FrontGeek)</strong></p></blockquote><h2 id="v-if和v-show原理分析"><a href="#v-if和v-show原理分析" class="headerlink" title="v-if和v-show原理分析"></a>v-if和v-show原理分析</h2><p>下面我们通过Vue 2.x的源码，来看看v-if和v-show的原理。</p><p>在开始之前我们要知道vue2中字符串模板解析编译成真实DOM的过程，大致流程如下：</p><ul><li>将模板template转为ast结构的JS对象</li><li>用ast得到的JS对象拼装render和staticRenderFns函数</li><li>render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息</li><li>vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点</li></ul><h3 id="v-if原理"><a href="#v-if原理" class="headerlink" title="v-if原理"></a>v-if原理</h3><p>在模板编译的parse阶段，会使用 <code>processIfConditions</code> 函数处理条件渲染指令的内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processIfConditions</span> (<span class="params">el, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prev = findPrevElement(parent.children)</span><br><span class="line">  <span class="keyword">if</span> (prev &amp;&amp; prev.if) &#123;</span><br><span class="line">    addIfCondition(prev, &#123;</span><br><span class="line">      exp: el.elseif,</span><br><span class="line">      block: el</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// 警告信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在模板编译的 <code>codegen</code> 阶段，会调用 <code>genIf</code> 函数处理 v-if 所在的标签：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">genIf</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  state: CodegenState,</span></span></span><br><span class="line"><span class="function"><span class="params">  altGen?: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  altEmpty?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  el.ifProcessed = <span class="literal">true</span> <span class="comment">// avoid recursion</span></span><br><span class="line">  <span class="keyword">return</span> genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genIfConditions</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  conditions: ASTIfConditions,</span></span></span><br><span class="line"><span class="function"><span class="params">  state: CodegenState,</span></span></span><br><span class="line"><span class="function"><span class="params">  altGen?: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  altEmpty?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!conditions.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> altEmpty || <span class="string">'_e()'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> condition = conditions.shift()</span><br><span class="line">  <span class="keyword">if</span> (condition.exp) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;condition.exp&#125;</span>)?<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      genTernaryExp(condition.block)</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>:<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      genIfConditions(conditions, state, altGen, altEmpty)</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;genTernaryExp(condition.block)&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v-if with v-once should generate code like (a)?_m(0):_m(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">genTernaryExp</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> altGen</span><br><span class="line">      ? altGen(el, state)</span><br><span class="line">      : el.once</span><br><span class="line">        ? genOnce(el, state)</span><br><span class="line">        : genElement(el, state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中可以看出，v-if 指令会转化成三目运算符的形式。</p><p>带有 v-if 指令的模板会编译成根据数据源真假值来调用具体辅助方法的渲染函数，v-if 会根据数据源真假值来决定是否渲染该节点，这一点与 v-show 不同。</p><h3 id="v-show原理"><a href="#v-show原理" class="headerlink" title="v-show原理"></a>v-show原理</h3><p>v-show 指令根据表达式之真假值，切换元素的 display CSS 属性。当条件变化时该指令触发过渡效果。</p><p>在模板编译和生成VNode的过程中，v-show指令与自定义指令的过程一样</p><p>在调用处理指令的钩子函数 updateDirectives 时，v-show 指令有所不同，相当于 v-show 内部实现了自定义指令的 bind、update、unbind 三个阶段的钩子函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  bind (el, &#123; value &#125;, vnode) &#123;</span><br><span class="line">    vnode = locateNode(vnode)</span><br><span class="line">    <span class="keyword">const</span> transition = vnode.data &amp;&amp; vnode.data.transition</span><br><span class="line">    <span class="keyword">const</span> originalDisplay = el.__vOriginalDisplay =</span><br><span class="line">      el.style.display === <span class="string">'none'</span> ? <span class="string">''</span> : el.style.display</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; transition) &#123;</span><br><span class="line">      vnode.data.show = <span class="literal">true</span></span><br><span class="line">      enter(vnode, () =&gt; &#123;</span><br><span class="line">        el.style.display = originalDisplay</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.style.display = value ? originalDisplay : <span class="string">'none'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  update (el, &#123; value, oldValue &#125;, vnode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value === !oldValue) <span class="keyword">return</span></span><br><span class="line">    vnode = locateNode(vnode)</span><br><span class="line">    <span class="keyword">const</span> transition = vnode.data &amp;&amp; vnode.data.transition</span><br><span class="line">    <span class="keyword">if</span> (transition) &#123;</span><br><span class="line">      vnode.data.show = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        enter(vnode, () =&gt; &#123;</span><br><span class="line">          el.style.display = el.__vOriginalDisplay</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        leave(vnode, () =&gt; &#123;</span><br><span class="line">          el.style.display = <span class="string">'none'</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.style.display = value ? el.__vOriginalDisplay : <span class="string">'none'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  unbind (el,binding,vnode,oldVnode,isDestroy)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDestroy) &#123;</span><br><span class="line">      el.style.display = el.__vOriginalDisplay</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述代码可以看到，v-show 指令仅仅是通过调用 DOM.style.display 的值来显示和隐藏DOM元素。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://cn.vuejs.org/v2/guide/conditional.html#v-if" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/conditional.html#v-if</a></li><li><a href="https://mp.weixin.qq.com/s/9CtghxcWPDZYIOiCjaYDcQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9CtghxcWPDZYIOiCjaYDcQ</a></li></ul><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术(FrontGeek)</strong>，我们一起学习一起进步。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在回答这个问题前，我们先来看下Vue文档中对这两个指令的说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v-if：用于条件性地渲染一块内容。这块内容只会在指令的表达式返回truthy值的时候被渲染。&lt;/li&gt;
&lt;li&gt;v-show：用于根据条件展示元素的指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;h
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="vue" scheme="http://www.chenhanpeng.com/tags/vue/"/>
    
      <category term="面试" scheme="http://www.chenhanpeng.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊JavaScript类型判断的四种方法</title>
    <link href="http://www.chenhanpeng.com/javascript-methods-of-judging-data-type/"/>
    <id>http://www.chenhanpeng.com/javascript-methods-of-judging-data-type/</id>
    <published>2021-01-20T12:09:02.000Z</published>
    <updated>2021-04-21T01:17:31.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在web开发中，我们经常碰到需要判断数据是数字还是字符串，判断是数组还是对象的场景，接下来我们一起来看看JavaScript中都有哪些方法可以判断数据类型。</p><blockquote><p>欢迎关注我的微信公众号：<strong>前端极客技术(FrontGeek)</strong></p></blockquote><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>在JS中，我们最常用的判断方法自然是<code>typeof</code>。</p><blockquote><p>typeof：是一元操作符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。</p></blockquote><p>在ES5中，JavaScript有六种数据类型：Number、String、Boolean、Undefined、Null、Object。ES6新增了一种数据类型：Symbol。</p><p>我们先用typeof对上面七种数据类型的值进行运算，看得到的结果是什么样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'test'</span>) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>) <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>()) <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure></p><p>从执行结果我们可以看出，null、对象都返回<code>object</code>，其他的都返回和数据类型对应的小写字符串。</p><p>在JS中，Object类型下还细分很多类型，比如Array、Function、Date、Error等等，我们也用typeof尝试判断这几种类型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []) <span class="comment">// object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// function</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> now) <span class="comment">// object</span></span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> error) <span class="comment">// object</span></span><br></pre></td></tr></table></figure></p><p>typeof可以检测出函数类型，其他类型返回的都是object，没办法确实是哪一种细分类型。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof操作符用于检查一个对象是否属于某个特定的class。同时它还考虑了继承。</p><p>用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">instanceof</span> B</span><br></pre></td></tr></table></figure></p><p>表示判断A是否为B的实例，如果是返回true，否则返回false。</p><p>我们先来看下几个关于instanceof的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> a() <span class="keyword">instanceof</span> a) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>从上面我们可以发现一个问题，instanceof虽然可以判断出[]是Array的实例，但它也认为 []是Object的实例。</p><p>我们简单分析下[]、Array、Object三者的关系：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210117211231.png" alt></p><p>[].<strong>proto</strong> 指向 Array.prototype，而 Array.prototype.<strong>proto</strong> 又指向 Object.prototype，最终 Object.prototype.<strong>proto</strong> 指向null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链。</p><p>我们从原型链可以看出，[] 的 <strong>proto</strong>  直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此：</p><blockquote><p>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</p></blockquote><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>对于对象子类型的判断，除了instanceof，我们还可以利用对象的constructor属性来进行判断。</p><p>constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。所以，修改原型对象时，一般要同时修改constructor属性的指向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'22'</span>.constructor === <span class="built_in">String</span>)             <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>)            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([].constructor === <span class="built_in">Array</span>)                <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">22</span>).constructor === <span class="built_in">Number</span>)   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Function</span>().constructor === <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Date</span>()).constructor === <span class="built_in">Date</span>)       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">RegExp</span>().constructor === <span class="built_in">RegExp</span>)     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Error</span>().constructor === <span class="built_in">Error</span>)       <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在使用constructor时我们需要注意以下几点：</p><ul><li>null 和 undefined 没有构造函数，因此不会有constructor的存在，这两种类型需要通过其他方式判断；</li><li>函数的constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</li></ul><h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h2><p>toString()是Object的原型方法，调用该方法，默认返回当前对象的<code>[[Class]]</code>。<code>[[Class]]</code>是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</p><p>对于Object对象，直接调用toString方法就能返回<code>[object Object]</code>，而对于其他对象，需要通过call/apply来调用才能返回正确的类型信息。</p><p>我们来看个demo：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>))   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>))    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)) <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>())) <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)) <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)) <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>())) <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>())) <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([])) <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>())) <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>())) <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)) <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>)) <span class="comment">// [object Math]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>)) <span class="comment">// [object JSON]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>)) <span class="comment">// [object Arguments]</span></span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure></p><p>Object.prototype.toString 看起来就是一个神器，通用性强，但是相比其他几个方法来说比较繁琐，在实际开发过程中，我们可以对其封装成一个判断类型的函数进行调用。</p><h2 id="type-API"><a href="#type-API" class="headerlink" title="type API"></a>type API</h2><p>在实际开发过程中，我们不会去检测 Math、JSON和Arguments，所以在isType函数中不考虑。</p><p>封装结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">value, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isType(<span class="string">'111'</span>, <span class="string">'String'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isType(<span class="literal">null</span>, <span class="string">'Null'</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你想判断一个基本类型的数据时，你可以用typeof去判断，它很简单，而且可靠；当你想判断一个对象属于哪个子类型时，你可以使用instanceof运算符或constructor属性，但是你需要有个预期的类型，不然就要针对每一种类型写不一样的if…else…语句，还有一点需要注意的就是constructor属性可以被修改，所以并不可靠；如果你不嫌代码量多，要求准确且全面，那你可以用Object.prototype.toString.call()进行判断。</p><p>文中所有示例代码见：<a href="https://github.com/Hanpeng-Chen/html-js-demo-code/tree/main/judge-type-of-data" target="_blank" rel="noopener">judge-type-of-data</a></p><blockquote><p>如果你觉得这篇内容对你有帮助的话：</p><p>1、<strong>点赞</strong>支持下吧，让更多的人也能看到这篇内容</p><p>2、关注公众号：<strong>前端极客技术(FrontGeek)</strong>，我们一起学习一起进步。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在web开发中，我们经常碰到需要判断数据是数字还是字符串，判断是数组还是对象的场景，接下来我们一起来看看JavaScript中都有哪些方法可
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.chenhanpeng.com/tags/JavaScript/"/>
    
      <category term="类型判断" scheme="http://www.chenhanpeng.com/tags/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的数据结构——栈和队列</title>
    <link href="http://www.chenhanpeng.com/javascript-stack-and-queue/"/>
    <id>http://www.chenhanpeng.com/javascript-stack-and-queue/</id>
    <published>2021-01-18T15:04:05.000Z</published>
    <updated>2021-01-20T02:10:26.277Z</updated>
    
    <content type="html"><![CDATA[<p>在前面 <a href="http://www.chenhanpeng.com/javascript-linked-list/">JavaScript中的数据结构——链表</a> 一文中，我们学习了链表。今天我们一起来学习另外两种数据结构：栈和队列。</p><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈是一种特殊的列表，限定仅在表尾进行插入和删除操作的线性表。表尾这一端我们称为栈顶，相对地，把另一端称为栈底。</p><p>栈遵循后进先出（LIFO）原则进行存储数据，先进入的数据被压入栈底，最后进入的数据在栈顶，需要读取数据的时候从栈顶开始弹出数据。如下图所示：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210116204449.png" alt></p><p>因为栈的后进先出的特定，因此只能访问在栈顶的元素。</p><p>栈的操作主要有两种：入栈和出栈。</p><h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><p>要实现一个栈，可以用数组或者链表来实现。下面我们用数组的方式来实现栈，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈</span></span><br><span class="line">  push(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出栈</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="comment">// 如果栈为空，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.data.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.pop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空栈</span></span><br><span class="line">  clear()&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> length()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>队列和栈有点像，它们都是线性表，元素都是有序的。</p><p>但是和栈不同的是，队列遵循的是先进先出（FIFO）的原则，也就是从尾部添加元素，从头部移除元素，最新添加的元素必须排列在队列的末尾。</p><p>队列的主要操作有：往队列中插入新的元素和删除最早加入的元素。</p><h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h3><p>队列同样可以用数组或链表来实现。下面我们还是用数组的方式来实现，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入栈</span></span><br><span class="line">  enqueue(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出栈</span></span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.data.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  clear()&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> length()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>栈遵循的是后进先出原则，队列遵循的是先进先出原则。</p><p>栈的队列实现起来还是相对比较简单，它们是用来帮我们组织数据的。比如下面两个实际开发场景：</p><ul><li>使用堆栈来组织数据，实现文本编辑器的撤销操作；</li><li>使用队列处理数据，实现浏览器的事件循环处理事件。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前面 &lt;a href=&quot;http://www.chenhanpeng.com/javascript-linked-list/&quot;&gt;JavaScript中的数据结构——链表&lt;/a&gt; 一文中，我们学习了链表。今天我们一起来学习另外两种数据结构：栈和队列。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="算法" scheme="http://www.chenhanpeng.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.chenhanpeng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈和队列" scheme="http://www.chenhanpeng.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的数据结构—链表</title>
    <link href="http://www.chenhanpeng.com/javascript-linked-list/"/>
    <id>http://www.chenhanpeng.com/javascript-linked-list/</id>
    <published>2021-01-17T04:17:31.000Z</published>
    <updated>2021-01-18T02:33:53.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据结构与算法在前端开发工程师的日常工作中也许不常用，但在这对前端工程师要求日益提高的时代，如果对数据结构、算法思维、代码效率等知识拥有足够的储备，那么我们将拥有更强的竞争力。</p><p>话不多说，我们接下来学习一种数据结构：链表(Linked list)。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>数组对于每个开发来说是非常熟悉的一种数据结构。链表是一种比数组稍微复杂一点的数据结构，掌握起来也比数组稍难一些。</p><p>链表是一种与数组类似的线性数据结构，但与数组的元素存储在特定的内存位置或索引中不同，链表的每个元素都是独立的对象，它包含一个指向该列表中下一个对象的指针或链接。</p><p>链表的每个元素（我们通常称为节点）包含两项：</p><ul><li>存储的数据：数据可以是任何有效的数据类型。</li><li>指针：到下一节点的链接</li></ul><p>链表的结构可以由很多种，它可以是单链表或双链表，也可以是已排序的或未排序的，环形的或非环形的。如果一个链表是单向的，那么链表中的每个元素没有指向前一个元素的指针。已排序的和未排序的链表较好理解。常见的有：单向链表、双向链表、单向循环链表和双向循环链表。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210114213201.png" alt></p><p>从上图我们可以看出，循环链表和单链表的区别在于：单链表的尾元素指向的Null，而循环链表的尾元素指向的是链表的头部元素。</p><blockquote><p>欢迎关注我的微信公众号：<strong>前端极客技术(FrontGeek)</strong></p></blockquote><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>链表和数组一样，也支持数据的查找、插入和删除。</p><p>由于链表是非连续的，想要访问第i个元素就不像数组那么方便，而是需要根据指针一个节点一个节点一次遍历，直到找到相应的节点。</p><p>因为链表的数据本身是非连续的空间，所以它的插入或删除操作，不需要像数组那边挪动原来的数据，因此在链表中插入数据、删除数据是非常快的。</p><h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><p>我们设计链表包含两个类：一个是Node类用来表示节点；另一个是LinkedList类提供插入节点、删除节点等操作。</p><p>头结点head的next初始化为null，每当调用插入方法时，next就会指向新的元素</p><ul><li><p>Node</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = el;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>LinkedList</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于查找</span></span><br><span class="line">  find()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入节点</span></span><br><span class="line">  insert()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  remove()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从头结点开始查找，如果没找到就把当前指针往后移，找到就返回该元素，如果遍历完没找到就直接返回null。</p><p>代码实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find(item)&#123;</span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">while</span> (currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.el !== item) &#123;</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currentNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h3><p>要往链表中插入新节点，需要知道在哪个节点后面插入。那么我们就需要知道在哪里插入和插入的元素是什么。</p><p>知道在哪个节点后面插入后，首先我们要先找到这个节点的位置，这里我们就可以用上面实现的查找方法。</p><p>找到节点后，我们先创建一个新节点，把新节点的next指针指向找到的这个节点next指向的对应节点，再把找到的这个节点的next指针指向新节点，数据的插入就完成了。具体过程如下图所示：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210114215737.png" alt></p><p>代码实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line">  <span class="comment">// el:要插入的数据</span></span><br><span class="line">  <span class="comment">// item：数据插入到这个节点后面</span></span><br><span class="line">  insert(el, item)&#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el)</span><br><span class="line">    <span class="keyword">const</span> cur = <span class="keyword">this</span>.find(item)</span><br><span class="line">    newNode.next = cur.next</span><br><span class="line">    cur.next = newNode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除节点和插入节点类似，首先要找到相应节点的前一个节点，找到后，让它的next指向待删除节点的下一个节点。如下图所示：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210114220545.png" alt></p><p>代码实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">findPre(item) &#123;</span><br><span class="line">  <span class="keyword">let</span> cur = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">while</span> (cur.next !== <span class="literal">null</span> &amp;&amp; cur.next.el !== item) &#123;</span><br><span class="line">    cur = cur.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line">remove(item)&#123;</span><br><span class="line">  <span class="keyword">const</span> preNode = <span class="keyword">this</span>.findPre(item)</span><br><span class="line">  <span class="keyword">if</span> (preNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    preNode.next = preNode.next.next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单向链表完整代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单项链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = el;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于查找</span></span><br><span class="line">  find(item)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.el !== item) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findPre(item) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (cur.next !== <span class="literal">null</span> &amp;&amp; cur.next.el !== item) &#123;</span><br><span class="line">      cur = cur.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入节点</span></span><br><span class="line">  <span class="comment">// el:要插入的数据</span></span><br><span class="line">  <span class="comment">// item：数据插入到这个节点后面</span></span><br><span class="line">  insert(el, item)&#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el)</span><br><span class="line">    <span class="keyword">const</span> cur = <span class="keyword">this</span>.find(item)</span><br><span class="line">    newNode.next = cur.next</span><br><span class="line">    cur.next = newNode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  remove(item)&#123;</span><br><span class="line">    <span class="keyword">const</span> preNode = <span class="keyword">this</span>.findPre(item)</span><br><span class="line">    <span class="keyword">if</span> (preNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      preNode.next = preNode.next.next</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表，顾名思义就是它有两个方向，除了next指针指向下一个节点外，比单向链表多了一个prev指针，用来指向上一个节点。</p><p>双向链表如下图所示：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210114223754.png" alt></p><p>和单向链表相比，在存储相同的数据情况下，双向链表要比单向链表占用更多的空间，但双向链表往往会比单向链表更加灵活。例如：</p><p>双向链表删除节点时，因为有prev指向上一个节点，就不需要像单向链表一样去寻找待删除节点的前驱节点，使得删除节点的效率提高了。</p><p>接下来我们来看下如何实现双向链表：</p><h3 id="双向链表的设计"><a href="#双向链表的设计" class="headerlink" title="双向链表的设计"></a>双向链表的设计</h3><p>对于节点类，我们只要在单向链表的基础上，加上一个prev指针。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = el</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.prev = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外双向链表的查找和单向链表一样，这里就不再细说，我们直接来看下插入节点。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>双向链表的插入和单向链表相似，多了一个prev指针，只要将新节点的prev指向前驱节点，将后驱节点的prev指向新节点。如下图所示：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210114224936.png" alt></p><p>实现代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert(el, item)&#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el)</span><br><span class="line">    <span class="keyword">const</span> cur = <span class="keyword">this</span>.find(item)</span><br><span class="line">    newNode.next = cur.next</span><br><span class="line">    newNode.prev = cur</span><br><span class="line">    cur.next = newNode</span><br><span class="line">    cur.next.prev = newNode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>双向链表的删除 remove 方法比单链表效率高，不需要查找前驱节点，只要找出待删除节点，然后将该节点的前驱 next 属性指向待删除节点的后继，设置该节点后继 previous 属性，指向待删除节点的前驱即可。</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210114225122.png" alt></p><p>实现代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">remove(item)&#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">this</span>.find(item)</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">    node.next = <span class="literal">null</span></span><br><span class="line">    node.prev = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>双向链表完整代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = el</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.prev = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于查找</span></span><br><span class="line">  find(item)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.el !== item) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入节点</span></span><br><span class="line">  <span class="comment">// el:要插入的数据</span></span><br><span class="line">  <span class="comment">// item：数据插入到这个节点后面</span></span><br><span class="line">  insert(el, item)&#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el)</span><br><span class="line">    <span class="keyword">const</span> cur = <span class="keyword">this</span>.find(item)</span><br><span class="line">    newNode.next = cur.next</span><br><span class="line">    newNode.prev = cur</span><br><span class="line">    cur.next = newNode</span><br><span class="line">    cur.next.prev = newNode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  remove(item)&#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">this</span>.find(item)</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">    node.next = <span class="literal">null</span></span><br><span class="line">    node.prev = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h2><p>单向循环链表和单向链表相似，节点类型都一样，唯一的区别就是在创建循环链表的时候，让其头结点的next属性指向它本身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next = head</span><br></pre></td></tr></table></figure></p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210114230407.png" alt></p><p>单向循环链表如上图所示，具体的实现细节不再一一细说，我们直接来看实现代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = el;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>)</span><br><span class="line">    <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.head</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于查找</span></span><br><span class="line">  find(item)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.el !== item) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findPre(item) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (cur.next !== <span class="literal">null</span> &amp;&amp; cur.next.el !== item) &#123;</span><br><span class="line">      cur = cur.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入节点</span></span><br><span class="line">  <span class="comment">// el:要插入的数据</span></span><br><span class="line">  <span class="comment">// item：数据插入到这个节点后面</span></span><br><span class="line">  insert(el, item)&#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el)</span><br><span class="line">    <span class="keyword">const</span> cur = <span class="keyword">this</span>.find(item)</span><br><span class="line">    newNode.next = cur.next</span><br><span class="line">    cur.next = newNode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  remove(item)&#123;</span><br><span class="line">    <span class="keyword">const</span> preNode = <span class="keyword">this</span>.findPre(item)</span><br><span class="line">    <span class="keyword">if</span> (preNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      preNode.next = preNode.next.next</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h2><p>既然单链表可以有循环链表，双向链表也可以是循环链表。双向循环链表头结点的prev指针指向尾结点，尾结点的next指针指向头结点。如下图所示：</p><p><img src="https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/20210114231724.png" alt></p><p>实现代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>本文所有示例代码见：<a href>linked-list</a></p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ul><li><a href="https://juejin.cn/post/6844903798754770958" target="_blank" rel="noopener">JavaScript数据结构之链表–介绍</a></li><li><a href="https://juejin.cn/post/6844903498362912775" target="_blank" rel="noopener">JS中的算法与数据结构——链表(Linked-list)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;数据结构与算法在前端开发工程师的日常工作中也许不常用，但在这对前端工程师要求日益提高的时代，如果对数据结构、算法思维、代码效率等知识拥有足够
      
    
    </summary>
    
      <category term="算法" scheme="http://www.chenhanpeng.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.chenhanpeng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="http://www.chenhanpeng.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊浏览器本地存储</title>
    <link href="http://www.chenhanpeng.com/local-storage-of-browser/"/>
    <id>http://www.chenhanpeng.com/local-storage-of-browser/</id>
    <published>2021-01-17T04:17:12.000Z</published>
    <updated>2021-01-18T02:33:53.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一名前端工程师，我们每天都在跟浏览器打交道，浏览器的本地存储更是经常用到。今天我们就一起来聊一聊浏览器的本地存储。</p><p>浏览器的本地存储主要分为：<code>Cookie</code>、 <code>WebStorage</code>、 <code>IndexedDB</code>。其中WebStorage又可以分为<code>localStorage</code>和<code>sessionStorage</code>。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP Cookie，通常叫做Cookie，一开始是在客户端用于存储会话信息的。</p><h3 id="Cookie主要构成"><a href="#Cookie主要构成" class="headerlink" title="Cookie主要构成"></a>Cookie主要构成</h3><ul><li>name：名称，一个唯一确定的cookie的名称，cookie的名称必须经过URL编码。</li><li>value：值，存储在cookie中的字符串值。值必须被URL编码。</li><li>Domain：域，指明cookie对哪个域有效，所有向该域发送的请求都会包含这个信息。</li><li>path：路径，对于指定域中的那个路径，应该向服务器发送cookie。</li><li>Expires/Max-Age：有效期，表示cookie的有效期。</li><li>HttpOnly：如果这个这个值设置为true，就不能通过JS脚本获取cookie的值。通过这个值可以有效防止XSS攻击。</li><li>Secure：安全标志，指定后，cookie只有在使用SSL连接的时候才能发送到服务器。</li></ul><h3 id="Cookie的原理"><a href="#Cookie的原理" class="headerlink" title="Cookie的原理"></a>Cookie的原理</h3><p>第一次访问网站时，浏览器发出请求，服务器响应请求后，会在响应头中添加一个Set-Cookie，将cookie放入响应请求中。</p><p>在第二次发起请求时，浏览器通过Cookie请求头部将cookie信息送给服务器，服务端根据cookie信息辨别用户身份。</p><p>Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p><h3 id="Cookie的生成"><a href="#Cookie的生成" class="headerlink" title="Cookie的生成"></a>Cookie的生成</h3><p>Cookie的生成方式主要有两种：</p><ul><li>服务端设置Cookie</li><li>客户端设置Cookie</li></ul><p>服务端设置方式参考上面Cookie的原理，具体的实现方式自行查阅相关资料。客户端设置Cookie方法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=zhangsan; age=20"</span>;</span><br></pre></td></tr></table></figure></p><h3 id="Cookie的缺点"><a href="#Cookie的缺点" class="headerlink" title="Cookie的缺点"></a>Cookie的缺点</h3><ul><li>每个特定域名下的cookie数量有限，不同浏览器数量限制不同。如果超过数量限制后再设置Cookie，浏览器就会清除以前设置的Cookie。</li><li>大小只有4kb。</li><li>每次HTTP请求都会默认带上Cookie，影响获取资源的效率。</li><li>Cookie的获取、设置、删除方法需要我们自己去封装。</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>Web Storage分为localStorage和sessionStorage。</p><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>localStorage以键值对的方式存储，永久存储，永不失效，除非手动删除。</p><p>localStorage有以下几个特点：</p><ul><li>保持的数据永久有效，除非手动删除；</li><li>大小为5M</li><li>仅在客户端使用，不和服务端进行通信</li><li>接口封装较好</li></ul><p>使用方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置</span></span><br><span class="line">localStorage.setItem(<span class="string">'name'</span>, <span class="string">'张三'</span>)</span><br><span class="line">localStorage.age = <span class="string">'25'</span></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">localStorage.getItem(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">let</span> age = localStorage.age</span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line">localStorage.removeItem(<span class="string">'name'</span>)</span><br><span class="line"><span class="comment">// 移除所有</span></span><br><span class="line">localStorage.clear()</span><br></pre></td></tr></table></figure></p><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>sessionStorage对象存储特定于某个会话的数据，当这个会话的页签或浏览器关闭，sessionStorage也就消失了。</p><p>页面刷新之后，存储在sessionStorage中的数据仍然存在可用。</p><p>sessionStorage的特点：</p><ul><li>会话级别的浏览器存储</li><li>大小为5M</li><li>仅在客户端使用，不和服务端通信</li><li>接口封装较好</li></ul><p>使用方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'张三'</span>)</span><br><span class="line">sessionStorage.age = <span class="string">'25'</span></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">sessionStorage.getItem(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">let</span> age = sessionStorage.age</span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">'name'</span>)</span><br><span class="line"><span class="comment">// 移除所有</span></span><br><span class="line">sessionStorage.clear()</span><br></pre></td></tr></table></figure></p><p>sessionStorage和localStorage的区别：localStorage的数据可以长期保留，sessionStorage的数据在关闭页面后即被清空。</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB，全称Indexed Database API，是浏览器中保持结构化数据的一种数据库。</p><p>IndexedDB的思想是创建一套API，方便保存和读取JavaScript对象，同时支持查询和搜索。</p><p><strong>IndexedDB特点</strong></p><ul><li>键值对存储：IndexedDB采用对象仓库存储数据，可以存储所有类型的数据。仓库中数据以键值对的形式保持。</li><li>异步：IndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作。</li><li>支持事务：有学过数据库的对事务肯定不陌生。事务意味着在一系列操作中，只要有一步失败，整个事务就都取消，数据库回滚到事务执行之前，不存在只改写一部分数据的情况。</li><li>同源限制：IndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</li><li>储存空间大: IndexedDB 的储存空间比 localStorage大得多，一般来说不少于 250MB，甚至没有上限。</li><li>支持二进制储存: IndexedDB不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</li></ul><p>IndexedDB的入门教程，可以查看阮一峰老师的文章：<a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html" target="_blank" rel="noopener">浏览器数据库 IndexedDB 入门教程</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Cookie主要用于“维持状态”，而非本地存储数据</li><li>Web Storage是专门为浏览器提供的数据存储机制，不与服务端发生通信</li><li>IndexedDB 用于客户端存储大量结构化数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;作为一名前端工程师，我们每天都在跟浏览器打交道，浏览器的本地存储更是经常用到。今天我们就一起来聊一聊浏览器的本地存储。&lt;/p&gt;
&lt;p&gt;浏览器
      
    
    </summary>
    
      <category term="前端" scheme="http://www.chenhanpeng.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器" scheme="http://www.chenhanpeng.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="本地存储" scheme="http://www.chenhanpeng.com/tags/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
</feed>
