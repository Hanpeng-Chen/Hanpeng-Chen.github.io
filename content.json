{"meta":{"title":"代码视界","subtitle":"Hanpeng Chen's Blog","description":"HanpengChen 的技术博客，主要分享前端领域相关优质技术文章、教程、项目经验、面试经验、行业前沿信息等，偶尔分享Python、机器学习和大数据等方面的技术文章。","author":"Hanpeng Chen","url":"http://www.chenhanpeng.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-04-26T00:55:26.400Z","updated":"2021-04-26T00:55:26.400Z","comments":false,"path":"/404.html","permalink":"http://www.chenhanpeng.com//404.html","excerpt":"","text":"猜你想看 PDF.js实现在线展示pdf文件"},{"title":"archives","date":"2019-03-19T15:35:45.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"archives/index.html","permalink":"http://www.chenhanpeng.com/archives/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-08-10T02:19:13.737Z","updated":"2020-08-10T02:19:13.737Z","comments":false,"path":"books/index.html","permalink":"http://www.chenhanpeng.com/books/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2021-04-21T01:17:31.963Z","updated":"2021-04-21T01:17:31.963Z","comments":false,"path":"categories/index.html","permalink":"http://www.chenhanpeng.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-08-10T02:19:13.784Z","updated":"2020-08-10T02:19:13.784Z","comments":false,"path":"repository/index.html","permalink":"http://www.chenhanpeng.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-10T02:19:13.784Z","updated":"2020-08-10T02:19:13.784Z","comments":true,"path":"links/index.html","permalink":"http://www.chenhanpeng.com/links/index.html","excerpt":"","text":""},{"title":"标签页","date":"2021-04-21T01:17:31.964Z","updated":"2021-04-21T01:17:31.964Z","comments":false,"path":"tags/index.html","permalink":"http://www.chenhanpeng.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-04-21T01:17:31.962Z","updated":"2021-04-21T01:17:31.962Z","comments":false,"path":"about/index.html","permalink":"http://www.chenhanpeng.com/about/index.html","excerpt":"","text":"Personal一个喜欢瞎折腾的前端开发工程师，干着前端的工作，向往着AI、大数据领域。 Blog本博客主要记录和分享一些平时学习或看到的知识，如有错误之处烦请指正。博客内容主要集中在前端、机器学习和大数据领域，但不局限于此。 公众号前端极客技术(FrontGeek) Contact可通过邮箱或关注公众号：前端极客技术，在公众号获取我的微信二维码 Email: hanpengchen07@163.com"}],"posts":[{"title":"阅读一行代码统一规范团队包管理器神器[only-allow] 源码","slug":"source_code_learning/only-allow","date":"2021-11-30T01:47:14.000Z","updated":"2021-12-21T01:51:39.184Z","comments":true,"path":"read-source-code-of-only-allow/","link":"","permalink":"http://www.chenhanpeng.com/read-source-code-of-only-allow/","excerpt":"","text":"当前市场上包管理器常用的有npm、yarn、pnpm。我们在实际项目开发中一般通过是在文档中说明约定使用的包管理器，但偶尔会遇到不遵守约定的人，他使用了其他的包管理器安装了其他的依赖，上传了代码。这种情况有可能导致严重的线上问题。如果我们可以通过代码进行强制约束使用同一包管理器，那么问题也就解决了。only-allow就是一款解决该问题的工具。 克隆代码12345// only-allow 官方仓库地址git clone https://github.com/pnpm/only-allow.gitcd only-allowpnpm i 从项目的README.md文件我们可以了解到only-allow的作用：在项目上强制使用特定的包管理器。 only-allow的用法only-allow具体的用法如下： Add a preinstall script to your project’s package.json 如果你想强制使用npm，添加： 12345&#123; \"scripts\": &#123; \"preinstall\": \"npx only-allow npm\" &#125;&#125; 如果你想强制使用pnpm，添加： 12345&#123; \"scripts\": &#123; \"preinstall\": \"npx only-allow pnpm\" &#125;&#125; 如果你想强制使用yarn，添加： 12345&#123; \"scripts\": &#123; \"preinstall\": \"npx only-allow yarn\" &#125;&#125; 调试源码从package.json文件我们可以得知项目的主入口文件为：bin.js 在package.json文件中添加如下命令： 12345&#123; \"scripts\" &#123; \"preinstall\": \"node bin.js pnpm\" &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env nodeconst whichPMRuns = require('which-pm-runs')const boxen = require('boxen') // 在终端中创建盒子，使打印信息更加显眼const argv = process.argv.slice(2)if (argv.length === 0) &#123; console.log('Please specify the wanted package manager: only-allow &lt;npm|pnpm|yarn&gt;') process.exit(1)&#125;// 获取到用户传入的希望使用的包管理器// npm yarn pnpm都不是，报错const wantedPM = argv[0]if (wantedPM !== 'npm' &amp;&amp; wantedPM !== 'pnpm' &amp;&amp; wantedPM !== 'yarn') &#123; console.log(`\"$&#123;wantedPM&#125;\" is not a valid package manager. Available package managers are: npm, pnpm, or yarn.`) process.exit(1)&#125;// 使用的包管理器const usedPM = whichPMRuns()// 如果使用的包管理和希望的不一致，根据对应的情况进行报错提示，并退出进程if (usedPM &amp;&amp; usedPM.name !== wantedPM) &#123; const boxenOpts = &#123; borderColor: 'red', borderStyle: 'double', padding: 1 &#125; switch (wantedPM) &#123; case 'npm': console.log(boxen('Use \"npm install\" for installation in this project', boxenOpts)) break case 'pnpm': console.log(boxen(`Use \"pnpm install\" for installation in this project.If you don't have pnpm, install it via \"npm i -g pnpm\".For more details, go to https://pnpm.js.org/`, boxenOpts)) break case 'yarn': console.log(boxen(`Use \"yarn\" for installation in this project.If you don't have Yarn, install it via \"npm i -g yarn\".For more details, go to https://yarnpkg.com/`, boxenOpts)) break &#125; process.exit(1)&#125; which-pm-runs源码123456789101112131415161718192021222324'use strict'module.exports = function () &#123; // process.env.npm_config_user_agent拿到的是如下字符串 // 'pnpm/6.23.2 npm/? node/v16.13.0 darwin arm64' if (!process.env.npm_config_user_agent) &#123; return undefined &#125; return pmFromUserAgent(process.env.npm_config_user_agent)&#125;function pmFromUserAgent (userAgent) &#123; const pmSpec = userAgent.split(' ')[0] const separatorPos = pmSpec.lastIndexOf('/')// 返回包管理器及其版本，例如// &#123;// name: 'pnpm',// version: '6.23.2'// &#125; return &#123; name: pmSpec.substr(0, separatorPos), version: pmSpec.substr(separatorPos + 1) &#125;&#125; 从which-pm-runs的源码，学到了获取当前运行脚本的包管理器和版本的方法：通过获取process.env.npm_config_user_agent变量，进行相应的截取。 npm命令钩子12345preinstall：在install之前执行installpostinstall：在install之后执行 总结only-allow这个包对多人协作开发的项目还是很有用的，找个时间用到公司的项目上，进一步规范团队开发。","categories":[{"name":"阅读源码","slug":"阅读源码","permalink":"http://www.chenhanpeng.com/categories/阅读源码/"}],"tags":[{"name":"阅读源码","slug":"阅读源码","permalink":"http://www.chenhanpeng.com/tags/阅读源码/"}]},{"title":"学习Vue源码前需要了解的defineProperty和Proxy","slug":"javascript/defineProperty和Proxy","date":"2021-08-24T04:12:35.000Z","updated":"2021-08-24T04:14:22.183Z","comments":true,"path":"javascript-defineProperty-and-proxy/","link":"","permalink":"http://www.chenhanpeng.com/javascript-defineProperty-and-proxy/","excerpt":"","text":"作者：Hanpeng_Chen 公众号：前端极客技术 前言大家有使用Vue开发想必对响应式都有了解，知道Vue2是用Object.defineProperty实现数据劫持，进而实现的双向绑定。在已经发布快一年的Vue3中，数据响应式的实现由Object.defineProperty API改成了Proxy API。 接下来我们一起来看看这两个API的基本用法。 definePropertyObject.defineProperty() 是ES5提供的方法，该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 语法 Object.defineProperty(obj, prop, description) 参数 obj：要在其上定义属性的对象 prop：要定义或修改的属性的名称 description：将被定义或修改的属性的描述符。是一个对象，具体为： configurable：是否可以修改默认属性，类型为 boolean enumerable：是否可以被枚举，类型为 boolean writable：是否可以修改这个属性的值，类型为 boolean value：初始值，可以是任意类型的值 get：被修饰的属性，在被访问的时候执行，类型为 Function set：被修饰的属性，在被修改的时候执行，类型为 Function description参数表示的属性描述符有两种主要形式：数据描述符和存取描述符。一个描述符只能是这两者中的一个，不能同时是两者。 数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。 存取描述符是由get和set函数所描述的属性。 两种描述符都是对象。 两者均具有以下两种可选键值configurable 当且仅当该属性的configurable键值为true时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认值为false。 enumerable 当且仅当该属性的enumerable键值为true时，该属性才会出现再对象的枚举属性中。默认为false。 数据描述符具有以下两种可选键值value 该属性对应的值。可以是任何有效的JavaScript值。默认为 undefined。 writable 当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value ，才能被赋值运算符改变。默认为false。 存取描述符还具有以下可选键值get 一个给属性提供 getter 函数的方法，如果没有getter为undefined。该方法返回值被用作属性值。默认为 undefined。 set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。 示例我们通过下面一个例子来看看defineProperty是如何在访问以及赋值的时候执行get和set。 12345678910111213141516let obj = &#123;&#125;, value = null;Object.defineProperty(obj, 'title', &#123; get: function() &#123; console.log('执行了 get 操作'); return value; &#125;, set: function(newValue) &#123; console.log('执行了 set 操作'); value = newValue; &#125;&#125;)obj.title = 'defineProperty demo'; // 执行了 set 操作console.log(obj.title); // 执行了 get 操作 // defineProperty demoobj.desc = 'xxxxxx'; // 不执行set 因为没有对desc这个属性进行劫持console.log(obj.desc); // xxxxxx 不执行get，因为没有对desc这个属性进行劫持 从上面的例子我们可以看到，defineProperty 只能代理某个属性，如果没有对属性进行劫持代理，对其进行操作是不会走 get 和 set 方法 我们再来看看属性描述符是数据描述符的例子： 123456Object.defineProperty(&#123;&#125;, 'title', &#123; value: 'demo', writable: true, enumerable: true, configurable: true&#125;); 如果属性描述符同时是数据描述符和存取描述符两种形式，则会报错：1234567// 报错：TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #&lt;Object&gt;Object.defineProperty(&#123;&#125;, 'title', &#123; value: 'demo', get: function() &#123; return 'defineProperty demo' &#125;&#125;) Proxy使用defineProperty只能重定义属性的get和set行为，到了ES6，提供了Proxy，可以重定义更多的行为，比如in、delete、函数调用等更多行为。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 语法 var proxy = new Proxy(target, handler) 参数 target：要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组、函数，甚至另一个代理）。 handler：一个通常以函数作为属性的对象，各属性中的函数分别定义了再执行各种操作时代理p的行为。回调方法的合集。 handler.getPrototypeOf() handler.setPrototypeOf() handler.isExtensible() handler.preventExtensions() handler.getOwnPropertyDescriptor() handler.defineProperty() handler.has() handler.get(target, property) handler.set(target, property, value) handler.deleteProperty() handler.ownKeys() handler.apply() handler.construct() 从上面我们可以发现，Proxy也有get和set方法。和defineProperty相比，Proxy接收的target可以为任何类型的对象，包括原生数组、函数，甚至是另一个代理对象。 示例先来看下get和set的例子： 123456789101112131415let proxy = new Proxy(&#123;&#125;, &#123; get: (obj, propKey) =&gt; &#123; console.log(' get 操作') return obj[propKey] &#125;, set: (obj, propKey, value) =&gt; &#123; console.log('设置 set 操作') obj[propKey] = value &#125;&#125;)proxy.title = 'proxy demo' // 设置 set 操作console.log(proxy.title) // get 操作 // proxy demoproxy.desc = 'xxxx' // 设置 set 操作console.log(proxy.desc) // get 操作 // xxxx 如果对象时一个多层嵌套对象，我们来看下Proxy对其属性的监听：123456789101112131415161718192021222324252627let obj = &#123; a: 1, b: &#123; a1: 11, b1: &#123; a2: 21 &#125; &#125;&#125;let proxy = new Proxy(obj, &#123; get: (obj, propKey) =&gt; &#123; console.log(' get 操作') return obj[propKey] &#125;, set: (obj, propKey, value) =&gt; &#123; console.log('设置 set 操作') obj[propKey] = value &#125;&#125;)console.log(proxy.a) // get 操作 // 1console.log(proxy.b.a1) // get 操作 // 11console.log(proxy.b.b1.a2) // get 操作 // 21console.log('--proxy.a--')proxy.a = 'a' // 设置 set 操作console.log('--proxy.b.a1--')proxy.b.a1 = 'a1' // 不触发 set 从上面我们可以发现，嵌套再深，我们都可以通过get监听到属性的访问。但是set并不像get自带递归，所以我们想要实现响应式，就需要对嵌套的对象或者数组，再次进行响应式处理。实现如下： 12345678910111213141516171819202122232425262728293031323334let obj = &#123; a: 1, b: &#123; a1: 11, b1: &#123; a2: 21 &#125; &#125;&#125;const handler = &#123; get(obj, prop) &#123; console.log(' get 操作') const val = obj[prop] if(val !== null &amp;&amp; typeof val=== 'object')&#123; return new Proxy(val, handler);//代理内层 &#125;else&#123; return val; // 返回obj[prop] &#125; &#125;, set(obj, prop, value) &#123; console.log('set', prop) obj[prop] = value return true // set需要返回true 代表赋值完成，否则会报错 &#125;&#125;const proxy = new Proxy(obj, handler)console.log(proxy.a) // get 操作 // 1console.log(proxy.b.a1) // get 操作 // 11console.log(proxy.b.b1.a2) // get 操作 // 21console.log('--proxy.a--')proxy.a = 'a' // set aconsole.log('--proxy.b.a1--')proxy.b.a1 = 'a1' // set a1 除了get和set，proxy可以拦截多达13种操作，比如：has(target, propKey) ，可以拦截propKey in proxy 的操作，返回一个布尔值。 12345678910111213// 使用 has 方法隐藏某些属性，不被 in 运算符发现let handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false &#125; return key in target; &#125;&#125;;let target = &#123; _prop: 'foo', prop: 'foo' &#125;;let proxy = new Proxy(target, handler);console.log('_prop' in proxy); // falseconsole.log('prop' in proxy); // true 性能的比较Vue3在响应式的实现性能上做了优化，其中数据响应式的实现由Object.defineProperty API 改成了Proxy API。因此可能会有人认为Proxy API 的性能要优于 Object.defineProperty，但是实际上Proxy在性能上要比Object.defineProperty差的。具体的可以参考这篇文章：Thoughts on ES6 Proxies Performance。 若对象内部属性要全部递归代理，Proxy 可以只在调用的时候递归，而 Object.definePropery 需要一次完成所有递归，性能比 Proxy 差。 在Vue2响应式实现中，definePropery 是在一开始，将传入的对象的所有属性全部进行递归，之后才处理set和get。 但是Vue3中的Proxy的递归是在set中，这样我们就可以根据需求来调整递归原则。也就是说，在一些条件下，让其不进行递归。这才是Vue3在响应式性能上优于Vue2的主要原因之一。 两者区别 Proxy 是对整个对象的代理，而 Object.defineProperty 只能代理某个属性。在实现响应式函数的时候，defineProperty 需要对每个属性进行遍历添加代理。 对象上新增属性，Proxy可以监听到，Object.defineProperty不能。 数组新增修改，Proxy可以监听到，Object.defineProperty不能。 若对象内部属性要全部递归代理，Proxy可以只在调用的时候递归，而 Object.definePropery 需要一次完成所有递归，性能比 Proxy 差。 Proxy 不兼容 IE，Object.defineProperty 不兼容 IE8 及以下。 参考资料ECMAScript 6 入门 MDN-Object.defineProperty 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、公众号：前端极客技术，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"}]},{"title":"一文学会Vue3新特性","slug":"vue_series/学习Vue3新特性","date":"2021-06-29T09:26:36.000Z","updated":"2021-06-29T09:30:38.385Z","comments":true,"path":"learn-vue3/","link":"","permalink":"http://www.chenhanpeng.com/learn-vue3/","excerpt":"","text":"Vue3.0 周边生态现在已经完善得差不多了，新项目可以开始使用Vue3来开发了，今天我们先来学习Vue3的一些新特性。 Composition API为什么选择Composition APIComposition API翻译成中文就是组合式API。有的人可能会疑惑为什么要用Composition API？原来Vue2中的options API不是也能实现吗？ 我们先来Vue3官方文档中的例子： 假设我们的应用中有一个显示某个用户的仓库列表的视图。此外，我们还希望有搜索和筛选功能。实现此视图组件的代码可能如下所示： 12345678910111213141516171819202122232425262728293031323334// src/components/UserRepositories.vueexport default &#123; components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;, props: &#123; user: &#123; type: String, required: true &#125; &#125;, data () &#123; return &#123; repositories: [], // 1 filters: &#123; ... &#125;, // 3 searchQuery: '' // 2 &#125; &#125;, computed: &#123; filteredRepositories () &#123; ... &#125;, // 3 repositoriesMatchingSearchQuery () &#123; ... &#125;, // 2 &#125;, watch: &#123; user: 'getUserRepositories' // 1 &#125;, methods: &#123; getUserRepositories () &#123; // 使用 `this.user` 获取用户仓库 &#125;, // 1 updateFilters () &#123; ... &#125;, // 3 &#125;, mounted () &#123; this.getUserRepositories() // 1 &#125;&#125; 该组件有以下几个职责： 从假定的外部 API 获取该用户的仓库，并在用户有任何更改时进行刷新 使用 searchQuery 字符串搜索仓库 使用 filters 对象筛选仓库 使用 (data、computed、methods、watch) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，逻辑关注点的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解。 这是一个大型组件的示例，其中逻辑关注点按颜色进行分组。 这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块。 如果能够将同一个逻辑关注点相关代码收集在一起会更好。而这正是组合式 API 使我们能够做到的。 Vue3兼容大部分Vue2语法，所以在Vue3中写Vue2语法是没问题的（废除的除外）。 setupsetup是Vue3新增的一个选项，是使用Composition API的入口。 setup的执行时机setup只在初始化时执行一次，所有的 Composition API 函数都在这里使用。 setup是在生命周期beforeCreate之前执行。我们通过下面的代码来验证一下： 123456789beforeCreate() &#123; console.log('---------beforeCreate--------');&#125;,setup() &#123; console.log('---------setup--------'); return &#123;&#125;;&#125;,// ---------setup--------// ---------beforeCreate-------- 由上面的执行结果我们可以推断出，setup执行时，组件对象还没有创建，此时this是undefined，因此在setup函数中不能通过this对象访问data/computed/methods/props。 setup参数setup有两个可选参数： props：组件传入的属性（响应式对象，且可以监听） context：上下文对象。setup中不能访问Vue2中最常用的this对象，所以context中就提供了this中最常用的三个属性：attrs、slot 和emit。 12345import &#123; toRef &#125; from 'vue'setup(props) &#123; const title = toRef(props, 'title') console.log(title.value)&#125; 由于props是响应式的，所以不能使用 ES6 解构，解构会消除prop的响应性。如果需要解构prop，可以在setup函数中使用toRefs函数来完成此操作。 12345678910export default &#123; setup(props, context) &#123; // Attribute (非响应式对象) console.log(context.attrs) // 插槽 (非响应式对象) console.log(context.slots) // 触发事件 (方法) console.log(context.emit) &#125;&#125; reactivereactive函数接受一个普通对象，返回一个响应式数据对象。 1234const data = reactive(&#123; count: 0, result: computed(() =&gt; data.count + 1)&#125;) ref 和 isRef ref：接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property .value。 isRef：检查值是否为一个 ref 对象。 1234567891011export default &#123; setup() &#123; const count = ref(0) console.log('count is ref：', isRef(count)) console.log('count: ', count) console.log('count.value：', count.value) return &#123; count &#125; &#125;&#125; toRefs将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。 我们通过reactive创建的对象，如果在模板中使用，就必须以xxxx.xxx的形式，但如果用到的地方比较多就比较麻烦。如果用ES6解构，就会失去响应式。 如果我们利用toRefs可以将一个响应式 reactive 对象的所有原始属性转换为响应式的ref属性。 前面提到的setup函数的props要解构可以使用toRefs。 示例代码如下：123456789101112131415161718192021222324&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;p&gt;number: &#123;&#123;number&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; toRefs, reactive &#125; from 'vue'export default &#123; setup() &#123; const state = reactive(&#123; number: 0, date: '20210628' &#125;) const state2 = toRefs(state) setInterval(() =&gt; &#123; state.number++ &#125;, 1000) return &#123; ...state2 &#125; &#125;&#125;&lt;/script&gt; computed函数与Vue2中的 computed 配置功能一致，返回的是一个 ref 类型的对象。 123456789setup() &#123; const state = reactive(&#123; count: 0, plusOne: computed(() =&gt; state.count + 1) &#125;) return &#123; ...toRefs(state) &#125;&#125; watch函数监视指定的一个或多个响应式数据，一旦数据变化，就自动执行监视回调。 1234567891011121314151617181920212223242526import &#123; watch, ref, reactive &#125; from 'vue'export default &#123; setup() &#123; const name = ref('前端极客技术') const otherName = reactive(&#123; firstName: '前端', lastName: '技术' &#125;) watch(name, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue) &#125;) watch( () =&gt; &#123; return otherName.firstName + otherName.lastName &#125;, value =&gt; &#123; console.log(value) &#125; ) setTimeout(() =&gt; &#123; name.value = '前端极客' otherName.firstName = '前端极客' &#125;, 3000) &#125;&#125; watchEffect为了根据响应式状态自动应用和重新应用副作用，我们可以使用 watchEffect 方法。它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。 123456789const count = ref(0)watchEffect(() =&gt; console.log(count.value))// -&gt; logs 0setTimeout(() =&gt; &#123; count.value++ // -&gt; logs 1&#125;, 100) 生命周期通过下面的图来看下Vue2和Vue3生命周期钩子的对比： Vue3新增了setup Vue2中的beforeDestroy名称变更为beforeUnmount Vue2中的destroyed变更为 unmounted Vue3.x 还新增用于调试的钩子函数onRenderTriggered和onRenderTricked 1234567891011121314151617181920setup() &#123; onBeforeMount(() =&gt; &#123; console.log('--onBeforeMount') &#125;) onMounted(() =&gt; &#123; console.log('--onMounted') &#125;) onBeforeUpdate(() =&gt; &#123; console.log('--onBeforeUpdate') &#125;) onUpdated(() =&gt; &#123; console.log('--onUpdated') &#125;) onBeforeUnmount(() =&gt; &#123; console.log('--onBeforeUnmount') &#125;) onUnmounted(() =&gt; &#123; console.log('--onUnmounted') &#125;)&#125; getCurrentInstancegetCurrentInstance 支持访问内部组件实例，用于高阶用法或库的开发。 123456789import &#123; getCurrentInstance &#125; from 'vue'const MyComponent = &#123; setup() &#123; const internalInstance = getCurrentInstance() internalInstance.appContext.config.globalProperties // 访问 globalProperties &#125;&#125; getCurrentInstance 只能在 setup 或生命周期钩子中调用。 如需在 setup 或生命周期钩子外使用，请先在 setup 中调用 getCurrentInstance() 获取该实例然后再使用。 TeleportTeleport是Vue3中新增的特性，翻译成中文就是传送的意思。Teleport提供了一种简洁的方式，让组件的html在父组件界面外的特定标签下插入显示。也就是我们可以把 子组件 或者 dom节点 插入到任何你想插入到的地方去。 语法： 使用to属性，指定要插入的节点。其值为选择器 1&lt;teleport to=&quot;body&quot;&gt;&lt;/teleport&gt; 我们使用Teleport实现一个模态窗口：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;button @click=&quot;modalOpen = true&quot;&gt; 弹出一个全屏模态窗口&lt;/button&gt; &lt;teleport to=&quot;body&quot;&gt; &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt; &lt;div&gt; 这是一个模态窗口! 我的父元素是&quot;body&quot;！ &lt;button @click=&quot;modalOpen = false&quot;&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/teleport&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &apos;vue&apos;;export default &#123; setup() &#123; const modalOpen = ref(true) return &#123; modalOpen &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;.modal &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: rgba(0,0,0,.5); display: flex; flex-direction: column; align-items: center; justify-content: center;&#125;.modal div &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: white; width: 300px; height: 300px; padding: 5px;&#125;&lt;/style&gt; Suspense Suspense 是一个试验性的新特性并且其 API 可能随时更改。它不应该被用在生产环境。 在正确渲染组件之前进行一些异步请求是很常见的事。组件通常会在本地处理这种逻辑，绝大多数情况下这是非常完美的做法。 该 &lt;suspense&gt; 组件提供了另一个方案，允许等待整个组件树处理完毕而不是单个组件。 这个 &lt;suspense&gt; 组件有两个插槽。它们都只接收一个子节点。default 插槽里的节点会尽可能展示出来。如果不能，则展示 fallback 插槽里的节点。 常见的一个用例：用到了异步组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 父组件&lt;template&gt; &lt;suspense&gt; &lt;template #default&gt; &lt;async-demo /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div&gt; Loading... &lt;/div&gt; &lt;/template&gt; &lt;/suspense&gt;&lt;/template&gt;&lt;script&gt;import &#123;defineAsyncComponent&#125; from &apos;vue&apos;export default &#123; components: &#123; AsyncDemo: defineAsyncComponent(() =&gt; import(&apos;./AsyncDemo.vue&apos;)) &#125;&#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;h2&gt;AsyncDemo&lt;/h2&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;export default &#123; name: &apos;AsyncDemo&apos;, setup () &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; msg: &apos;async import&apos; &#125;) &#125;, 2000) &#125;) &#125;&#125;&lt;/script&gt; Fragment在Vue2中，template中只允许有一个根节点，但是在Vue3中，可以直接写多个根节点。 12345&lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt; 破坏性变化 Global API 改为应用程序实例调用 Global and internal APIs重构为可做摇树优化 model选项和v-bind的sync 修饰符被移除，统一为v-model参数形式 渲染函数API修改 函数式组件仅能通过简单函数方式创建 废弃在SFC的template上使用functional或者添加functional选项的方式声明函数式组件 异步组件要求使用defineAsyncComponent 方法创建 组件data选项应该总是声明为函数 自定义组件白名单执行于编译时 is属性仅限于用在component标签上 $scopedSlots 属性被移除，都用$slots代替 特性强制策略变更 自定义指令API和组件一致 一些transition类名修改: v-enter -&gt; v-enter-from v-leave -&gt; v-leave-from watch 选项 和$watch 不再支持点分隔符字符串路径, 使用计算函数作为其参数 Vue 2.x中应用程序根容器的 outerHTML 会被根组件的模板替换 (或被编译为template)。Vue 3.x现在使用应用根容器的innerHTML取代. 移除 移除keyCode 作为 v-on 修饰符 on,on, on,off and $once 移除 Filters移除 Inline templates attributes移除 最后本文只是介绍了Vue3中的一些常用的新特性，更多具体内容需要大家详细阅读Vue3的官方文档： https://v3.cn.vuejs.org/ 如果你觉得这篇内容对你有帮助的话： 点赞支持下吧，让更多的人也能看到这篇内容 关注公众号：前端极客技术，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://www.chenhanpeng.com/categories/前端/Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://www.chenhanpeng.com/tags/Vue3/"}]},{"title":"vue项目配合nginx开启gzip提升页面打开速度","slug":"solutions/vue项目开启gzip压缩","date":"2021-05-20T07:01:05.000Z","updated":"2021-05-21T03:39:49.268Z","comments":true,"path":"use-gzip-in-vue-project/","link":"","permalink":"http://www.chenhanpeng.com/use-gzip-in-vue-project/","excerpt":"","text":"用Vue开发移动端H5，可能很多同学会遇到最后打包上线，用户第一次打开可能有3s，甚至更久的白屏时间，白屏时间过长是很容易导致用户流失的，所以是必须要解决的问题。 经排查后发现是因为打包后的app.js太大，以及引用的一些插件安装包加载比较慢。 针对这种情况有很多解决方案： 路由懒加载 打包文件中去掉map文件 CDN引入第三方库 代码压缩 分包 预渲染 开启Gzip gzip压缩一种非常方便，且效果明显的解决方法，使用gzip压缩可以减小60%以上的体积。 从上图我们可以看到gzip压缩后的文件体积基本减小了60%左右，效果喜人。 下面我们主要看下如何开启Gzip打包，已经nginx如何配置开启Gzip。 gzip介绍gzip属于在线压缩，在资源通过http发送报文给客户端的过程中，进行压缩，可以减少客户端带宽占用，减少文件传输大小。 html、js、css文件，甚至Json数据都可以用其来进行压缩。 但是不是每个浏览器都支持gzip的，如果知道客户端是否支持gzip呢，请求头中有个Accept-Encoding来标识对压缩的支持。客户端http请求头声明浏览器支持的压缩方式，服务端配置启用压缩，压缩的文件类型，压缩方式。当客户端请求到服务端的时候，服务器解析请求头，如果客户端支持gzip压缩，响应时对请求的资源进行压缩并返回给客户端，浏览器按照自己的方式解析，在http响应头，我们可以看到content-encoding:gzip，这是指服务端使用了gzip的压缩方式。 那么怎么看有没有用gzip压缩的文件呢，打开f12，查看network，按照下面的方式过滤，如果content-encoding是gzip，说明返回的是gzip。 nginx的gzip分为两种： nginx动态压缩，对每个请求先压缩再输出 nginx静态压缩，使用现成的扩展名为.gz的预压缩文件 nginx动态压缩配置 gzipgzip使用环境:http、server、location、if(x)，一般把它定义在nginx.conf的http{…..}之间 配置12345678910111213141516171819http &#123; gzip on; gzip_min_length 1k; gzip_buffers 4 8k; gzip_http_version 1.0; gzip_comp_level 4; gzip_proxied any; gzip_types text/css text/javascript text/xml text/plain image/x-icon application/javascript application/x-javascript application/json; gzip_vary on; gzip_disable \"MSIE [1-6]\\.\"; #以下的配置省略...&#125; nginx -s reload ：修改配置后重新加载生效 配置项说明 gzip：on为启用，off为关闭 gzip_min_length：设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。 gzip_buffers：获取多少内存用于缓存压缩结果，‘4 16k’表示以16k*4为单位获得 gzip_comp_level：gzip压缩比（1~9），越小压缩效果越差，但是越大处理越慢，所以一般取中间值; gzip_types：对特定的MIME类型生效,其中’text/html’被系统强制启用 gzip_http_version：识别http协议的版本,早起浏览器可能不支持gzip自解压,用户会看到乱码 gzip_vary：启用应答头”Vary: Accept-Encoding” gzip_proxied：nginx做为反向代理时启用,off(关闭所有代理结果的数据的压缩),expired(启用压缩,如果header头中包括”Expires”头信息),no-cache(启用压缩,header头中包含”Cache-Control:no-cache”),no-store(启用压缩,header头中包含”Cache-Control:no-store”),private(启用压缩,header头中包含”Cache-Control:private”),no_last_modefied(启用压缩,header头中不包含”Last-Modified”),no_etag(启用压缩,如果header头中不包含”Etag”头信息),auth(启用压缩,如果header头中包含”Authorization”头信息) gzip_disable：(IE5.5和IE6 SP1使用msie6参数来禁止gzip压缩 )指定哪些不需要gzip压缩的浏览器(将和User-Agents进行匹配),依赖于PCRE库 问题开启gzip，资源下载体积减小了，下载效率提升了，但是在线gzip比较占用CPU，和 gzip_static 相比还是不太友好。 nginx静态压缩配置gzip_static在前端代码打包构建bundle的时候，一般都有根据一定的算法自动压缩代码成gz文件的webpack插件。 当我们不在 nginx 开启 gzip_static的时候，发现生产的gz文件并没有被运行。 gzip_static是会自动执行gz文件的，这样的就避免了通过gzip自动压缩。 123http &#123; gzip_static on;&#125; 如何判断gzip_static是否生效在请求的response headers里面的Etag里面，没有W/就表明使用的是我们自己的 .gz 文件。 Vue项目打包.gz文件1. 安装插件1npm install compression-webpack-plugin -D 2. 在vue.config.js中配置123456789101112131415const CompressionPlugin = require('compression-webpack-plugin')module.exports = &#123; ... configureWebpack: &#123; plugins: [ new CompressionPlugin(&#123; test: /\\.js$|\\.html$|\\.css/, threshold: 10240, deleteOriginalAssets: false, algorithm: 'gzip' &#125;) ] &#125;&#125; 动态压缩和静态压缩结合使用123456789101112http &#123; gzip_static on; gzip_proxied expired no-cache no-store private auth; gzip on; gzip_min_length 1k; gzip_buffers 4 8k; gzip_http_version 1.0; gzip_comp_level 8; gzip_types application/javascript text/css image/gif; gzip_vary on; gzip_disable \"MSIE [1-6]\\.\";&#125; 首先尝试使用静态压缩，如果有则返回 .gz 的预压缩文件，否则尝试动态压缩。 总结vue重新打包部署后，nginx配置后重新加载，再打开页面速度是不是快了很多。","categories":[{"name":"解决方案","slug":"解决方案","permalink":"http://www.chenhanpeng.com/categories/解决方案/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.chenhanpeng.com/tags/vue/"},{"name":"解决方案","slug":"解决方案","permalink":"http://www.chenhanpeng.com/tags/解决方案/"},{"name":"gzip压缩","slug":"gzip压缩","permalink":"http://www.chenhanpeng.com/tags/gzip压缩/"}]},{"title":"面试经常提到的重排和重绘，你真的了解吗？","slug":"fe/重排和重绘","date":"2021-05-17T15:46:03.000Z","updated":"2021-05-18T00:42:17.866Z","comments":true,"path":"reflow-and-repaint/","link":"","permalink":"http://www.chenhanpeng.com/reflow-and-repaint/","excerpt":"","text":"上一篇文章 「浏览器渲染流程」你知道HTML、CSS、JS文件在浏览器中是如何转化成页面的吗？ 学习了浏览器的页面渲染流程，在文章的最后我们提到了两个和渲染流程有关的概念：重排和重绘。理解这两个概念对我们做Web性能优化会有很大的帮助。 重排(reflow)概念当更新了元素的几何属性，那么浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排，也称为“回流”。 例如我们通过JS或CSS修改了元素的宽度和高度，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。 渲染树的节点发生改变，影响了该节点的几何属性，导致该节点位置发生变化，此时就会触发浏览器重排并重新生成渲染树。重排意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。 重排需要更新完整的渲染流水线，所以开销也是最大的。 常见的引起重排属性和方法任何会改变元素的位置和尺寸大小的操作，都会触发重排。常见的例子如下： 添加或删除可见的DOM元素 元素尺寸改变 内容变化，比如在input框中输入文字 浏览器窗口尺寸改变 计算offsetTop、offsetLeft等布局信息 设置style属性的值 激活CSS伪类，例如 :hover 查询某些属性或调用某些方法 几何属性几何属性：包括布局、尺寸等可用数学几何衡量的属性。 布局：display、float、position、list、table、flex、columns、grid 尺寸：margin、padding、border、width、height 获取布局信息的属性或方法获取布局信息的属性如下： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect() 看到这里有的人可能会疑惑，我们只是获取这些属性值，并没有改变它，为什么会触发重排？ 现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制清空队列，因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。 所以我们应避免频繁使用上述的属性。 重排的影响范围浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围的DOM重新排列，影响的范围分两种： 全局范围从根节点html开始对整个渲染树重新布局。 123456789&lt;body&gt; &lt;div class=\"hello\"&gt; &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt; &lt;h5&gt;male&lt;/h5&gt; &lt;ol&gt; &lt;li&gt;loving&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt; 上面代码中的p节点发生重排时，它的父节点div和body也会发生重排，甚至h5和ol节点也会受到影响。 局部范围对渲染树的某部分或某一渲染对象进行重新布局。 例如：讲一个DOM元素的宽高等几何信息写死，然后在DOM元素内部触发重排，就只会重新渲染该DOM元素内部的元素，而不会影响到外界。 重绘(repaint)概念更新了元素的绘制属性，但没有改变布局，重新把元素外观绘制出来的过程叫做重绘。例如更改某些元素的背景颜色。 重绘并没有引起元素几何属性的改变，所以就直接进入绘制阶段，然后执行之后的一系列子阶段。 和重排相比，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。 重排一定会伴随重绘，重绘却不一定伴随重排。 外观属性包括界面、文字等可用状态向量描述的属性 界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip、border-radius、background-size、visibility 文字：text、font、word 性能优化重排和重绘在操作节点样式时频繁出现，同时也存在很大程度上的性能问题。重排成本比重绘成本高得多，因为一个节点的重排可能导致子节点、兄弟节点或祖先节点的重排，所以我们要尽可能减少重排次数、重排范围。 使用visibility:hidden替换display:none通过下面四个方面来看看两者有什么区别： 占位表现 display:none：不占据空间 visibility:hidden：占据空间 触发影响 display:none：触发重排重绘 visibility:hidden：触发重绘 过渡影响 display:none：影响过渡不影响动画 visibility:hidden：过渡和动画都不影响 株连效果 display:none：自身及其子节点全都不可见 visibility:hidden：自身及其子节点都不可见，但可声明子节点visibility:visible单独显示 避免使用Table布局Table布局可能很小的一个改动就会造成整个table重排。 通常可用 ul、li、span等标签取代 table 系列标签生成表格 避免设置多层内联样式浏览器的CSS解析器解析css文件时，对CSS规则是从右到左匹配查找，样式层级过多会影响重排重绘效率。 123456789101112131415&lt;style&gt; span &#123; color: red; &#125; div &gt; a &gt; span &#123; color: red; &#125;&lt;/style&gt;&lt;div&gt; &lt;a href=\"https://www.baidu.com\"&gt; &lt;span&gt;百度搜索&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。 将频繁重绘或重排的节点设置为图层上一篇文章中我们构建完布局树之后，我们会进行分层，将页面分为很多个图层，如果不对图层添加关联，图层之间是不会相互影响的。 因此，在浏览器中将频繁重排或重绘的节点设置为一张新图层，那么新图层就能够阻止节点的渲染行为影响别的节点。 设置新图层的方法： 将节点设置为video或iframe 为节点添加 will-change 属性 使用requestAnimationFrame作为动画帧动画速度越快，重排次数越多，浏览器刷新频率为60Hz，即每16.6ms更新一次，而requestAnimationFrame()正是以16.6ms的速度更新一次。所以可用requestAnimationFrame()代替setInterval()。 对于复杂动画效果,使用绝对定位让其脱离文档流对于复杂动画效果，由于会经常的引起重排重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的重排。 动态改变类而不改变样式不要尝试每次操作DOM去改变节点样式，这样会频繁触发重排。 更好的方式是使用新的类名预定义节点样式，在执行逻辑操作时收集并确认最终更换的类名集合，在适合时机一次性动态替换原来的类名集合。 具体的实现可以看下HTML DOM元素属性 classList。 避免触发同步布局事件先来看下面的代码：1234for (let i = 0; i &lt;100; i++) &#123; const top = document.getElementById('list').style.top; console.log(top)&#125; 上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。 上面代码中每次循环操作DOM都会发生重排，应该在循环外使用变量保存一些不会变化的DOM映射值。1234const top = document.getElementById('list').style.top;for (let i = 0; i &lt;100; i++) &#123; console.log(top)&#125; 批量修改DOM当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少重排重绘次数： 使元素脱离文档流 对其进行多次修改 将元素带回到文档中。 该过程的第一步和第三步可能会引起重排，但是经过第一步之后，对DOM的所有修改都不会引起重排，因为它已经不在渲染树了。 有三种方式可以让DOM脱离文档流： 隐藏要操作的dom在要操作dom之前，通过display隐藏dom，当操作完成之后，再将dom的display属性置为可见，因为不可见的元素不会触发重排和重绘。 通过使用DocumentFragment创建一个dom碎片，在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排。 复制节点，在副本上工作，然后替换它。 当然我们也可以使用框架来实现批量修改DOM，比如Vue、React。 CSS3硬件加速（GPU加速）使用CSS3硬件加速，可以让 transform、opacity、filters这些动画不会引起重拍重绘，但对于动画的其它属性，比如background-color这些，还是会引起重排重绘的，不过它还是可以提升这些动画的性能。 常见的触发CSS3硬件加速的CSS属性有： transform opacity filters will-change 启动硬件加速注意点： 如果为太多元素使用CSS3硬件加速，会导致内存占用较大，也会从另一方面导致性能问题 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。 我们通过下面这个例子来看验证一下CSS3硬件加速这个优化方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;body&gt; &lt;style&gt; #container &#123; width: 300px; height: 300px; position: absolute; border: 1px solid burlywood; &#125; .rect &#123; width: 100px; height: 100px; left: 0; top: 0; background-color: gray; &#125; .animate .rect &#123; animation: run-around 4s ease-in-out infinite; &#125; @keyframes run-around &#123; 0% &#123; transform: translate3d(0, 0, 0); &#125; 25% &#123; transform: translate3d(200px, 0, 0); &#125; 50% &#123; transform: translate3d(200px, 200px, 0); &#125; 75% &#123; transform: translate3d(0, 200px, 0); &#125; &#125; &lt;/style&gt; &lt;script&gt; function start() &#123; const el = document.getElementById(\"container\") el.classList.contains('animate') ? el.classList.remove('animate') : el.classList.add('animate') &#125; &lt;/script&gt; &lt;button onclick=\"start()\"&gt;开启/停止动画&lt;/button&gt; &lt;div id=\"container\"&gt; &lt;div class=\"rect\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 通过Chrome浏览器的Performance捕获了一段时间的重排重绘情况，结果如下： 当动画进行的时候，没有发生任何的重排或重绘。 总结通过上面的学习，我们可以总结出以下几点： 重排是因为元素的几何属性更改触发的 重绘是由于元素的绘制属性更改触发的 触发重排也一定会触发重绘，触发重绘不一定会触发重排 重排的成本高于重绘 减少重排次数、重排范围是Web性能优化的基本思路 文章到这里正文内容就结束了，你是否已经清楚什么是重排和重绘？为什么减少重排重绘能够优化Web性能？欢迎留言讨论。 如果你觉得这篇内容对你有帮助的话： 点赞支持下吧，让更多的人也能看到这篇内容 关注公众号：前端极客技术，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"浏览器","slug":"前端/浏览器","permalink":"http://www.chenhanpeng.com/categories/前端/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://www.chenhanpeng.com/tags/浏览器/"},{"name":"重排和重绘","slug":"重排和重绘","permalink":"http://www.chenhanpeng.com/tags/重排和重绘/"}]},{"title":"前端必读书籍推荐和海量前端学习资源分享","slug":"other/前端必读书籍推荐和学习资源分享","date":"2021-05-16T07:00:08.000Z","updated":"2021-05-18T01:15:04.062Z","comments":true,"path":"fe-books-recommendation-and-share/","link":"","permalink":"http://www.chenhanpeng.com/fe-books-recommendation-and-share/","excerpt":"","text":"HTML和CSS书籍推荐《Head First HTML与CSS(第2版)》豆瓣评分 9.2。是前端入门的经典书籍，手把手教学，内容幽默有趣，丰富的案例让你从 0 开始学前端。前端初学者首选书籍，工作多年的前端也可以阅读。 《精通CSS：高级Web标准解决方案(第3版)》豆瓣评分 7.6。前端大神Winter在最近公开推荐过这本书，将它和《JavaScript高级程序设计（第4版）》列为前端必读。书中介绍了涉及字体、网页布局、响应式Web设计、表单、动画等方面的实用技巧，并讨论了如何实现稳健、灵活、无障碍访问的Web设计，以及在技术层面如何实现跨浏览器方案和后备方案。 《CSS权威指南(第三版)》豆瓣评分 8.5。这本书也是非常的经典了，2007 年的书了，但是无不影响这本书作为 CSS 的经典著作，把原理讲得非常的通透，除了 w3c 标准，算最权威的一本了，毕竟权威指南，可以当做开发工具书来查阅。 《CSS揭秘》豆瓣评分9.4。神书，47 个 css 技巧让你在面对各种 css 问题的时候游刃有余。豆瓣评分 9.4 ，是 css 书籍中评分最高的了，css 进阶必备。 以上PDF版电子书下载： 关注公众号：【前端极客技术】，发送【学习资源】，即可获取网盘下载链接。 JavaScript书籍推荐《JavaScript高级程序设计(第4版)》豆瓣评分 9.2。俗称红宝书，是JavaScript入门书籍最佳选择之一。Zakas大神把概念深入浅出，将JavaScript的语法要点讲清楚明白。作为一名前端开发，这本书至少要通读一遍。而且看完这本，后续看其它进阶书籍会比较好。 《JavaScript权威指南》豆瓣评分 8.8。犀牛书是每个FE都绕不过的一本书，可以先大致通读几遍，也可以把其当作工具书，时时翻阅。 《你不知道的JavaScript》豆瓣评分 9.3。堪称JavaScript的神书，分为上中下三册。书中的闭包、异步这些内容讲得很通透，读完有一种醍醐灌顶的感觉，值得花时间好好看一遍。 《ES6 标准入门（第3版）》还有阮一峰老师的开源书籍《ES6标准入门》也是值得推荐的。是一本开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。虽然是开源书籍，但是有条件的可以购买实体书，支持一下阮一峰老师。 开源书籍地址：https://es6.ruanyifeng.com/ 《JavaScript DOM高级程序设计》通过学习本书，可以理解一个JS的库如何产生，自己动手写一个简单的自己的JS库，如果你打算研究其他的JS库或者正在研究其他的JS库，那么这本书会使你的理解达到新的高度，进阶高级必读，写库必读。 《JavaScript DOM编程艺术(第2版)》豆瓣评分 8.7。本 书在简洁明快地讲述JavaScript和DOM的基本知识之后，通过几个实例演示了专业水准的网页开发技术，透彻阐述了平稳退化等一批至关重要的 JavaScript编程原则和最佳实践。 《javascript设计模式与开发实践》前端设计模式类的书本来就很少，这本是腾讯前端AlloyTeam团队出品，综合讲述前端的设计模式，设计原则，编程技巧，代码重构等等。AlloyTeam有自己的资源站，感兴趣的读者可以自行搜索，资源还有博客非常多，质量也很高。 以上PDF版电子书下载： 关注公众号：【前端极客技术】，发送【学习资源】，即可获取网盘下载链接。 其他书籍推荐 《深入 React 技术栈》 《React 进阶之路》 《Web性能权威指南》 《深入浅出Node.js》 视频教程推荐极客时间付费课程 重学前端 浏览器工作原理与实践 JavaScript核心原理解析 Node.js开发实战 React实战进阶45讲 算法训练营 其他视频教程 黄轶老师的《Vue.js源码全方位深入解析》 React源码深度解析 前端面试之道 PDF电子书和视频教程资源下载 上面电子书和视频教程获取方式： 关注公众号：【前端极客技术】，发送【学习资源】，即可获取网盘下载链接。","categories":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://www.chenhanpeng.com/categories/技术杂谈/"}],"tags":[{"name":"书籍推荐","slug":"书籍推荐","permalink":"http://www.chenhanpeng.com/tags/书籍推荐/"},{"name":"资源分享","slug":"资源分享","permalink":"http://www.chenhanpeng.com/tags/资源分享/"}]},{"title":"「浏览器渲染流程」你知道HTML、CSS、JS文件在浏览器中是如何转化成页面的吗？","slug":"fe/浏览器渲染过程","date":"2021-05-12T23:55:41.000Z","updated":"2021-05-14T02:06:56.827Z","comments":true,"path":"how-to-render-page-on-the-browser/","link":"","permalink":"http://www.chenhanpeng.com/how-to-render-page-on-the-browser/","excerpt":"","text":"在前面一篇文章：「高频面试题」浏览器从输入url到页面展示中间发生了什么 中，我们有对浏览器的渲染流程做了一个概括性的介绍，今天这篇文章我们将深入学习这部分内容。 对于很多前端开发来说，平常做工主要专注于业务开发，对浏览器的渲染阶段可能不是很了解。实际上这个阶段很重要，了解浏览器的渲染过程，能让我们知道我们写的HTML、CSS、JS代码是如何被解析，并最终渲染成一个页面的，在页面性能优化的时候有相应的解决思路。 我们先来看一个问题： HTML、CSS、JS文件在浏览器中是如何转化成页面的？ 如果你回答不上来，那就往下看吧。 按照渲染的时间顺序，渲染过程可以分为下面几个子阶段：构建DOM树、样式计算、布局阶段、分层、栅格化和合成显示。 下面详细看下每个子阶段都做了哪些事情。 1. 构建DOM树HTML文档描述一个页面的结构，但是浏览器无法直接理解和使用HTML，所以需要通过HTML解析器将HTML转换成浏览器能够理解的结构——DOM树。 HTML文档中所有内容皆为节点，各节点之间有层级关系，彼此相连，构成DOM树。 构建过程：读取HTML文档的字节(Bytes)，将字节转换成字符(Chars)，依据字符确定标签(Tokens)，将标签转换成节点(Nodes)，以节点为基准构建DOM树。参考下图： 打开Chrome的开发者工具，在控制台输入 document 后回车，就能看到一个完整的DOM树结构，如下图所示： 在控制台打印出来的DOM结构和HTML内容几乎一样，但和HTML不同的是，DOM是保存在内存中的树状结构，可以通过JavaScript来查询或修改其内容。 2. 样式计算样式计算这个阶段，是为了计算出DOM节点中每个元素的表现样式。 2.1 解析CSSCSS样式可以通过下面三种方式引入： 通过link引用外部的CSS文件 style 标签内的CSS 元素的style属性内嵌的CSS 和HTML一样，浏览器无法直接理解纯文本的CSS样式，需要通过CSS解析器将CSS解析成 styleSheets 结构，也就是我们常说的 CSSOM树。 styleSheets结构同样具备查询和修改功能：1document.styleSheets 2.2 属性值标准化属性值标准化看字面意思有点不好理解，我们通过下面一个例子来看看什么是属性值标准化： 在写CSS样式的时候，我们在设置color属性值的时候，经常会用white、red等，但是这种值浏览器的渲染引擎不容易理解，所以需要将所有值转换成渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。 white标准化后的值为 rgb(255, 255, 255) 2.3 计算DOM树中每个节点的样式完成样式的属性值标准化后，就需要计算每个节点的样式属性，这个阶段CSS有两个规则我们需要清楚： 继承规则：每个DOM节点都包含有父节点的样式 层叠规则：层叠是CSS的一个基本特征，是一个定义了如何合并来自多个源的属性值的算法。 样式计算阶段是为了计算出DOM节点中每个元素的具体样式，在计算过程中需要遵守CSS的继承和层叠两个规则。 该阶段最终输出的内容是每个DOM节点的样式，并被保存在 ComputedStyle 的结构中。 3. 布局阶段经过上面的两个步骤，我们已经拿到了DOM树和DOM树中元素的样式，接下来需要计算DOM树中可见元素的几何位置，这个计算过程就是布局。 3.1 创建布局树在DOM树中包含了一些不可见的元素，例如 head 标签，设置了 display:none 属性的元素，所以我们需要额外构建一棵只包含可见元素的布局树。 构建过程：从DOM树的根节点开始遍历，将所有可见的节点加到布局树中，忽略不可见的节点。 3.2 布局计算到这里我们就有了一棵构建好的布局树，就可以开始计算布局树节点的坐标位置了。从根节点开始遍历，结合上面计算得到的样式，确定每个节点对象在页面上的具体大小和位置，将这些信息保存在布局树中。 布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。 4. 分层现在我们已经有了布局树，也知道了每个元素的具体位置信息，但是还不能开始绘制页面，因为页面中会有像3D变换、页面滚动、或者用 z-index 进行z轴排序等复杂效果，为了更方便实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树(LayerTree)。 在Chrome浏览器中，我们可以打开开发者工具，选择 Elements-Layers 标签，就可以看到页面的分层情况，如下图所示： 浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。 到这里，我们构建了两棵树：布局树和图层树。下面我们来看下这两颗树之间的关系： 正常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。 那节点要满足什么条件才会被提升为一个单独的图层？只要满足下面其中一个条件即可： 拥有层叠上下文属性的元素会被提升为单独的一个图层 需要剪裁(clip)的地方也会被创建为图层。 5. 图层绘制构建好图层树之后，渲染引擎就会对图层树中的每个图层进行绘制。 渲染引擎实现图层绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后将这些指令按照顺序组成一个待绘制列表。 6. 栅格化(raster)操作绘制一个图层时会生成一个绘制列表，这只是用来记录绘制顺序和绘制指令的列表，实际上绘制操作是由渲染引擎中的合成线程来完成的。 通过下图来看下渲染主线程和合成线程之间的关系： 当图层的绘制列表准备好后，主线程会把该绘制列表提交给合成线程，合成线程开始工作。 首先合成线程会将图层划分为图块(tile)，图块大小通常是 256256 或者 512512。 然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示： 7. 合成和显示一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。 8. 总结一个完整的渲染流程可以总结如下： 1、渲染进程将HTML内容转换为浏览器能够读懂的DOM树结构。 2、渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。 3、创建布局树，并计算元素的布局信息。 4、对布局树进行分层，并生成分层树。 5、为每个图层生成绘制列表，并将其提交到合成线程。 6、合成线程将图层分图块，并栅格化将图块转换成位图。 7、合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。 渲染过程中还有两个我们经常听到的概念：重排和重绘。在这篇文章中就不细说，下一篇文章再详细介绍。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"浏览器","slug":"前端/浏览器","permalink":"http://www.chenhanpeng.com/categories/前端/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://www.chenhanpeng.com/tags/浏览器/"},{"name":"渲染流程","slug":"渲染流程","permalink":"http://www.chenhanpeng.com/tags/渲染流程/"}]},{"title":"在cloudflare上创建一个免费的在线代理来解决gitalk授权登录报403问题","slug":"other/创建一个免费的在线代理来解决gitalk授权登录报403问题","date":"2021-04-21T03:30:11.000Z","updated":"2021-05-14T02:06:56.838Z","comments":true,"path":"create-own-cors-anywhere-to-resolve-the-request-with-403/","link":"","permalink":"http://www.chenhanpeng.com/create-own-cors-anywhere-to-resolve-the-request-with-403/","excerpt":"","text":"2021.04.28 更新针对403的问题，gitalk开发团队已经对其做了修复，解决方法如下： 更新版本到 1.7.2 或者修改配置增加 proxy: ‘https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token&#39; 当然我们也可以自己动手搭建代理，如果有兴趣的话可以直接下拉看下面的 利用cloudflare worker搭建在线代理 问题说明前两天突然发现个人博客的gitalk评论功能出了问题，点击使用Github登录一直失败，打开控制台一查，发现下面这个请求报403。 https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token cors-anywhere是一个用来解决跨域问题而生的反向代理，是一个开源框架。 PSA: Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st #301 从Github上这个issue上我们可以知道，gitalk中用到的 cors-anywhere.herokuapp.com 这个网站原本是用来演示用的，从2021.1.31开始不再作为开放的代理服务，作者建议开发者自己维护一个代理网站。 初步解决方案（不稳定不建议使用）在gitalk的issue中看到别人分享的一个在线代理，先拿来用下： https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token 我们现在配置文件_config.yml的gitalk配置项中加一个proxy：123456789101112gitalk: enable: true clientID: clientSecret: accessToken: repo: blog-comments owner: Hanpeng-Chen admin: ['Hanpeng-Chen'] perPage: 10 distractionFreeMode: true language: zh-CN proxy: https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token 在gitalk.ejs中加上proxy配置：123456789101112var gitalk = new Gitalk(&#123; // Gitalk配置 language: \"&lt;%= config.language%&gt;\", clientID: \"&lt;%= theme.gitalk.clientID%&gt;\", clientSecret: \"&lt;%= theme.gitalk.clientSecret%&gt;\", repo: \"&lt;%= theme.gitalk.repo%&gt;\", owner: \"&lt;%= theme.gitalk.owner%&gt;\", admin: [\"&lt;%= theme.gitalk.admin%&gt;\"], id: md5(location.pathname), distractionFreeMode: &lt;%= theme.gitalk.distractionFreeMode%&gt;, proxy: \"&lt;%= theme.gitalk.proxy %&gt;\"&#125;); 重新部署后，点击Github登录，这次没有没有报403的问题，但是出现了下面“Error：Network Error”。 查看了对应请求的应答码 429，表示请求太多，我个人估计是白嫖这个在线代理的人太多导致的。 既然白嫖的代理不能用，那我们就自己搭一个在线代理吧。 利用cloudflare worker搭建在线代理利用CloudFlare Worker创建在线代理，不需要我们有服务器，也不需要搭建Node.js服务，只需要注册一个CloudFlare账号，创建一个Worker，部署一个JS脚本就可以了，简单方便，下面我们就来看看如何创建吧。 首先你需要一个 CloudFlare 的账号，如果还没有的话就先注册一个吧：点我注册 选择Workers，创建一个免费的Worker。 免费版本每天10万次请求也足以应对个人使用或者是小范围分享了。 填写自己喜欢的二级域名，然后创建worker。 进入github项目的 index.js，复制代码。 清除脚本编辑器中的示例代码，将复制的代码粘贴进去。 这里有个点需要注意：我们可以设置请求的黑白名单，这里的白名单我只设置了自己博客域名，大家可以根据自己的情况修改，当然也可以设置为whitelist = [ &quot;.*&quot; ]，这样的话知道你代理地址的人都可以用了，然而免费版本的每天只有10万次请求，如果用的人多了很容易就用完了，所以还是建议大家设置 whitelist。 123blacklist = [ ]; // regexp for blacklisted urls// whitelist = [ \".*\" ]; // regexp for whitelisted originswhitelist = [ \"^http.?://www.chenhanpeng.com$\", \"chenhanpeng.com$\" ] 修改好之后，点击 保存并部署，如果部署正常的话，我们就可以使用我们创建的在线代理了。 从右侧获取到你的worker域名并记下来，在上面提到的proxy配置项修改为如下代码： 1proxy: https://cloudflare-cors-anywhere.hanpengchen.workers.dev/?https://github.com/login/oauth/access_token 重新部署我们的博客，再次点击 使用Github登录，这次登录成功，没有报错，至此，个人在线代理就搭建成功了，博客的评论功能也能正常使用了，撒花！！！ 在线代理的原理了解传统在线代理都是在服务端替换 HTML/JS/CSS 等资源中的 URL。这不仅需要对内容做大量的分析和处理，还需对流量进行解压和再压缩，消耗大量 CPU 资源。并且由于逻辑较复杂，通常使用 Python/PHP 等编程语言自己实现。 为降低服务端开销，本项目使用浏览器的一个黑科技 —— Service Worker。它能让 JS 拦截网页产生的请求，并能自定义返回内容，相当于在浏览器内部实现一个反向代理。这使得绝大部分的内容处理都可以在浏览器上完成，服务器只需纯粹的转发流量。 要是还有其它问题的话，欢迎留言讨论。 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术，我们一起学习一起进步。","categories":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://www.chenhanpeng.com/categories/技术杂谈/"}],"tags":[{"name":"gitalk","slug":"gitalk","permalink":"http://www.chenhanpeng.com/tags/gitalk/"},{"name":"在线代理","slug":"在线代理","permalink":"http://www.chenhanpeng.com/tags/在线代理/"}]},{"title":"JS中的apply、call、bind你掌握了吗？一起来手写实现这三个方法吧","slug":"javascript/this-apply-call-bind","date":"2021-04-20T23:35:39.000Z","updated":"2021-04-21T01:17:31.279Z","comments":true,"path":"handwriting-apply-call-bind/","link":"","permalink":"http://www.chenhanpeng.com/handwriting-apply-call-bind/","excerpt":"","text":"作者：Hanpeng_Chen 公众号：前端极客技术 apply、call和bind这三个方法在函数原型链中是比较重要的概念，和this关键字密切相关。如果你对这三个方法还不是很清楚的话，那么认真地阅读这篇文章吧，让我们一起来彻底掌握它们吧！ 在开始介绍apply/call/bind 这三个方法之前，我们需要先来了解一下JS中的this指向问题。 this指向在ES5中，我们只要牢记一句话：this永远指向最后调用它的那个对象，那么对于this的指向问题就比较好理解了。 直接函数调用我们先来看一个例子：12345678var name = 'global name';function getName() &#123; var name = 'function name'; console.log('in function', this); console.log(this.name);&#125;getName();console.log('out function', this) 在浏览器控制台执行结果如下图所示： 我们可以看到在全局环境中直接调用函数getName()相当于window.getName()，调用它的是全局对象window，所以this对象指向全局对象，也就是window对象。 对象函数调用我们再看下面这个例子：123456789var name = 'global name';var obj = &#123; name: 'object name', getName: function() &#123; console.log(this); // &#123;name: \"object name\", getName: ƒ&#125; console.log(this.name); // object name &#125;&#125;obj.getName(); 在上面这个例子中，函数 getName 时对象 obj 调用的，所以在 getName 函数中打印的 this 是 obj 对象本身，this.name 是 object name。 我们将上面的代码进行如下改造：12345678910var name = \"global name\";function getName() &#123; console.log(this.name);&#125;var obj = &#123; name: \"object name\"&#125;;obj.getName = getName;obj.getName(); // object namegetName(); // global name 在上面代码中，我们将 getName 函数的指针赋值给 obj.getName，obj.getName() 是对象函数调用方法，this指向obj本身，所以打印的this.name是 object name。 而全局环境调用getName()，等同于 window.getName()，打印的也就是 global name。 从上面两个示例我们可以总结出：对象函数调用，this指针指向调用函数的对象本身。 构造函数调用接下来我们来看下构造函数里面this指针的指向问题，还是先看下面的示例代码：12345function NewObject(name) &#123; this.name = name; console.log(this.name)&#125;var obj = new NewObject('obj') 从上面例子我们可以看出：构造函数中的this指向新创建的对象本身，所以上面例子打印出来的name为 obj。 小结 直接函数调用，this指针指向全局环境； 对象函数调用，this指针指向调用函数的对象本身； 构造函数调用，this指针指向新创建的对象本身。 改变this的指向的几种方法改变this的指向的方法主要有以下几种： 使用ES6中的箭头函数 在函数内部使用 _this = this 使用apply、call、bind new实例化一个对象 箭头函数箭头函数中的this只取决于它外面的第一个不是箭头函数的函数的this，并且箭头函数的this一旦绑定了上下文，就不会被任何代码改变。123456789function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this.a); &#125;; &#125;;&#125;var a = 2;console.log(foo()()()); // 2 在函数内部使用 _this = this先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。 1234567891011121314var name = 'global name'var obj = &#123; name: 'obj name', fn1: function () &#123; console.log(this.name); &#125;, fn2: function () &#123; var _this = this setTimeout(function() &#123; _this.fn1() &#125;, 1000) &#125;&#125;obj.fn2() // obj name 在上面的例子中，如果fn2函数不通过_this变量保存上下文，而是在setTimeout延时函数中直接使用this的话，这时的this指向的是window，但是window对象上并没有定义fn1函数，程序就会报错。 new实例化一个对象这个我们在上面构造函数调用中已经介绍过了，new实例化一个对象，this指针指向新创建的对象本身。 接下来我们一起来看看apply、call、bind的使用及其原理。 apply、call、bind 基本介绍基本语法：123fn.apply(thisArg, [p1, p2, ...])fn.call(thisArg, p1, p2, ...)fn.bind(thisArg, p1, p2, ...) 这三个方法是挂在Function对象上的，调用这三个方法的必须是一个函数。 这三个方法的共有作用：改变函数fn的this指向。 call和apply的区别在于:传参的写法不同，apply的第2个参数是数组，call则是从第2个至第n个都是给fn的传参。 bind和上面两个方法又有所不同，bind虽然改变了fn的this指向，但不是马上执行，而apply和call是在改变了this指向后立即执行。 apply/call/bind的核心理念：借用方法我们先来看下面apply、call、bind这三个方法的简单示例：12345678910111213141516171819let dog = &#123; name: 'dog', getDetail: function (count) &#123; return `$&#123;this.name&#125; has $&#123;count&#125; legs` &#125;&#125;let bird = &#123; name: 'bird'&#125;let frog = &#123; name: 'frog'&#125;console.log(dog.getDetail(4)); // dog has 4 legsconsole.log(dog.getDetail.apply(bird, [2])); // bird has 2 legsconsole.log(dog.getDetail.call(frog, 3)); // frog has 3 legslet bird1 = dog.getDetail.bind(bird);console.log(bird1(2)); // bird has 2 legs 在上面代码中，dog对象有一个 getDetail 的方法，对象bird和frog也需要临时使用同样的方法，那么这时候我们可以借用dog对象的getDetail方法，这样既能达到目的，也能节省重复定义，节约内存空间。 这就是这三个方法的核心理念：借用方法。 手写实现apply、call和bind在大厂面试中，手写实现一个apply/call/bind是一道高频面试题，接下来我们一起来实现这三个方法： apply的实现根据上面apply的原理和其借用方法的理念，我们来整理一下实现 apply 方法的思路： 通过设置context的属性，将函数的this指向隐式绑定到 context上； 通过隐式绑定执行函数并传递参数； 删除临时属性，返回函数执行结果。 具体实现代码如下： 123456789101112Function.prototype.apply = function(context, args) &#123; if (context === null || context === undefined) &#123; context = window &#125; else &#123; context = Object(context) // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象 &#125; context.fn = this; let result = eval('context.fn(...args)'); // 删除添加的函数 delete context.fn; return result;&#125; 从上面的代码可以看出，实现apply的关键在于 eval 这行代码。其中显示了用context这个临时变量来指定上下文，然后还是通过执行 eval 来执行 context.fn 这个函数，最后返回result。 如果不使用eval，我们还有下面的实现方式：123456789101112131415Function.prototype.apply = function (context, args) &#123; if (context === null || context === undefined) &#123; context = window; &#125; else &#123; context = Object(context); // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象 &#125; // 给context新增一个独一无二的属性以免覆盖原来属性 let fn = Symbol(); context[fn] = this; // 通过隐式绑定的方式调用函数 let result = context[fn](...args); // 删除添加的函数 delete context[fn]; return result;&#125;; 使用Symbol临时存储函数，避免了跟上下文对象的原属性冲突的风险。 call的实现call和apply基本原理差不多，只是参数存在区别，这里我们不再细说，直接看call方法的实现代码： 1234567891011Function.prototype.call = function(context, ...args) &#123; if (context === null || context === undefined) &#123; context = window &#125; else &#123; context = Object(context) &#125; context.fn = this; let result = eval('context.fn(...args)'); delete context.fn; return result;&#125; bind的实现bind方法和其它两个方法的区别在于：bind方法是返回一个函数，而其它两个方法是直接返回执行结果。 实现思路和call基本相同，因为bind不需要返回执行结果，所以不需要用eval，而是需要通过返回一个函数的方式将结果返回，之后再执行这个结果，得到想要的结果。 具体实现思路如下： 拷贝源函数： 通过变量存储源函数 使用 Object.create 复制源函数的prototype给fbound 返回拷贝的函数 调用拷贝的函数 new调用判断：通过 instanceof 判断函数是否通过 new 调用，来决定绑定的 context 绑定 this，传递参数 返回源函数的执行结果 1234567891011121314Function.prototype.bind = function (context, ...args) &#123; if (typeof this !== 'function') &#123; throw new Error('this must be a function') &#125; var self = this; var fbound = function() &#123; return self.call(this instanceof fbound ? this : Object(context), ...args, ...arguments); // return self.call(this instanceof fbound ? this : Object(context), args.concat(Array.prototype.slice.call(arguments))) &#125; if (this.prototype) &#123; fbound.prototype = Object.create(this.prototype); &#125; return fbound;&#125; 从上面的代码中可以看到，实现 bind 的核心在于返回的时候需要返回一个函数，故这里的 fbound 需要返回，但是在返回的过程中原型链对象上的属性不能丢失。因此这里需要用Object.create 方法，将 this.prototype 上面的属性挂到 fbound 的原型上面，最后再返回 fbound。这样调用 bind 方法接收到函数的对象，再通过执行接收的函数，即可得到想要的结果。 看到这里，apply、call、bind这三个方法的实现你是否已经完全掌握了？如果没有的话那就自己动手多写几次吧！ 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"},{"name":"原理源码","slug":"前端/原理源码","permalink":"http://www.chenhanpeng.com/categories/前端/原理源码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"},{"name":"手写源码","slug":"手写源码","permalink":"http://www.chenhanpeng.com/tags/手写源码/"}]},{"title":"一起搞清楚JS中的new到底做了什么，并模拟实现一个new","slug":"javascript/JS中的new","date":"2021-04-13T15:00:06.000Z","updated":"2021-04-21T01:17:30.347Z","comments":true,"path":"js-new/","link":"","permalink":"http://www.chenhanpeng.com/js-new/","excerpt":"","text":"作者：Hanpeng_Chen 公众号：前端极客技术 new关键字对于前端开发者来说是比较常见的操作，在互联网大厂的面试中，有时候会要求手写实现new。接下来我们一起看看new到底做了什么？如何模拟实现？ new原理介绍new概念关于new关键字，MDN上是这样描述的： new关键字创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 上面这句话也许有些难懂，我们先来看下面这段代码： 12345678910let Parent = function(name, age) &#123; this.name = name; this.age = age;&#125;;Parent.prototype.getName = function()&#123; return this.name;&#125;let child = new Parent('张三', 25);console.log(child.getName());console.log(child.age); 从这个例子中，我们可以看到：实例child可以访问到Parent构造函数里的属性，也可以访问到Parent.prototype中的属性。 从输出结果可以看出：child是一个通过Parent这个构造函数生成的一个实例对象。 那么关于new关键字的作用，我们可以理解为就是执行一个构造函数，返回一个实例对象，在new的过程中，根据构造函数的情况，来确定是否可以接受参数传递。 不使用new关键字会发生什么我们对上面代码进行改造一下，去掉new，会有什么变化？ 12345678let Parent = function(name, age) &#123; this.name = name; this.age = age;&#125;let child1 = Parent('张三', 25)console.log(child1) // undefinedconsole.log(age) // 25console.log(child1.name) // Cannot read property 'name' of undefined 从上面代码我们可以看到，没有使用new关键词，返回的结果是undefined。我们直接打印age可以获取到值，是因为JavaScript代码在默认情况下this的指向是window。 构造函数返回一个对象会发生什么？如果构造函数中有return一个对象的操作，结果会发生什么变化？我们再来看下面这段改造后的代码： 12345678function Parent(name) &#123; this.name = name; return &#123;age: 30&#125;&#125;let p = new Parent('张三')console.log(p); // &#123; age: 30 &#125;console.log(p.name); // undefinedconsole.log(p.age); // 30 从上述代码的执行结果看到：如果构造函数return出来的是一个和this无关的对象时，new命令会直接返回这个新对象，而不是生成一个绑定了最新this的新对象并返回出来。 如果构造函数return回来的不是一个对象，那么还是会按照new的实现步骤，返回新生成的对象。我们通过下面的代码验证一下：1234567function Parent(name) &#123; this.name = name; return 'Chinese'&#125;let p = new Parent('张三')console.log(p); // Parent &#123; name: '张三' &#125;console.log(p.name); // 张三 小结：new到底做了什么？new在这个生成实例过程中到底进行了哪些步骤来实现？我将其总结为下面几个步骤： 创建一个空的简单JavaScript对象，即 {}； 将构造函数的作用域赋给新对象（this指向新对象）； 执行构造函数中的代码（为新对象添加属性）； 如果该函数没有返回对象，则返回this。 new的实现结合上面的内容，我们一起来手写实现new。 在开始写代码之前，我们先确定new被调用后大致做了那几件事： 让实例可以访问到私有属性； 让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性； 构造函数返回的最后结果是引用数据类型。 知道了new被调用后做了哪些事情，那么我们就可以开始手写实现它了。实现代码如下： 12345678910111213141516function _new(ctor, ...args) &#123; if (typeof ctor !== 'function') &#123; throw 'ctor must be a function'; &#125; // 创建新的对象 let newObj = new Object(); // 让新创建的对象可以访问构造函数原型（constructor.prototype）所在原型链上的属性； newObj.__proto__ = Object.create(ctor.prototype); // 将构造函数的作用域赋给新对象（this指向新对象）； // 执行构造函数中的代码 let res = ctor.apply(newObj, [...args]); let isObject = typeof res === 'object' &amp;&amp; res !== null; let isFunction = typeof res === 'function'; return isObject || isFunction ? res : newObj;&#125; 对我们上面模拟实现的new方法进行测试，代码如下：123456789101112131415161718192021222324252627282930let Parent = function(name, age) &#123; this.name = name; this.age = age;&#125;;Parent.prototype.getName = function()&#123; return this.name;&#125;let p = _new(Parent, 'zhangsan', 25);console.log(p); // Parent &#123; name: 'zhangsan', age: 25 &#125;console.log(p.age); // 25 console.log(p.getName()); // zhangsanfunction Parent1(name) &#123; this.name = name; return &#123;age: 30&#125;&#125;let p1 = _new(Parent1, 'lisi')console.log(p1); // &#123; age: 30 &#125;console.log(p1.name); // undefinedconsole.log(p1.age); // 30function Parent2(name) &#123; this.name = name; return 'Chinese'&#125;let p2 = _new(Parent2, 'wangwu')console.log(p2); // Parent &#123; name: 'wangwu' &#125;console.log(p2.name); // wangwu 从测试结果可以看出，我们模拟实现的_new方法和原生的new关键字调用结果是一样的。 到这里手写模拟实现new就结束了，你学会了吗？ 如有发现不妥或可改进之处，欢迎留言指出。 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"},{"name":"原理源码","slug":"前端/原理源码","permalink":"http://www.chenhanpeng.com/categories/前端/原理源码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"}]},{"title":"一起手写实现符合Promise/A+规范的Promise源码","slug":"javascript/手写Promise源码","date":"2021-03-28T02:09:59.000Z","updated":"2021-04-21T01:17:31.489Z","comments":true,"path":"handwriting-promise-accord-with-promise-a-plus-specification/","link":"","permalink":"http://www.chenhanpeng.com/handwriting-promise-accord-with-promise-a-plus-specification/","excerpt":"","text":"作者：Hanpeng_Chen 公众号：前端极客技术 Promise是JavaScript中异步编程的核心内容，也是前端面试的高频问题。关于Promise的基本用法这里不再详细介绍，接下来我们一起来实现一个符合 Promise/A+ 规范的Promise。 在开始写代码之前，我们要知道Promise/A+规范都有哪些内容。 Promise/A+ 规范https://promisesaplus.com/ 上面是Promise/A+规范的官方地址，是一个英文版本，大家可以自行点击阅读。下面我把规范中比较关键的点进行说明： 术语 promise 是一个具有then方法的对象或函数，它的行为符合该规范。 thenable 是一个定义了then方法的对象或函数。 value 可以是任何一个合法的JavaScript的值，包括undefined、thenable、promise。 exception 是一个异常，是在Promise里面可以用throw语句抛出的值。 reason 是一个Promise里reject之后返回的拒绝原因。 状态 一个Promise有三种状态：pending、fulfilled、rejected。 当状态为pending时，可以转换为 fulfilled 或者 rejected。 当状态为 fulfilled 时，就不能再变为其他状态，必须返回一个不能再改变的值。 当状态为 rejected 时，就不能再变为其他状态，必须有一个promise被reject的原因，原因值也不能改变。 then方法Promise必须拥有一个then方法，来访问最终的结果。 then方法有两个参数：1promise.then(onFulfilled, onRejected) onFulfilled 和 onRejectedonFulfilled和onRejected两个都是可选参数，两者都必须是函数类型。 如果onFulfilled是函数，必须在promise变成fulfilled时，调用 onFulfilled，参数是promise的value，onFulfilled只能被调用一次。 如果onRejected是函数，必须在promise变成rejected时，调用 onRejected，参数是promise的reason，onRejected只能被调用一次。 then方法可以被多次调用then方法可以被一个Promise调用多次，且必须返回一个Promise对象。 如果promise变成了 fulfilled态，所有的onFulfilled回调都需要按照then的顺序执行 如果promise变成了 rejected态，所有的onRejected回调都需要按照then的顺序执行 Promise/A+规范的主要部分就是上面这些，接下来我们一起动手实现一个Promise。 实现 Promise构造函数Promise构造函数接受一个 executor 函数，executor函数执行完同步或异步操作后，调用它的两个参数resolve和reject。 12345678910111213141516171819202122232425const PENDING = \"pending\";const FULFILLED = \"fulfilled\";const REJECTED = \"rejected\";function Promise(executor) &#123; let self = this; self.status = PENDING; self.data = undefined; // Promise的值 self.onResolvedCallback = []; // Promise resolve时的回调函数 self.onRejectedCallback = []; // Promise rejected的回调函数集 function resolve(value) &#123; &#125; function reject(reason) &#123; &#125; try &#123; executor(resolve, reject) &#125; catch(e) &#123; reject(e) &#125;&#125; Promise构造函数中定义了resolve和reject两个函数，下面一起来看看这两个函数如何实现？ 从规范中我们知道：resolve和reject函数主要是返回对应状态的值value或者reason，并将Promise内部的状态从pending变成对应的状态，并且在这个状态改变之后是不可逆的。 那么这两个函数要如何实现，可以看下面这段代码： 1234567891011121314151617181920212223function Promise(executor) &#123; ... function resolve(value) &#123; if (self.status === PENDING) &#123; self.status = FULFILLED; self.data = value; for(let i = 0; i &lt; self.onResolvedCallback.length; i++) &#123; self.onResolvedCallback[i](value) &#125; &#125; &#125; function reject(reason) &#123; if (self.status === PENDING) &#123; self.status = REJECTED; self.data = reason; for(let i = 0; i &lt; self.onRejectedCallback.length; i++) &#123; self.onRejectedCallback[i](reason); &#125; &#125; &#125; ...&#125; then方法的实现then方法接收两个参数，分别是Promise成功的回调 onFulfilled 和 失败的回调 onRejected。 如果调用then时，promise已经成功，则执行onFulfilled，并将value值作为参数传递进去； 如果promise已经失败，执行onRejected，将失败的原因reason作为参数传递进去。 如果promise的状态是pending，需要将onFulfilled和onRejected函数存放起来，等待状态确定后，再依次将对应的函数执行(发布订阅) promise 可以then多次，promise 的then 方法返回一个 promise 我们把then方法实现的思路过了一遍，下面来看其实现代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859Promise.prototype.then = function(onFulfilled, onRejected) &#123; let self = this; let promise2; // 根据规范，如果then的参数不是function，则需要忽略它 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; &#123; throw reason &#125;; if (self.status === FULFILLED) &#123; // 如果promise状态确定为fulfilled，调用onFulFilled，但代码执行中可能会抛出，所以将其包裹在try/catch代码块中 return promise2 = new Promise(function(resolve, reject) &#123; try &#123; let x = onFulfilled(self.data) if (x instanceof Promise) &#123; x.then(resolve, reject) &#125; resolve(x) &#125; catch(e) &#123; reject(e) &#125; &#125;) &#125; if (self.status === REJECTED) &#123; return promise2 = new Promise(function(resolve, reject) &#123; try &#123; let x = onRejected(self.data); if (x instanceof Promise) &#123; x.then(resolve, reject) &#125; &#125; catch(e) &#123; reject(e) &#125; &#125;) &#125; if (self.status === PENDING) &#123; return promise2 = new Promise(function(resolve, reject) &#123; self.onResolvedCallback.push(function(value) &#123; try &#123; let x = onFulfilled(self.data); if (x instanceof Promise) &#123; x.then(resolve, reject) &#125; &#125; catch(e) &#123; reject(e) &#125; &#125;) self.onRejectedCallback.push(function(reason) &#123; try &#123; let x = onRejected(self.data) if (x instanceof Promise) &#123; x.then(resolve, reject) &#125; &#125; catch(e) &#123; reject(e) &#125; &#125;) &#125;) &#125;&#125; 到这里一个符合Promise/A+规范的then方法基本实现了。 优化在Promise/A+规范中，onFulfilled和onRejected两个函数需要异步调用。 并且规范中提到，要支持不同的Promise进行交互，关于不同的Promise交互详细说明点击下方链接查看： https://promisesaplus.com/#point-46 基于上面两点，我们对上面实现的then方法中执行Promise的方法进行优化，在处理Promise进行resolve或reject时，加上 setTimeout(fn, 0) 优化后的完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155const PENDING = \"pending\";const FULFILLED = \"fulfilled\";const REJECTED = \"rejected\";function Promise(executor) &#123; let self = this; self.status = PENDING; self.data = undefined; // Promise的值 self.onResolvedCallback = []; // Promise resolve时的回调函数 self.onRejectedCallback = []; // Promise rejected的回调函数集 function resolve(value) &#123; if (value instanceof Promise) &#123; return value.then(resolve, reject); &#125; setTimeout(function () &#123; if (self.status === PENDING) &#123; self.status = FULFILLED; self.data = value; for (let i = 0; i &lt; self.onResolvedCallback.length; i++) &#123; self.onResolvedCallback[i](value); &#125; &#125; &#125;, 0); &#125; function reject(reason) &#123; setTimeout(function () &#123; if (self.status === PENDING) &#123; self.status = REJECTED; self.data = reason; for (let i = 0; i &lt; self.onRejectedCallback.length; i++) &#123; self.onRejectedCallback[i](reason); &#125; &#125; &#125;, 0); &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this; let promise2; // 根据规范，如果then的参数不是function，则需要忽略它 onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : function(v) &#123; return v; &#125;; onRejected = typeof onRejected === \"function\" ? onRejected : function(r) &#123; throw r; &#125;; if (self.status === FULFILLED) &#123; // 如果promise状态确定为fulfilled，调用onFulFilled，但代码执行中可能会抛出，所以将其包裹在try/catch代码块中 return promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function()&#123; try &#123; let x = onFulfilled(self.data); resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e); &#125; &#125;) &#125;); &#125; if (self.status === REJECTED) &#123; return promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function()&#123; try &#123; let x = onRejected(self.data); resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e); &#125; &#125;) &#125;); &#125; if (self.status === PENDING) &#123; return promise2 = new Promise(function (resolve, reject) &#123; self.onResolvedCallback.push(function (value) &#123; try &#123; let x = onFulfilled(self.data); resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e); &#125; &#125;); self.onRejectedCallback.push(function (reason) &#123; try &#123; let x = onRejected(self.data); resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125;&#125;;function resolvePromise(promise2, x, resolve, reject) &#123; let then; let thenCalledOrThrow = false; if (promise2 === x) &#123; return reject(new TypeError('Chaining cycle detected for promise')) &#125; if (x instanceof Promise) &#123; if (x.status === PENDING) &#123; x.then(function(v) &#123; resolvePromise(promise2, v, resolve, reject) &#125;, reject) &#125; else &#123; x.then(resolve, reject) &#125; return &#125; if ((x !== null) &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123; then = x.then; if (typeof then === 'function') &#123; then.call(x, function(y) &#123; if (thenCalledOrThrow) return; // 已经调用过 thenCalledOrThrow = true; return resolvePromise(promise2, y, resolve, reject) &#125;, function(r) &#123; if (thenCalledOrThrow) return; thenCalledOrThrow = true; return reject(r); &#125;) &#125; else &#123; resolve(x) &#125; &#125; catch(e) &#123; if (thenCalledOrThrow) return; thenCalledOrThrow = true; return reject(e); &#125; &#125; else &#123; resolve(x) &#125;&#125;Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected)&#125;module.exports = Promise; 测试有专门的测试脚本可以测试我们写的Promise是否符合Promise/A+规范。 首先在Promise实现的代码中，暴露一个deferred方法：12345678Promise.defer = Promise.deferred = function()&#123; let dfd = &#123;&#125;; dfd.promise = new Promise(function(resolve, reject) &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125; 在Promise源码的目录执行npm安装和执行测试命令：123npm i -g promises-aplus-testspromises-aplus-tests Promise.js promises-aplus-tests中共有872条测试用例。从上面的执行结果可以看出，我们手写的Promise通过所有用例。 Promise其他方法的实现原生的Promise还提供了一些其他方法，比如： Promise.resolve() Promise.reject() Promise.prototype.catch() Promise.prototype.finally() Promise.all() Promise.race() … 在面试中也经常碰到面试官要求手写实现这些方法，接下来我们一起看看这几个方法如何实现： Promise.resolvePromise.resolve(value)方法返回一个给定值解析后的Promise对象。 如果 value 是个 thenable 对象，返回的promise会“跟随”这个thenable的对象，采用它的最终状态 如果传入的value本身就是promise对象，那么Promise.resolve将不做任何修改、原封不动地返回这个promise对象。 其他情况，直接返回以该值为成功状态的promise对象。 1234567891011121314Promise.resolve = function (value) &#123; if (value instanceof Promise) &#123; return value &#125; return new Promise((resolve, reject) =&gt; &#123; if (value &amp;&amp; typeof value === 'object' &amp;&amp; typeof value.then === 'function') &#123; setTimeout(() =&gt; &#123; value.then(resolve, reject) &#125;) &#125; else &#123; resolve(value) &#125; &#125;)&#125; Promise.rejectPromise.reject方法和Promise.resolve不同，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。 12345Promise.reject = function(reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason) &#125;)&#125; Promise.prototype.catchPromise.prototype.catch 用于指定出错时的回调，是特殊的then方法，catch之后，可以继续.then123Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected)&#125; Promise.prototype.finally不管成功还是失败，都会走到finally中,并且finally之后，还可以继续then。并且会将值原封不动的传递给后面的then.1234567891011Promise.prototype.finally = function(cb) &#123; return this.then((value) =&gt; &#123; return Promise.resolve(cb()).then(() =&gt; &#123; return value &#125;) &#125;, (err) =&gt; &#123; return Promise.resolve(cb()).then(() =&gt; &#123; throw err; &#125;) &#125;)&#125; Promise.allPromise.all(promises) 返回一个promise对象 如果传入的参数是一个空的可迭代对象，那么此promise对象回调完成(resolve),只有此情况，是同步执行的，其它都是异步返回的。 如果传入的参数不包含任何 promise，则返回一个异步完成. promises 中所有的promise都promise都“完成”时或参数中不包含 promise 时回调完成。 如果参数中有一个promise失败，那么Promise.all返回的promise对象失败 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组 12345678910111213141516171819202122232425Promise.all = function(promises) &#123; promises = Array.from(promises); // 将可迭代对象转换成数组 return new Promise((resolve, reject) =&gt; &#123; let index = 0; let result = []; if (promises.length === 0) &#123; resolve(result); &#125; else &#123; function processValue(i, value) &#123; result[i] = value; if (++index === promises.length) &#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; Promise.resolve(promises[i]).then((data) =&gt; &#123; processValue(i, data); &#125;, (err) =&gt; &#123; reject(err); return; &#125;) &#125; &#125; &#125;)&#125; Promise.racePromise.race函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。 如果传的参数数组是空，则返回的 promise 将永远等待。 如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。 123456789101112131415161718Promise.race = function(promises) &#123; promises = Array.from(promises); return new Promise((resolve, reject) =&gt; &#123; if (promises.length === 0) &#123; return; &#125; else &#123; for (let i = 0; i &lt; promises.length; i++) &#123; Promise.resolve(promises[i]).then((data) =&gt; &#123; resolve(data); return; &#125;, (err) =&gt; &#123; reject(err); return; &#125;) &#125; &#125; &#125;)&#125; 本文所有源代码：handwriting-promise 总结第一次写难免遇到各种问题，只要对照规范多写几次，自己总结一下，你也可以很快写出通过测试的Promise源码。 如果你能根据PromiseA+的规范，写出符合规范的源码，那么我想，对于面试中的Promise相关的问题，都能够给出比较完美的答案。 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"},{"name":"原理源码","slug":"前端/原理源码","permalink":"http://www.chenhanpeng.com/categories/前端/原理源码/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"},{"name":"原理源码","slug":"原理源码","permalink":"http://www.chenhanpeng.com/tags/原理源码/"}]},{"title":"「高频面试题」浏览器从输入url到页面展示中间发生了什么","slug":"interview/浏览器从输入url到页面展示中间发生了什么","date":"2021-03-17T23:57:40.000Z","updated":"2021-04-21T01:17:30.120Z","comments":true,"path":"what-happens-when-you-type-in-a-url/","link":"","permalink":"http://www.chenhanpeng.com/what-happens-when-you-type-in-a-url/","excerpt":"","text":"“在浏览器中，从输入URL到页面展示，中间发生了什么？”这是一道经典的高频面试题，其中涉及了网络、操作系统、web等一系列的知识。接下来我们一起来看看要怎么回答这道题。 整个过程可以大致描述为： URL解析用户输入URL，浏览器会根据用户输入的信息判断是搜索内容还是请求的URL。如果是搜索内容，就将搜索内容+默认搜索引擎来合成新的带搜索关键字的URL。如果判断输入内容符合URL规则，地址栏会根据规则，把内容加上协议，合成为完整的URL。 地址解析 协议 默认端口号 传输协议 http 80 超文本传输协议 https 443 在http的基础上进行了安全设置(SSL/TSL)证书认证 ftp 21 主要用于客户端电脑和服务器端的文件传输 URL的编码因为网络标准规定了URL只能是字母和数字，还有一些特殊符号（-_.~ ! * ‘ ( ) ; : @ &amp; = + $ , / ? # [ ]， 对于一些特殊字符，在客户端和服务端传递的时候，需要进行编码和解码。 encodeURI、decodeURI：对中文、空格等编码解码，适合给URL本身编码 encodeURIComponent、decodeURIComponent：对中文、空格 : /等编码解码，编码范围更广，适合给参数编码。 escape unescape 主要用于客户端不同页面之间的数据传输的时候，信息的编码解码（如：cookie） 检查缓存接下来就进入页面资源请求过程。 这时，浏览器进程会通过进程间通信把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。 首先，网络进程会先查找本地缓存是否缓存了该资源。如果有缓存资源且缓存在有效期内，直接返回资源给浏览器进程；如果在缓存中没有找到该资源，那么直接进入网络请求流程。 这一步中的缓存是指强缓存，具体内容可以参考：一文彻底掌握HTTP缓存。 发起网络请求的第一步就是要进行DNS解析。 DNS解析 DNS解析：就是根据浏览器识别出来的URL地址中的域名，到DNS服务器上，查找服务器外网IP的过程。 DNS解析也是有缓存的：浏览器解析过一次，一般就会在本地记录一下解析记录。所以每一次DNS解析：本地DNS服务器解析(递归)、根/顶级/权威域名服务器解析(迭代) DNS解析过程DNS的域名查找：客户端和浏览器，本地DNS之间的查询方式是递归查询；本地DNS服务器和根域及子域之间的查询方式是迭代查询。 在客户端输入URL后，会有一个递归查找的过程，从浏览器缓存中查找 -&gt; 本地的hosts文件查找 -&gt; 本地DNS解析器缓存查找 -&gt; 本地DNS服务器查找，在这个过程中任何一步找到了都会结束查找流程。 递归查找过程如下图所示： 如果在本地DNS服务器中也没有查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下图： 优化 减少DNS请求次数：页面中尽可能少用过多域名。HTTP有并发性，但它的并发性是受到源的限制的，同一个源一次最多并发4-7个。 DNS预获取（DNS Prefetch）：在不能减少DNS解析记录的情况下，可以把DNS预解析。处理方法如下：1&lt;link rel=\"dns-prefetch\" href=\"//g.alicdn.com\"/&gt; 建立TCP连接，三次握手DNS解析获取到服务器的IP+端口后，接下来就是要建立TCP链接，这里就涉及到我们常说的“三次握手”。 首先，判断是不是https，如果是，则HTTPS其实是HTTP + SSL/TLS 两部分组成，也就是在HTTP基础上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。 进行三次握手，建立TCP连接： 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为 x+1；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTAB_LISHED状态，完成TCP三次握手。 seq序号：用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记 ack确认序号：只有ACK标志位为1，确认序号字段才有效，ack=seq+1 标识位： ACK：确认标识，用于表示对数据包的成功接收 SYN：同步标识，表示TCP连接已初始化，发起一个新连接 FIN：完成标识，释放一个连接，用于拆除上一个SYN标识。一个完整的TCP连接过程一定有SYN和FIN包。 数据传输TCP 连接建立之后，浏览器端会构建请求行、 请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。如果是 HTTPS，还需要进行 TSL 协商。 服务器接收到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304；若无效则重新返回资源，状态码为200。 这里会涉及HTTP的协商缓存，具体内容可以参考：一文彻底掌握HTTP缓存 关闭TCP连接，四次挥手 第一次挥手：主机1（可以是客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态，表示主机1没有数据要发送给主机2了； 第二次挥手：主机2接收到主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number + 1；主机1进入 FIN_WAIT_2状态；主机2告诉主机1，我同意你的关闭请求； 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段后，就关闭连接；此时，主机1等待主机2 MSL后依然没有收到回复，则证明主机2已正常关闭，那好，主机1也可以关闭连接了。 浏览器渲染浏览器拿到资源会根据资源类型进行处理，比如是 gzip 压缩后的文件则进行解压缩，如果响应头 Content-type 是 text/html，则开始解析HTML。 按照渲染的时间顺序，流水线可以分为下面几个子阶段：构建DOM树、样式计算、布局阶段、分层、栅格化和显示。 1、渲染进程将HTML内容转换为浏览器能够读懂的DOM树结构。 2、渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。 3、创建布局树，并计算元素的布局信息。 4、对布局树进行分层，并生成分层树。 5、为每个图层生成绘制列表，并将其提交到合成线程。 6、合成线程将图层分图块，并栅格化将图块转换成位图。 7、合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。 构建DOM树浏览器从网络或硬盘中获得HTML字节数据后，会先将HTML的原始字节数据转换为文件指定编码的字符，然后浏览器会根据HTML规范来将字符串转换为各种令牌标签，如html、body等，最终解析成一个树状的对象模型，就是DOM树。 具体步骤如下： 转码：读取接收到的HTML二进制数据，按指定编码格式将字节转换为HTML字符串 Tokens化：解析HTML，将HTML字符串转换为结构清晰的Tokens，每个Token都有特殊的含义，同时又自己的一套规则 构建Nodes：每一个Node都添加特定的属性或属性访问器，通过指针能够确定Node的父、子、兄弟关系和所属treeScope 构建DOM树：最重要的工作就是建立起每个节点的父子兄弟关系。 解析过程中遇到图片、link、script会启动下载。 script标签会阻塞 DOM 树的构建，所以一般将 script 放在底部，或者添加 async 、defer 标识。 css 下载时异步，不会阻塞浏览器构建 DOM 树，但是会阻塞渲染，布局阶段会等待 css 下载解析完毕后才进行。 样式计算渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。 样式计算过程主要有两步： 属性值标准化：先将所有值转换为渲染引擎容易理解的、标准化的计算值。在CSS文本中有很多属性值，如em、blue、bold等等，这些类型值不容易被渲染引擎理解，所以需要进行转换。 处理样式的继承和层叠，计算出DOM树中每个节点的具体样式。 CSS样式来源主要有3种： 通过link引用的外部css文件 style标签内的css 元素的style属性内嵌的css 布局阶段布局过程，即排除script、meta等功能化、非视觉节点，排除 display:none 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。 分层页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。 并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。 图层绘制渲染引擎实现图层的绘制：把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。 绘制列表中的指令非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。 栅格化合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。 通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。 显示最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。 页面渲染优化： HTML文档结构层次尽量少，最好不深于六层； 脚本尽量后放，放在前即可； 少量首屏样式内联放在标签内 样式结构层次尽量简单 在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流； 减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画； 动画尽量使用在绝对定位或固定定位的元素上； 隐藏在屏幕外，或在页面滚动时，尽量停止动画； 尽量缓存DOM查找，查找器尽量简洁； 涉及多域名的网站，可以开启域名预解析。 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/categories/面试/"},{"name":"面试","slug":"前端/面试","permalink":"http://www.chenhanpeng.com/categories/前端/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/tags/面试/"}]},{"title":"「LeetCode系列」42.接雨水","slug":"leetcode/LeetCode-42-接雨水","date":"2021-03-05T02:37:45.000Z","updated":"2021-04-21T01:17:31.832Z","comments":true,"path":"null/","link":"","permalink":"http://www.chenhanpeng.com/null/","excerpt":"","text":"作者：Hanpeng_Chen 公众号：前端极客技术 博客：官网、掘金 今天我们来做一道LeetCode上的题目，原题链接：42.接雨水 题目描述给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例2： 输入：height = [4,2,0,3,2,5] 输出：9 思路分析暴力求解思路 根据示例1的图片我们可以比较清晰理解题目：每个柱子宽度为1，所以我们只要计算出每个柱子上面可以积蓄雨水的体积，最后进行求和即可得出总的雨水体积。 对于每个柱子上面的蓄水量，根据木桶原理，我们只要找出下雨后水能达到的最高位置，即两边最大高度的较小值减去当前高度的值。 求解步骤： 初始化sum = 0 从左往右遍历数组： 初始化两边最大高度分别为0： left_max = 0, right_max = 0 从当前元素向左遍历并更新： left_max = Math.max(left_max, height[k]) 从当前元素向右遍历并更新： right_max = Math.max(right_max, height[k]) 将Math.min(left_max, right_max) - height[i]累加到sum中 实现代码：123456789101112131415var trap = function(height) &#123; let len = height.length; let sum = 0; for (let i = 1; i &lt; len - 1; i++) &#123; let left_max = 0, right_max = 0; for (let k = i; k &gt;= 0; k--) &#123; left_max = Math.max(left_max, height[k]) &#125; for (let k = i; k &lt; len; k++) &#123; right_max = Math.max(right_max, height[k]) &#125; sum += (Math.min(left_max, right_max) - height[i]) &#125; return sum&#125;; 复杂度分析 该方法用到了双重遍历，所以时间复杂度为：O(n^2)；空间复杂度为：O(1) 暴力求解优化上面的暴力解法中，每次为了找到位置i的左右最大值，都要向左和向右遍历一次，因此出现了双重遍历。如果我们提前将每个位置的左右最大值查出并存储起来，后面遍历数组的时候直接去相应的值，那么就不会出现双重遍历的情况，时间复杂度也就降为：O(n)。 步骤 找到数组中i的到最左端最高的柱子高度 left_max; 找到数组中i到最右端最高的柱子的高度right_max; 遍历数组： 累加 Math.min(left_max[i], right_max[i]) - height[i] 实现代码12345678910111213141516171819var trap = function(height) &#123; if (!height || height.length === 0) return 0; let sum = 0; let left_max = []; let right_max = []; let len = height.length; left_max[0] = height[0]; for (let i = 1; i &lt; len; i++) &#123; left_max[i] = Math.max(height[i], left_max[i - 1]) &#125; right_max[len - 1] = height[len - 1]; for (let i = len - 2; i &gt;= 0; i--) &#123; right_max[i] = Math.max(height[i], right_max[i + 1]) &#125; for (let i = 1; i &lt; len - 1; i++) &#123; sum += Math.min(left_max[i], right_max[i]) - height[i]; &#125; return sum;&#125;; 复杂度分析 时间复杂度：总共用了三次遍历，每次O(n)，所以总的时间复杂度为O(n) 空间复杂度：使用了额外的O(n)空间来存left_max和right_max数组，所以空间复杂度为O(n) 该解法是通过空间换时间的方式来减少运行时间。 双指针接下来我来介绍另一种比较好的解法：双指针解法。 在暴力解法的核心主要是查找出左右两边的最大值，但是我们仔细分析会发现，只要 right_max[i] &gt; left_max[i]，柱子i位置的最大存水量就由left_max决定；反之如果 left_max[i] &gt; right_max[i]，则由right_max决定。 根据这个思路，我们还是先从左往右扫描数组，我们可以认为如果一侧有更高的柱子（例如右侧），积水的高度依赖于当前方向的高度（从左到右）。当我们发现另一侧（右侧）的条形块高度不是最高的，我们则开始从相反的方向遍历（从右到左）。 此时我们维护左右两个指针，通过两个指针交替进行遍历，实现一次遍历完成。 对于位置left而言，它左边的最大值一定是left_max，右边的最大值大于等于right_max。如果此时left_max &lt; right_max，那么它就能计算出它的位置能存多少水，无论右边将来会不会出现更大的值，都不影响计算出的结果，所以当height[left] &lt; height[right] 时，我们去处理left指针。反之，我们去处理right指针。 步骤： 初始化left指针为0，right指针为height.length - 1; while left &lt; right时： if height[left] &lt; right[right]: left_max = Math.max(left_max, height[left]) 累加 left_max - height[left] 到sum中 left++ else right_max = Math.max(right_max, height[right]) sum += right_max - height[right] right– 实现代码12345678910111213141516171819var trap = function(height) &#123; let sum = 0; let left_max = 0; let right_max = 0; let left = 0; let right = height.length - 1; while(left &lt; right) &#123; if (height[left] &lt; height[right]) &#123; left_max = Math.max(left_max, height[left]); sum += left_max - height[left]; left++; &#125; else &#123; right_max = Math.max(right_max, height[right]); sum += right_max - height[right]; right--; &#125; &#125; return sum;&#125;; 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术(FrontGeek)，我们一起学习一起进步。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.chenhanpeng.com/categories/算法/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://www.chenhanpeng.com/categories/算法/LeetCode/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/tags/面试/"},{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://www.chenhanpeng.com/tags/LeetCode题解/"}]},{"title":"「面试必备」一文吃透JavaScript继承","slug":"javascript/一文吃透JavaScript继承","date":"2021-02-28T15:53:15.000Z","updated":"2021-04-21T01:17:31.420Z","comments":true,"path":"inheritance-in-javascript/","link":"","permalink":"http://www.chenhanpeng.com/inheritance-in-javascript/","excerpt":"","text":"继承在各种编程语言中都充当着至关重要的角色，在JavaScript中也被经常用在前端工程基础库的底层搭建上，是JavaScript需要重点学习的一块内容。 继承可以使得子类具有父类的各种方法和属性。ES6中推出了class这个概念，方便了我们学习和理解，但class只是一个语法糖，实际底层的实现还是原来的那一套：利用原型链和构造函数来实现继承，接下来我们一起来看看在JavaScript中都有哪些实现继承的方法。 原型链继承原型链继承是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 该方法主要涉及构造函数、原型和实例，三者之间存在着一定的关系： 每一个构造函数都有一个prototype属性，指向函数的原型对象；每一个原型对象都有一个constructor属性，指向构造函数；每一个实例都有一个 proto 属性，指向构造函数的原型对象。 我们先来看下面一段代码：123456789101112function Parent() &#123; this.name = \"parent\"; this.interest = [\"eat\"];&#125;function Child() &#123; this.type = \"child\";&#125;Child.prototype = new Parent();let child = new Child();console.log(child.name, child.type); 在上面的代码中，定义了 Parent 和 Child 两个对象，两个对象之间实现了继承，这种继承方式是通过创建Parent的实例，并将该实例赋给 Child.prototype 实现的。该方法实现的本质就是重写了原型对象。 从上面的代码看，在子类的实例中可以访问到父类的属性和方法，看似这种继承方式没什么问题，我们接着看下面的代码：123let child1 = new Child();child1.interest.push(\"run\");console.log(child.interest, child1.interest); // [ 'eat', 'run' ] [ 'eat', 'run' ] 上面代码中我又新创建了一个子类实例 child1，并改变了 interest 属性，但是原来的 child 的interest属性也跟着变了。 出现这个问题的原因很简单：因为两个实例使用的是同一个原型对象，它们的内存空间是共享的。当一个发生变化时，另一个也随之变化，这就是使用原型链继承方式的一个缺点。 还有一个缺点就是：没有办法在不影响所有对象实例的情况下，给父类的构造函数传递参数。 因为上面的问题，实践中很少会单独使用原型链继承。 构造函数继承为了解决原型属性共享问题，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术，有时候也叫伪造对象或经典继承。 借助构造函数的基本思想就是：利用call或apply把父类中通过this指定的属性和方法复制到子类创建的实例中。因为this对象是在运行时基于函数的执行环境绑定的。 我们通过下面代码来了解：1234567891011121314151617181920function Parent(name) &#123; this.name = name; this.interest = [\"eat\"];&#125;Parent.prototype.getName = function () &#123; return this.name;&#125;;function Child(name) &#123; Parent.call(this, name); this.type = \"child\";&#125;let child1 = new Child('child1');child1.interest.push(\"run\");console.log(child1.interest); // [ 'eat', 'run' ]let child2 = new Child('child2');console.log(child2.interest); // [ 'eat' ]console.log(child1.getName()); // 报错 从上面代码的执行结果来看，该方法解决了原型链继承的弊端，但仍存在问题：父类原型对象上一旦存在父类之前自己定义的方法，子类将无法继承这些方法。 我们可以总结出构造函数实现继承具有如下优缺点：优点： 它使父类的引用类型属性不会被共享； 可以向父类的构造函数传参。 缺点： 只能继承父类的实例属性和方法，不能继承原型属性或方法。 组合继承（原型链+构造函数）组合继承（combination inheritance），也叫作伪经典继承。是将原型链和借用构造函数的技术组合在一起，发挥二者之长的一种继承方式。 组合继承方法的思路是将公共的属性和方法放在父类的 prototype 上，然后利用原型链继承来实现公共的属性和方法的继承，而对于那种每个实例都可自定义修改的属性采取构造函数继承的方法来实现每个实例都独有一份这样的属性。 代码如下：123456789101112131415161718192021222324function Parent() &#123; this.name = \"parent\"; this.interest = [\"eat\"];&#125;Parent.prototype.getName = function () &#123; return this.name;&#125;;function Child() &#123; Parent.call(this); this.type = \"child type\";&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;let child1 = new Child();let child2 = new Child();child1.interest.push(\"run\");console.log(child1.interest, child2.interest); // [ 'eat', 'run' ] [ 'eat' ]console.log(child1.getName()); // parentconsole.log(child2.getName()); // parent 从代码执行结果来看，组合继承避免了原型链继承和构造函数继承的缺陷，融合了二者的优点。 但组合继承有一个问题：就是无论什么情况下，都会调用两次超类型的构造函数，即Parent执行了两次，第一次是改变 Child的prototype的时候，第二次是通过call方法调用Parent的时候。 上面介绍的三种方法主要是围绕构造函数的方式，如果是JavaScript的普通对象，要如何实现继承？ 原型式继承该方法的原理就是借助原型，可以基于已有的对象创建新对象，节省了创建自定义类型这一步。123456function object(o) &#123; function W()&#123; &#125; W.prototype = o; return new W();&#125; ES5中新增了 Object.create() 方法规范化了原型式继承，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数）。 通过下面的代码我们一起看看普通对象时怎样实现继承的。12345678910111213141516171819202122let parent = &#123; name: \"parent\", interest: [\"eat\"], getName: function () &#123; return this.name; &#125;,&#125;;let parent1 = Object.create(parent);parent1.name = \"parent1\";parent1.interest.push(\"sleep\");let parent2 = Object.create(parent);parent2.name = \"parent2\";parent2.interest.push(\"run\");console.log(parent1.name); // parent1console.log(parent1.name === parent1.getName()); // trueconsole.log(parent1.interest); // [ 'eat', 'sleep', 'run' ]console.log(parent2.name); // parentconsole.log(parent2.name === parent2.getName()); // trueconsole.log(parent2.interest); // [ 'eat', 'sleep', 'run' ] 从上面代码执行结果你会发现存在引用类型数据共享问题，因为Object.create方法是可以为一些对象实现浅拷贝的。 关于浅拷贝的内容可以看我之前写的文章：这一次，彻底掌握JavaScript的深浅拷贝 原型式继承的缺点：多个实例的引用类型属性指向相同的内存，存在篡改的可能。 接下来我们看下在原型式继承基础上进行优化的另一种继承方式：寄生式继承。 寄生式继承寄生式继承时原型式继承的加强版，利用原型式继承可以获得一份目标对象的浅拷贝的能力再进行增强，添加一些方法，这样的继承方式称为寄生式继承。 寄生式继承的优缺点和原型式继承一样，但对于普通对象的继承方式来说，寄生式继承相比于原型式继承，在父类的基础上添加了更多的方法。下面我们一起来看下其实现代码： 12345678910111213141516171819let parent = &#123; name: \"parent\", interest: [\"eat\", \"run\"], getName: function () &#123; return this.name; &#125;,&#125;;function clone(original) &#123; let clone = Object.create(original); clone.getInterest = function () &#123; return this.interest; &#125;; return clone;&#125;let parent1 = clone(parent);console.log(parent1.getName()); // parentconsole.log(parent1.getInterest()); // [ 'eat', 'run' ] 从上面代码可以看到，parent1是通过寄生式继承生成的实例，不仅有getName方法，还拥有getInterest方法。 寄生组合式继承实质上，寄生组合继承是寄生式继承的加强版。这是为了避免组合继承中无可避免地要调用两次父类构造函数的最佳方案，也是所有继承方式中相对最优的继承方式。 代码如下：12345678910111213141516171819202122232425262728293031323334function clone(parent, child) &#123; // 改用Object.create可以减少组合继承中多进行一次构造函数 child.prototype = Object.create(parent.prototype); child.prototype.constructor = child;&#125;function Parent() &#123; this.name = \"parent\"; this.interest = [\"eat\", \"run\"];&#125;Parent.prototype.getName = function () &#123; return this.name;&#125;;function Child() &#123; Parent.call(this); this.type = \"child type\";&#125;clone(Parent, Child);Child.prototype.getInterest = function () &#123; return this.interest;&#125;;let child1 = new Child();let child2 = new Child();child1.interest.push(\"sleep\");console.log(child1.getName()); // parentconsole.log(child1.getInterest()); // [ 'eat', 'run', 'sleep' ]console.log(child2.getName()); // parentconsole.log(child2.getInterest()); // [ 'eat', 'run' ] 通过这段代码可以看出来，这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销。 ES6新增了Class语法糖，并提供了继承的关键字extends，接下来我们看下extends的用法和底层实现逻辑。 ES6的Class继承Class可以通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 大多数浏览器的ES5实现中，每一个对象都有 proto 属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype和proto两个属性，因此同时存在两条继承链: 子类的proto属性，表示构造函数的继承，总是指向父类； 子类的prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。 12345678910111213141516171819202122232425class Parent &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;class Child extends Parent &#123; constructor(name, age) &#123; super(name); this.age = age; &#125; getAge() &#123; return this.age; &#125;&#125;let child = new Child(\"zhangsan\", 25);console.log(child.getName());console.log(child.getAge());console.log(Child.__proto__ === Parent); // trueconsole.log(Child.prototype.__proto__ === Parent.prototype); // true 在实际项目开发过程中，因为浏览器兼容性问题，我们都会利用babel将ES6的代码编译成ES5。那接下来我们来看看extends编译成ES5语法是什么样子的，下面是转译的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475\"use strict\";function _typeof(obj) &#123; \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" &amp;&amp; typeof Symbol.iterator === \"symbol\") &#123; _typeof = function _typeof(obj) &#123; return typeof obj; &#125;; &#125; else &#123; _typeof = function _typeof(obj) &#123; return obj &amp;&amp; typeof Symbol === \"function\" &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? \"symbol\" : typeof obj; &#125;; &#125; return _typeof(obj); &#125;function _instanceof(left, right) &#123; if (right != null &amp;&amp; typeof Symbol !== \"undefined\" &amp;&amp; right[Symbol.hasInstance]) &#123; return !!right[Symbol.hasInstance](left); &#125; else &#123; return left instanceof right; &#125; &#125;function _inherits(subClass, superClass) &#123; if (typeof superClass !== \"function\" &amp;&amp; superClass !== null) &#123; throw new TypeError(\"Super expression must either be null or a function\"); &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, writable: true, configurable: true &#125; &#125;); if (superClass) _setPrototypeOf(subClass, superClass);&#125;function _setPrototypeOf(o, p) &#123; _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) &#123; o.__proto__ = p; return o; &#125;; return _setPrototypeOf(o, p); &#125;function _createSuper(Derived) &#123; var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() &#123; var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) &#123; var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); &#125; else &#123; result = Super.apply(this, arguments); &#125; return _possibleConstructorReturn(this, result); &#125;; &#125;function _possibleConstructorReturn(self, call) &#123; if (call &amp;&amp; (_typeof(call) === \"object\" || typeof call === \"function\")) &#123; return call; &#125; return _assertThisInitialized(self); &#125;function _assertThisInitialized(self) &#123; if (self === void 0) &#123; throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); &#125; return self; &#125;function _isNativeReflectConstruct() &#123; if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try &#123; Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () &#123;&#125;)); return true; &#125; catch (e) &#123; return false; &#125; &#125;function _getPrototypeOf(o) &#123; _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) &#123; return o.__proto__ || Object.getPrototypeOf(o); &#125;; return _getPrototypeOf(o); &#125;function _classCallCheck(instance, Constructor) &#123; if (!_instanceof(instance, Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125; &#125;function _defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125;function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; &#125;var Parent = /*#__PURE__*/function () &#123; function Parent(name) &#123; _classCallCheck(this, Parent); this.name = name; &#125; _createClass(Parent, [&#123; key: \"getName\", value: function getName() &#123; return this.name; &#125; &#125;]); return Parent;&#125;();var Child = /*#__PURE__*/function (_Parent) &#123; _inherits(Child, _Parent); var _super = _createSuper(Child); function Child(name, age) &#123; var _this; _classCallCheck(this, Child); _this = _super.call(this, name); _this.age = age; return _this; &#125; _createClass(Child, [&#123; key: \"getAge\", value: function getAge() &#123; return this.age; &#125; &#125;]); return Child;&#125;(Parent); 从编译后的代码可以看到，采用的也是寄生组合式继承方式，这也证明了这种方式是较优的解决继承的方式。 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术(FrontGeek)，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"}],"tags":[{"name":"继承","slug":"继承","permalink":"http://www.chenhanpeng.com/tags/继承/"}]},{"title":"这一次彻底掌握JavaScript的深浅拷贝","slug":"javascript/这一次彻底掌握JavaScript的深浅拷贝","date":"2021-02-22T15:30:45.000Z","updated":"2021-04-21T01:17:31.764Z","comments":true,"path":"javascript-shallow-copy-and-deep-copy/","link":"","permalink":"http://www.chenhanpeng.com/javascript-shallow-copy-and-deep-copy/","excerpt":"","text":"关于拷贝这个问题，也是前端面试中的一道经典面试题，我们在日常开发中也常碰到需要用到深拷贝或浅拷贝的场景。接下来我们通过这篇文章，彻底掌握JavaScript的深浅拷贝。 数据类型在开始讲深浅拷贝之前，我们要先知道JavaScript的数据类型，主要有下图所示的8种： Object是引用类型，其他7种为基础类型。 JavaScript的数据类型最后都会在初始化之后放在不同的内存中，因此上面的数据类型大致可以分为两类来进行存储： 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量 引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。 接下来我们先来看看浅拷贝。 欢迎关注公众号：前端极客技术(FrontGeek) 浅拷贝的原理和实现浅拷贝的定义： 创建一个对象接受要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，可能会影响到另一个对象。 我们来看看JavaScript中都有哪些实现浅拷贝的方法。 Object.assignobject.assign 是 ES6 中 object 的一个方法，该方法可以用于 JS 对象的合并等多个用途，其中一个用途就是可以进行浅拷贝。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。 object.assign 的语法为：Object.assign(target, …sources) object.assign 的示例代码如下： 12345678910let target = &#123;&#125;let source = &#123; a: &#123; b: 1 &#125;&#125;Object.assign(target, source)source.a.b = 10; console.log(source); // &#123; a: &#123; b: 10 &#125; &#125;; console.log(target); // &#123; a: &#123; b: 10 &#125; &#125;; 从上面代码中我们可以看到，首先通过 Object.assign 将 source 拷贝到 target 对象中，将 source 对象中的 b 属性由 1 修改为 10。从执行结果可以看出target和source两个对象中的 b 属性都变为 10 了，证明 Object.assign 暂时实现了我们想要的拷贝效果。 使用Object.assign方法实现浅拷贝时有几点需要注意： Object.assign方法不会拷贝对象的继承属性 Object.assign方法不会拷贝对象的不可枚举的属性 可以拷贝Symbol类型的属性 12345678910111213let obj1 = &#123; a: &#123; b: 1 &#125;, sym: Symbol(1) &#125;;Object.defineProperty(obj1, \"innumerable\", &#123; value: \"不可枚举属性\", enumerable: false,&#125;);let obj2 = &#123;&#125;;Object.assign(obj2, obj1);obj1.a.b = 10;console.log(\"obj1\", obj1); // obj1 &#123; a: &#123; b: 10 &#125;, sym: Symbol(1) &#125;console.log(\"obj2\", obj2); // obj1 &#123; a: &#123; b: 10 &#125;, sym: Symbol(1) &#125; 从上面的样例代码中可以看到，利用 object.assign 也可以拷贝 Symbol 类型的对象，但是如果到了对象的第二层属性 obj1.a.b 这里的时候，前者值的改变也会影响后者的第二层属性的值，说明其中依旧存在着访问共同堆内存的问题，也就是说这种方法还不能进一步复制，而只是完成了浅拷贝的功能。 扩展运算符方法我们也可以利用JS的扩展运算符，在构造对象的同时完成浅拷贝的功能。 123456789let obj = &#123;a: 1, b: &#123;c: 10&#125;&#125;let obj2 = &#123;...obj&#125;obj2.a = 10console.log(obj);console.log(obj2);let arr = [1, 3, 4, 5, [10, 20]]let arr2 = [...arr]console.log(arr2) 扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便。 concat拷贝数组数组的concat方法也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中元素的属性，因为它会影响拷贝之后连接的数组。 12345let arr = [1, 2, 3];let newArr = arr.concat();newArr[1]= 10;console.log(arr);console.log(newArr); slice拷贝数组slice方法也比较有局限性，因为它仅仅针对数组类型。 slice方法会返回一个新的数组对象，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原数组的。 1234let arr = [1, 2, &#123;val: 4&#125;];let newArr = arr.slice();newArr[2].val = 1000;console.log(arr); //[ 1, 2, &#123; val: 1000 &#125; ] 从上面的代码中可以看出，这就是浅拷贝的限制所在了——它只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝。这一讲的后面我会介绍深拷贝相关的内容。 手工实现一个浅拷贝除了上面提到的方法，我们也可以手写一个浅拷贝方法，思路如下： 对基础数据类型做一个最基本的拷贝； 对引用类型开辟一个新的存储，并拷贝一层对象属性。 12345678910111213const shallowCopy = (target) =&gt; &#123; if (typeof target === \"object\" &amp;&amp; target !== null) &#123; const copyTarget = Array.isArray(target) ? [] : &#123;&#125;; for (let key in target) &#123; if (target.hasOwnProperty(key)) &#123; copyTarget[key] = target[key]; &#125; &#125; return copyTarget; &#125; else &#123; return target; &#125;&#125;; 深拷贝的原理和实现浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。 这两个对象是相互独立、不受影响的，彻底实现了内存上的分离。总的来说，深拷贝的原理可以总结如下： 将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不完全改变源对象，二者实现真正的分离。 知道了深拷贝的原理后，我们来看下都有哪些深拷贝的方法： 乞丐版：JSON.stringifyJSON.stringify() 方法是开发中常用的也是最简单的深拷贝方法，其实就是将一个对象序列化为JSON的字符串，并将对象中的内容转换为字符串，最后再用JSON.parse()方法将JSON字符串生成一个新的对象。 12345678let obj = &#123;a: 1, b: [1, 2, 3]&#125;;let str = JSON.stringify(obj);let newObj = JSON.parse(str);obj.a = 2;obj.b.push(4)console.log(obj)console.log(newObj) 从上面的代码可以看到，通过 JSON.stringify 可以初步实现一个对象的深拷贝，通过改变 obj 的 a 属性，其实可以看出 newObj 这个对象也不受影响。 我们来看看下面几种使用JSON.stringify方法进行深拷贝的情况：12345678910111213141516171819202122function Obj() &#123; this.func = function () &#123; alert(1) &#125;; this.obj = &#123;a:1&#125;; this.arr = [1,2,3]; this.und = undefined; this.reg = /123/; this.date = new Date(0); this.NaN = NaN; this.infinity = Infinity; this.sym = Symbol(1);&#125; let obj1 = new Obj();Object.defineProperty(obj1,'innumerable',&#123; enumerable:false, value:'innumerable'&#125;);console.log('obj1',obj1);let str = JSON.stringify(obj1);let obj2 = JSON.parse(str);console.log('obj2',obj2); 从上面的执行结果来看，JSON.stringify方法来实现深拷贝并不完美，下面我们一起来看看JSON.stringify实现深拷贝存在的问题： 拷贝的对象如果有函数、undefined、symbol这几种类型，经过JSON.stringify序列化之后的字符串中这个键值对会消失； 拷贝Date引用类型会变成字符串 无法拷贝不可枚举的属性 无法拷贝对象的原型链 拷贝RegExp引用类型会变成空对象 对象中含有 NaN、Infinity、-Infinity，JSON序列化的结果会变成null 无法拷贝对象的循环应用，即对象成环，例如obj[key]=obj 用 JSON.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。 如果深拷贝方法要支持Function、Symbol等类型的拷贝，我们只能自己手动实现一个深拷贝方法。 手写实现深拷贝（基础版）接下来我们自己实现一个深拷贝方法，思路如下： 通过for in遍历传入参数的属性值，如果值时引用类型则再次递归调用该方法，如果时基础类型就直接复制。 1234567891011121314151617181920212223function deepCopy(target) &#123; let copyTarget = Array.isArray(target) ? [] : &#123;&#125;; for (let key in target) &#123; if (typeof target[key] === \"object\") &#123; copyTarget[key] = deepCopy(target[key]); &#125; else &#123; copyTarget[key] = target[key]; &#125; &#125; return copyTarget;&#125;let obj1 = &#123; a: &#123; b: 1, &#125;, c: 10,&#125;;let obj2 = deepCopy(obj1);obj1.a.b = 100;obj1.c = 22console.log(obj2); 上面我们通过递归的方式实现了深拷贝，但仍存在一些问题没有解决： 无法复制不可枚举的属性以及Symbol类型； 只针对普通的引用类型的值做了递归复制，但对于Array、Date、RegExp、Error、Function这些引用类型并不能正确地拷贝。 对象的属性里面成环，即循环引用没有解决。 接下来我们一起来改进这个深拷贝方法： 改进版的深拷贝方法针对上面说的几点问题，一起来看看有什么解决方法： 针对不可枚举属性和Symbol类型，可以使用 Reflect.ownKeys 方法； 参数为Date、RegExp类型时，直接生成一个新的实例返回； 利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object.create() 方法创建一个新对象，并继承传入原对象的原型链； 利用 WeakMap 类型作为 Hash表，因为WeakMap时弱引用类型，可以有效防止内存泄漏，作为检测循环引用很有帮助，如果存在循环，则引用直接返回WeakMap存储的值。 根据上面的内容，我们重新写一下深拷贝方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function deepCopy(obj, hash = new WeakMap()) &#123; // 日期对象直接返回一个新的日期对象 if (obj.constructor === Date) return new Date(obj); // 如果是正则对象直接返回一个新的正则对象 if (obj.constructor === RegExp) return new RegExp(obj); // 如果循环引用了就用WeakMap来解决 if (hash.has(obj)) return hash.get(obj); // 遍历传入参数所有键的特性 let allDesc = Object.getOwnPropertyDescriptor(obj); // 继承原型链 let copyObj = Object.create(Object.getPrototypeOf(obj), allDesc); hash.set(obj, copyObj) for (let key of Reflect.ownKeys(obj)) &#123; copyObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== 'function') ? deepCopy(obj[key], hash) : obj[key] &#125; return copyObj&#125;function isComplexDataType(obj) &#123; return (typeof obj === 'object' || typeof obj === 'function') &amp;&amp; obj !== null&#125;// 下面是验证代码let obj = &#123; num: 0, str: '', boolean: true, unf: undefined, nul: null, obj: &#123; name: '我是一个对象', id: 1 &#125;, arr: [0, 1, 2], func: function () &#123; console.log('我是一个函数') &#125;, date: new Date(0), reg: new RegExp('/我是一个正则/ig'), [Symbol('1')]: 1,&#125;;Object.defineProperty(obj, 'innumerable', &#123; enumerable: false, value: '不可枚举属性' &#125;);obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))obj.loop = obj // 设置loop成循环引用的属性let cloneObj = deepCopy(obj)cloneObj.arr.push(4)console.log('obj', obj)console.log('cloneObj', cloneObj) 性能问题尽管使用深拷贝可以完全克隆一个新的对象，不会产生副作用，但是因为深拷贝方法用到递归，性能方面不如浅拷贝，在实际开发过程中，我们要根据实际情况进行选择。 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术(FrontGeek)，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"}],"tags":[{"name":"深浅拷贝","slug":"深浅拷贝","permalink":"http://www.chenhanpeng.com/tags/深浅拷贝/"}]},{"title":"【面试题】Vue2 中如何检测数组变化","slug":"interview/Vue2中如何检测数组变化","date":"2021-02-04T14:36:47.000Z","updated":"2021-04-21T01:17:29.967Z","comments":true,"path":"how-to-observe-array-in-vue2/","link":"","permalink":"http://www.chenhanpeng.com/how-to-observe-array-in-vue2/","excerpt":"","text":"为什么要对数组进行单独处理我们都知道在Vue2中，对响应式处理利用的是 Object.defineProperty 对数据进行拦截。如果数据是数组，我们还是用defineProperty的方法进行拦截的话，需要对数组每一层每一位都进行依赖收集和更新时的notify，这样消耗的性能将指数倍增加，因为我们无法预估一个数组有多少层有多少位。 考虑性能原因，没有用 defineProperty 对数组的每一项进行拦截，而是选择对下面7个数组方法进行重写： push shift pop splice unshift sort reverse 为什么是上面7个方法？因为我们要监控的是原数组的数据变化，使用上面7个方法对数组进行操作，会改变原数组，而其他方法并不会改变原数组。 如何重写数组方法我们先来看Vue2中关于重写数组方法的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // 重写7个方法 // cache original method // 获取数组原方法 const original = arrayProto[method] // def方法重新定义arrayMethods的method方法，然后将新的取值方法赋值 def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; // 如果是去除数组参数方法，触发一次notify将会重新计算 // 如果仅仅是数字数据，任何操作只需要再次执行一次notify则可以 // 但是如果新增的是一个对象类型，就需要重新监听 // 为什么用角标和length属性不能监听的原因是因为无法触发obj的get方法，所以没法动态监听 if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() // &#123;a,b,c&#125; observer =&gt; dep return result &#125;)&#125;)/** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125; 从上面的代码我们可以知道：vue2对push、splice等方法进行重写，如果加入新对象，会调用observe方法对新对象进行劫持。最后在向外抛出数组变化前，通知观察者进行视图更新。 补充 在Vue2中只有通过上面说的7中变异方法修改数组才会触发数组对应的watcher进行更新，如果我们修改数组的索引和长度是无法监控到的，也就无法实现视图更新。如果想更改索引更新数据，可以通过 Vue.$set() 来进行处理。 数组中数据如果是对象类型，也会进行递归劫持。 欢迎关注我的微信公众号：前端极客技术(FrontGeek) 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术(FrontGeek)，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/categories/面试/"},{"name":"面试","slug":"前端/面试","permalink":"http://www.chenhanpeng.com/categories/前端/面试/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.chenhanpeng.com/tags/vue/"},{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/tags/面试/"}]},{"title":"【面试题】说一说你对Vue2 响应式原理的理解？","slug":"interview/说一说你对Vue响应式原理的理解","date":"2021-01-29T15:08:57.000Z","updated":"2021-04-21T01:17:30.220Z","comments":true,"path":"interview-vue-reactivity-in-depth/","link":"","permalink":"http://www.chenhanpeng.com/interview-vue-reactivity-in-depth/","excerpt":"","text":"前言虽然Vue3已经正式发布，但目前Vue2还是开发主力，所以近期面试Vue2相关内容还是比较常见的，今天我们一起来看看下面这个问题： 面试题 面试官：说一说你对Vue2 响应式原理的理解？ 无法让面试官满意的回答碰到面试官问你这个问题，你可能会做如下回答： Vue是非侵入性的响应式系统，遍历对象并使用Object.defineProperty对对象的属性进行数据劫持，当数据发生变化时，触发数据劫持的setter函数，通知组件实例的watcher需要进行视图更新，以此来实现响应式。 上面的答案虽然提到 Object.defineProperty 这一关键点，但并不能让面试官满意，因为有一些关键的细节并没有回答出来，比如：Vue是在什么时候进行数据劫持？又是如何实现在数据更新时通知视图更新的？ 让面试官满意的回答下面我们一起来过一下Vue2 的响应式流程： 在init数据初始化的时候，对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（这时候只会劫持已经存在的属性）。如果数据是数组类型， Vue2中是通过重写数组方法来实现。多层对象是通过递归来实现劫持的。 在初始化流程中的编译阶段，当render function 被渲染的时候，会读取Vue实例中和视图相关的响应式数据，此时会触发 getter 函数进行 依赖收集（将观察者Watcher对象存放到当前闭包的订阅者Dep的subs中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。 当数据发生变化或者视图导致的数据发生变化时，会触发数据劫持的setter函数，setter会通知初始化依赖收集中的Dep中和视图相应的 Watcher ，告知需要重新渲染视图，Watcher 就会再次通过 update 方法来更新视图。 上面的回答基本将Vue2的响应式原理说清楚了，虽然还有一些细节的内容没说，但如果你们清晰的将上面三个流程说出来，面试官就能知道你已经理解了Vue2的响应式原理，面试评分自然不会低。 因为Vue3已经发布，所以在这个基础上，面试官可能还会问：Vue3 在响应式原理上都做了哪些优化方案？这个问题我们后续在做解答。 感谢读完这篇文章，如果感觉写得还可以的话，关注公众号，点个赞，我们一起学习、准备面试。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/categories/面试/"},{"name":"面试","slug":"前端/面试","permalink":"http://www.chenhanpeng.com/categories/前端/面试/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.chenhanpeng.com/tags/vue/"},{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/tags/面试/"}]},{"title":"【面试真题系列】Vue中的v-if和v-show有什么区别？","slug":"interview/Vue中的v-if和v-show有什么区别","date":"2021-01-21T14:07:53.000Z","updated":"2021-04-21T01:17:30.059Z","comments":true,"path":"interview-vue-v-if-v-show/","link":"","permalink":"http://www.chenhanpeng.com/interview-vue-v-if-v-show/","excerpt":"","text":"在回答这个问题前，我们先来看下Vue文档中对这两个指令的说明： v-if：用于条件性地渲染一块内容。这块内容只会在指令的表达式返回truthy值的时候被渲染。 v-show：用于根据条件展示元素的指令。 v-if和v-show的共同点两者的作用效果是相同的，都能控制元素在页面是否显示。 在用法上也相同：12&lt;div v-if=\"show\"&gt;&lt;/div&gt;&lt;div v-show=\"show\"&gt;&lt;/div&gt; v-if和v-show的区别两者的区别主要表现在下面四个方面： 编译过程 编译条件 性能消耗 应用场景 编译过程v-if 是真正的条件渲染，因为它会确保切换过程中条件块内的事件监听器和 子组件适当地被销毁和重建。 v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由 true 变为false的时候触发组件的beforeDestroy、destroyed钩子。 v-show的元素始终会被渲染并保留在DOM中，只是简单切换元素的CSS属性display进行隐藏或显示。 编译条件v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直到条件第一次变为真时，才会开始渲染条件块。 v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 性能消耗v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。 应用场景如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 欢迎关注我的微信公众号：前端极客技术(FrontGeek) v-if和v-show原理分析下面我们通过Vue 2.x的源码，来看看v-if和v-show的原理。 在开始之前我们要知道vue2中字符串模板解析编译成真实DOM的过程，大致流程如下： 将模板template转为ast结构的JS对象 用ast得到的JS对象拼装render和staticRenderFns函数 render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息 vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点 v-if原理在模板编译的parse阶段，会使用 processIfConditions 函数处理条件渲染指令的内容：1234567891011function processIfConditions (el, parent) &#123; const prev = findPrevElement(parent.children) if (prev &amp;&amp; prev.if) &#123; addIfCondition(prev, &#123; exp: el.elseif, block: el &#125;) &#125; else if (process.env.NODE_ENV !== 'production') &#123; // 警告信息 &#125;&#125; 在模板编译的 codegen 阶段，会调用 genIf 函数处理 v-if 所在的标签：12345678910111213141516171819202122232425262728293031323334353637383940export function genIf ( el: any, state: CodegenState, altGen?: Function, altEmpty?: string): string &#123; el.ifProcessed = true // avoid recursion return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)&#125;function genIfConditions ( conditions: ASTIfConditions, state: CodegenState, altGen?: Function, altEmpty?: string): string &#123; if (!conditions.length) &#123; return altEmpty || '_e()' &#125; const condition = conditions.shift() if (condition.exp) &#123; return `($&#123;condition.exp&#125;)?$&#123; genTernaryExp(condition.block) &#125;:$&#123; genIfConditions(conditions, state, altGen, altEmpty) &#125;` &#125; else &#123; return `$&#123;genTernaryExp(condition.block)&#125;` &#125; // v-if with v-once should generate code like (a)?_m(0):_m(1) function genTernaryExp (el) &#123; return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state) &#125;&#125; 从代码中可以看出，v-if 指令会转化成三目运算符的形式。 带有 v-if 指令的模板会编译成根据数据源真假值来调用具体辅助方法的渲染函数，v-if 会根据数据源真假值来决定是否渲染该节点，这一点与 v-show 不同。 v-show原理v-show 指令根据表达式之真假值，切换元素的 display CSS 属性。当条件变化时该指令触发过渡效果。 在模板编译和生成VNode的过程中，v-show指令与自定义指令的过程一样 在调用处理指令的钩子函数 updateDirectives 时，v-show 指令有所不同，相当于 v-show 内部实现了自定义指令的 bind、update、unbind 三个阶段的钩子函数。123456789101112131415161718192021222324252627282930313233343536373839404142export default &#123; bind (el, &#123; value &#125;, vnode) &#123; vnode = locateNode(vnode) const transition = vnode.data &amp;&amp; vnode.data.transition const originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display if (value &amp;&amp; transition) &#123; vnode.data.show = true enter(vnode, () =&gt; &#123; el.style.display = originalDisplay &#125;) &#125; else &#123; el.style.display = value ? originalDisplay : 'none' &#125; &#125;, update (el, &#123; value, oldValue &#125;, vnode) &#123; if (!value === !oldValue) return vnode = locateNode(vnode) const transition = vnode.data &amp;&amp; vnode.data.transition if (transition) &#123; vnode.data.show = true if (value) &#123; enter(vnode, () =&gt; &#123; el.style.display = el.__vOriginalDisplay &#125;) &#125; else &#123; leave(vnode, () =&gt; &#123; el.style.display = 'none' &#125;) &#125; &#125; else &#123; el.style.display = value ? el.__vOriginalDisplay : 'none' &#125; &#125;, unbind (el,binding,vnode,oldVnode,isDestroy)&#123; if (!isDestroy) &#123; el.style.display = el.__vOriginalDisplay &#125; &#125;&#125; 从上述代码可以看到，v-show 指令仅仅是通过调用 DOM.style.display 的值来显示和隐藏DOM元素。 参考文章 https://cn.vuejs.org/v2/guide/conditional.html#v-if https://mp.weixin.qq.com/s/9CtghxcWPDZYIOiCjaYDcQ 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术(FrontGeek)，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/categories/面试/"},{"name":"面试","slug":"前端/面试","permalink":"http://www.chenhanpeng.com/categories/前端/面试/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.chenhanpeng.com/tags/vue/"},{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/tags/面试/"}]},{"title":"聊一聊JavaScript类型判断的四种方法","slug":"javascript/聊一聊JavaScript类型判断的四种方法","date":"2021-01-20T12:09:02.000Z","updated":"2021-04-21T01:17:31.607Z","comments":true,"path":"javascript-methods-of-judging-data-type/","link":"","permalink":"http://www.chenhanpeng.com/javascript-methods-of-judging-data-type/","excerpt":"","text":"前言在web开发中，我们经常碰到需要判断数据是数字还是字符串，判断是数组还是对象的场景，接下来我们一起来看看JavaScript中都有哪些方法可以判断数据类型。 欢迎关注我的微信公众号：前端极客技术(FrontGeek) typeof在JS中，我们最常用的判断方法自然是typeof。 typeof：是一元操作符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。 在ES5中，JavaScript有六种数据类型：Number、String、Boolean、Undefined、Null、Object。ES6新增了一种数据类型：Symbol。 我们先用typeof对上面七种数据类型的值进行运算，看得到的结果是什么样的：12345678console.log(typeof 1) // numberconsole.log(typeof 'test') // stringconsole.log(typeof true) // booleanconsole.log(typeof undefined) // undefinedconsole.log(typeof null) // objectconsole.log(typeof &#123;&#125;) // objectconsole.log(typeof []) // objectconsole.log(typeof Symbol()) // symbol 从执行结果我们可以看出，null、对象都返回object，其他的都返回和数据类型对应的小写字符串。 在JS中，Object类型下还细分很多类型，比如Array、Function、Date、Error等等，我们也用typeof尝试判断这几种类型：12345678console.log(typeof []) // objectfunction a()&#123;&#125;console.log(typeof a) // functionlet now = new Date()console.log(typeof now) // objectlet error = new Error()console.log(typeof error) // object typeof可以检测出函数类型，其他类型返回的都是object，没办法确实是哪一种细分类型。 instanceofinstanceof操作符用于检查一个对象是否属于某个特定的class。同时它还考虑了继承。 用法如下：1A instanceof B 表示判断A是否为B的实例，如果是返回true，否则返回false。 我们先来看下几个关于instanceof的例子：12345678910console.log([] instanceof Array) // trueconsole.log([] instanceof Object) // trueconsole.log(&#123;&#125; instanceof Object) // trueconsole.log(new Date() instanceof Date) // truefunction a ()&#123;&#125;console.log(a instanceof Function) // trueconsole.log(new a() instanceof a) // true 从上面我们可以发现一个问题，instanceof虽然可以判断出[]是Array的实例，但它也认为 []是Object的实例。 我们简单分析下[]、Array、Object三者的关系： [].proto 指向 Array.prototype，而 Array.prototype.proto 又指向 Object.prototype，最终 Object.prototype.proto 指向null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链。 我们从原型链可以看出，[] 的 proto 直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此： instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 constructor对于对象子类型的判断，除了instanceof，我们还可以利用对象的constructor属性来进行判断。 constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。所以，修改原型对象时，一般要同时修改constructor属性的指向。 12345678console.log('22'.constructor === String) // trueconsole.log(true.constructor === Boolean) // trueconsole.log([].constructor === Array) // trueconsole.log(new Number(22).constructor === Number) // trueconsole.log(new Function().constructor === Function) // trueconsole.log((new Date()).constructor === Date) // trueconsole.log(new RegExp().constructor === RegExp) // trueconsole.log(new Error().constructor === Error) // true 在使用constructor时我们需要注意以下几点： null 和 undefined 没有构造函数，因此不会有constructor的存在，这两种类型需要通过其他方式判断； 函数的constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object Object.prototype.toStringtoString()是Object的原型方法，调用该方法，默认返回当前对象的[[Class]]。[[Class]]是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于Object对象，直接调用toString方法就能返回[object Object]，而对于其他对象，需要通过call/apply来调用才能返回正确的类型信息。 我们来看个demo：12345678910111213141516171819console.log(Object.prototype.toString.call('')) // [object String]console.log(Object.prototype.toString.call(1)) // [object Number]console.log(Object.prototype.toString.call(true)) // [object Boolean]console.log(Object.prototype.toString.call(Symbol())) //[object Symbol]console.log(Object.prototype.toString.call(undefined)) // [object Undefined]console.log(Object.prototype.toString.call(null)) // [object Null]console.log(Object.prototype.toString.call(new Function())) // [object Function]console.log(Object.prototype.toString.call(new Date())) // [object Date]console.log(Object.prototype.toString.call([])) // [object Array]console.log(Object.prototype.toString.call(new RegExp())) // [object RegExp]console.log(Object.prototype.toString.call(new Error())) // [object Error]console.log(Object.prototype.toString.call(&#123;&#125;)) // [object Object]console.log(Object.prototype.toString.call(Math)) // [object Math]console.log(Object.prototype.toString.call(JSON)) // [object JSON]function a () &#123; console.log(Object.prototype.toString.call(arguments)) // [object Arguments]&#125;a() Object.prototype.toString 看起来就是一个神器，通用性强，但是相比其他几个方法来说比较繁琐，在实际开发过程中，我们可以对其封装成一个判断类型的函数进行调用。 type API在实际开发过程中，我们不会去检测 Math、JSON和Arguments，所以在isType函数中不考虑。 封装结果如下：12345function isType(value, type) &#123; return Object.prototype.toString.call(value) === `[object $&#123;type&#125;]`&#125;console.log(isType('111', 'String')) // trueconsole.log(isType(null, 'Null')) // true 总结当你想判断一个基本类型的数据时，你可以用typeof去判断，它很简单，而且可靠；当你想判断一个对象属于哪个子类型时，你可以使用instanceof运算符或constructor属性，但是你需要有个预期的类型，不然就要针对每一种类型写不一样的if…else…语句，还有一点需要注意的就是constructor属性可以被修改，所以并不可靠；如果你不嫌代码量多，要求准确且全面，那你可以用Object.prototype.toString.call()进行判断。 文中所有示例代码见：judge-type-of-data 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术(FrontGeek)，我们一起学习一起进步。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"},{"name":"类型判断","slug":"类型判断","permalink":"http://www.chenhanpeng.com/tags/类型判断/"}]},{"title":"JavaScript中的数据结构——栈和队列","slug":"algorithm/JavaScript中的数据结构——栈和队列","date":"2021-01-18T15:04:05.000Z","updated":"2021-01-20T02:10:26.277Z","comments":true,"path":"javascript-stack-and-queue/","link":"","permalink":"http://www.chenhanpeng.com/javascript-stack-and-queue/","excerpt":"","text":"在前面 JavaScript中的数据结构——链表 一文中，我们学习了链表。今天我们一起来学习另外两种数据结构：栈和队列。 栈(Stack)定义栈是一种特殊的列表，限定仅在表尾进行插入和删除操作的线性表。表尾这一端我们称为栈顶，相对地，把另一端称为栈底。 栈遵循后进先出（LIFO）原则进行存储数据，先进入的数据被压入栈底，最后进入的数据在栈顶，需要读取数据的时候从栈顶开始弹出数据。如下图所示： 因为栈的后进先出的特定，因此只能访问在栈顶的元素。 栈的操作主要有两种：入栈和出栈。 栈的实现要实现一个栈，可以用数组或者链表来实现。下面我们用数组的方式来实现栈，代码如下： 123456789101112131415161718192021222324252627class Stack &#123; constructor() &#123; this.data = []; &#125; // 入栈 push(item) &#123; this.data.push(item); &#125; // 出栈 pop() &#123; // 如果栈为空，直接返回null if(this.data.length === 0) &#123; return null; &#125; return this.data.pop() &#125; // 清空栈 clear()&#123; this.data = []; &#125; get length()&#123; return this.data.length; &#125;&#125; 队列(Queue)定义队列和栈有点像，它们都是线性表，元素都是有序的。 但是和栈不同的是，队列遵循的是先进先出（FIFO）的原则，也就是从尾部添加元素，从头部移除元素，最新添加的元素必须排列在队列的末尾。 队列的主要操作有：往队列中插入新的元素和删除最早加入的元素。 队列的实现队列同样可以用数组或链表来实现。下面我们还是用数组的方式来实现，代码如下：12345678910111213141516171819202122class Queue &#123; constructor () &#123; this.data = []; &#125; // 入栈 enqueue(item) &#123; this.data.push(item) &#125; // 出栈 dequeue() &#123; if (this.data.length === 0) &#123; return null &#125; return this.data.shift() &#125; clear()&#123; this.data = [] &#125; get length()&#123; return this.data.length &#125;&#125; 总结栈遵循的是后进先出原则，队列遵循的是先进先出原则。 栈的队列实现起来还是相对比较简单，它们是用来帮我们组织数据的。比如下面两个实际开发场景： 使用堆栈来组织数据，实现文本编辑器的撤销操作； 使用队列处理数据，实现浏览器的事件循环处理事件。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.chenhanpeng.com/categories/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.chenhanpeng.com/tags/数据结构/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://www.chenhanpeng.com/tags/栈和队列/"}]},{"title":"JavaScript中的数据结构—链表","slug":"algorithm/JavaScript中的数据结构—链表","date":"2021-01-17T04:17:31.000Z","updated":"2021-01-18T02:33:53.426Z","comments":true,"path":"javascript-linked-list/","link":"","permalink":"http://www.chenhanpeng.com/javascript-linked-list/","excerpt":"","text":"前言数据结构与算法在前端开发工程师的日常工作中也许不常用，但在这对前端工程师要求日益提高的时代，如果对数据结构、算法思维、代码效率等知识拥有足够的储备，那么我们将拥有更强的竞争力。 话不多说，我们接下来学习一种数据结构：链表(Linked list)。 链表数组对于每个开发来说是非常熟悉的一种数据结构。链表是一种比数组稍微复杂一点的数据结构，掌握起来也比数组稍难一些。 链表是一种与数组类似的线性数据结构，但与数组的元素存储在特定的内存位置或索引中不同，链表的每个元素都是独立的对象，它包含一个指向该列表中下一个对象的指针或链接。 链表的每个元素（我们通常称为节点）包含两项： 存储的数据：数据可以是任何有效的数据类型。 指针：到下一节点的链接 链表的结构可以由很多种，它可以是单链表或双链表，也可以是已排序的或未排序的，环形的或非环形的。如果一个链表是单向的，那么链表中的每个元素没有指向前一个元素的指针。已排序的和未排序的链表较好理解。常见的有：单向链表、双向链表、单向循环链表和双向循环链表。 从上图我们可以看出，循环链表和单链表的区别在于：单链表的尾元素指向的Null，而循环链表的尾元素指向的是链表的头部元素。 欢迎关注我的微信公众号：前端极客技术(FrontGeek) 单向链表链表和数组一样，也支持数据的查找、插入和删除。 由于链表是非连续的，想要访问第i个元素就不像数组那么方便，而是需要根据指针一个节点一个节点一次遍历，直到找到相应的节点。 因为链表的数据本身是非连续的空间，所以它的插入或删除操作，不需要像数组那边挪动原来的数据，因此在链表中插入数据、删除数据是非常快的。 设计链表我们设计链表包含两个类：一个是Node类用来表示节点；另一个是LinkedList类提供插入节点、删除节点等操作。 头结点head的next初始化为null，每当调用插入方法时，next就会指向新的元素 Node 123456class Node &#123; constructor(el) &#123; this.el = el; this.next = null; &#125;&#125; LinkedList 1234567891011121314class LinkedList &#123; constructor()&#123; this.head = new Node('head') &#125; // 用于查找 find()&#123;&#125; // 插入节点 insert()&#123;&#125; // 删除节点 remove()&#123;&#125;&#125; 查找从头结点开始查找，如果没找到就把当前指针往后移，找到就返回该元素，如果遍历完没找到就直接返回null。 代码实现如下：1234567find(item)&#123; let currentNode = this.head while (currentNode !== null &amp;&amp; currentNode.el !== item) &#123; currentNode = currentNode.next; &#125; return currentNode&#125; 插入新节点要往链表中插入新节点，需要知道在哪个节点后面插入。那么我们就需要知道在哪里插入和插入的元素是什么。 知道在哪个节点后面插入后，首先我们要先找到这个节点的位置，这里我们就可以用上面实现的查找方法。 找到节点后，我们先创建一个新节点，把新节点的next指针指向找到的这个节点next指向的对应节点，再把找到的这个节点的next指针指向新节点，数据的插入就完成了。具体过程如下图所示： 代码实现如下：123456789// 插入节点 // el:要插入的数据 // item：数据插入到这个节点后面 insert(el, item)&#123; const newNode = new Node(el) const cur = this.find(item) newNode.next = cur.next cur.next = newNode &#125; 删除节点删除节点和插入节点类似，首先要找到相应节点的前一个节点，找到后，让它的next指向待删除节点的下一个节点。如下图所示： 代码实现如下：123456789101112131415findPre(item) &#123; let cur = this.head while (cur.next !== null &amp;&amp; cur.next.el !== item) &#123; cur = cur.next &#125; return cur&#125;// 删除节点remove(item)&#123; const preNode = this.findPre(item) if (preNode.next !== null) &#123; preNode.next = preNode.next.next &#125;&#125; 单向链表完整代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 单项链表// 节点class Node &#123; constructor(el) &#123; this.el = el; this.next = null; &#125;&#125;class LinkedList &#123; constructor()&#123; this.head = new Node('head') &#125; // 用于查找 find(item)&#123; let currentNode = this.head while (currentNode !== null &amp;&amp; currentNode.el !== item) &#123; currentNode = currentNode.next; &#125; return currentNode &#125; findPre(item) &#123; let cur = this.head while (cur.next !== null &amp;&amp; cur.next.el !== item) &#123; cur = cur.next &#125; return cur &#125; // 插入节点 // el:要插入的数据 // item：数据插入到这个节点后面 insert(el, item)&#123; const newNode = new Node(el) const cur = this.find(item) newNode.next = cur.next cur.next = newNode &#125; // 删除节点 remove(item)&#123; const preNode = this.findPre(item) if (preNode.next !== null) &#123; preNode.next = preNode.next.next &#125; &#125;&#125; 双向链表双向链表，顾名思义就是它有两个方向，除了next指针指向下一个节点外，比单向链表多了一个prev指针，用来指向上一个节点。 双向链表如下图所示： 和单向链表相比，在存储相同的数据情况下，双向链表要比单向链表占用更多的空间，但双向链表往往会比单向链表更加灵活。例如： 双向链表删除节点时，因为有prev指向上一个节点，就不需要像单向链表一样去寻找待删除节点的前驱节点，使得删除节点的效率提高了。 接下来我们来看下如何实现双向链表： 双向链表的设计对于节点类，我们只要在单向链表的基础上，加上一个prev指针。 1234567class Node &#123; constructor(el) &#123; this.el = el this.next = null this.prev = null &#125;&#125; 另外双向链表的查找和单向链表一样，这里就不再细说，我们直接来看下插入节点。 插入双向链表的插入和单向链表相似，多了一个prev指针，只要将新节点的prev指向前驱节点，将后驱节点的prev指向新节点。如下图所示： 实现代码如下：12345678insert(el, item)&#123; const newNode = new Node(el) const cur = this.find(item) newNode.next = cur.next newNode.prev = cur cur.next = newNode cur.next.prev = newNode &#125; 删除双向链表的删除 remove 方法比单链表效率高，不需要查找前驱节点，只要找出待删除节点，然后将该节点的前驱 next 属性指向待删除节点的后继，设置该节点后继 previous 属性，指向待删除节点的前驱即可。 实现代码如下：1234567remove(item)&#123; const node = this.find(item) node.prev.next = node.next node.next.prev = node.prev node.next = null node.prev = null &#125; 双向链表完整代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344// 双向链表class Node &#123; constructor(el) &#123; this.el = el this.next = null this.prev = null &#125;&#125;class LinkedList &#123; constructor()&#123; this.head = new Node('head') &#125; // 用于查找 find(item)&#123; let currentNode = this.head while (currentNode !== null &amp;&amp; currentNode.el !== item) &#123; currentNode = currentNode.next; &#125; return currentNode &#125; // 插入节点 // el:要插入的数据 // item：数据插入到这个节点后面 insert(el, item)&#123; const newNode = new Node(el) const cur = this.find(item) newNode.next = cur.next newNode.prev = cur cur.next = newNode cur.next.prev = newNode &#125; // 删除节点 remove(item)&#123; const node = this.find(item) node.prev.next = node.next node.next.prev = node.prev node.next = null node.prev = null &#125;&#125; 单向循环链表单向循环链表和单向链表相似，节点类型都一样，唯一的区别就是在创建循环链表的时候，让其头结点的next属性指向它本身。1head.next = head 单向循环链表如上图所示，具体的实现细节不再一一细说，我们直接来看实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Node &#123; constructor(el) &#123; this.el = el; this.next = null; &#125;&#125;class LinkedList &#123; constructor()&#123; this.head = new Node('head') this.head.next = this.head &#125; // 用于查找 find(item)&#123; let currentNode = this.head while (currentNode !== null &amp;&amp; currentNode.el !== item) &#123; currentNode = currentNode.next; &#125; return currentNode &#125; findPre(item) &#123; let cur = this.head while (cur.next !== null &amp;&amp; cur.next.el !== item) &#123; cur = cur.next &#125; return cur &#125; // 插入节点 // el:要插入的数据 // item：数据插入到这个节点后面 insert(el, item)&#123; const newNode = new Node(el) const cur = this.find(item) newNode.next = cur.next cur.next = newNode &#125; // 删除节点 remove(item)&#123; const preNode = this.findPre(item) if (preNode.next !== null) &#123; preNode.next = preNode.next.next &#125; &#125;&#125; 双向循环链表既然单链表可以有循环链表，双向链表也可以是循环链表。双向循环链表头结点的prev指针指向尾结点，尾结点的next指针指向头结点。如下图所示： 实现代码如下：12 本文所有示例代码见：linked-list 参考文章： JavaScript数据结构之链表–介绍 JS中的算法与数据结构——链表(Linked-list)","categories":[{"name":"算法","slug":"算法","permalink":"http://www.chenhanpeng.com/categories/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.chenhanpeng.com/tags/数据结构/"},{"name":"链表","slug":"链表","permalink":"http://www.chenhanpeng.com/tags/链表/"}]},{"title":"聊一聊浏览器本地存储","slug":"fe/聊一聊浏览器本地存储","date":"2021-01-17T04:17:12.000Z","updated":"2021-01-18T02:33:53.427Z","comments":true,"path":"local-storage-of-browser/","link":"","permalink":"http://www.chenhanpeng.com/local-storage-of-browser/","excerpt":"","text":"前言作为一名前端工程师，我们每天都在跟浏览器打交道，浏览器的本地存储更是经常用到。今天我们就一起来聊一聊浏览器的本地存储。 浏览器的本地存储主要分为：Cookie、 WebStorage、 IndexedDB。其中WebStorage又可以分为localStorage和sessionStorage。 CookieHTTP Cookie，通常叫做Cookie，一开始是在客户端用于存储会话信息的。 Cookie主要构成 name：名称，一个唯一确定的cookie的名称，cookie的名称必须经过URL编码。 value：值，存储在cookie中的字符串值。值必须被URL编码。 Domain：域，指明cookie对哪个域有效，所有向该域发送的请求都会包含这个信息。 path：路径，对于指定域中的那个路径，应该向服务器发送cookie。 Expires/Max-Age：有效期，表示cookie的有效期。 HttpOnly：如果这个这个值设置为true，就不能通过JS脚本获取cookie的值。通过这个值可以有效防止XSS攻击。 Secure：安全标志，指定后，cookie只有在使用SSL连接的时候才能发送到服务器。 Cookie的原理第一次访问网站时，浏览器发出请求，服务器响应请求后，会在响应头中添加一个Set-Cookie，将cookie放入响应请求中。 在第二次发起请求时，浏览器通过Cookie请求头部将cookie信息送给服务器，服务端根据cookie信息辨别用户身份。 Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。 Cookie的生成Cookie的生成方式主要有两种： 服务端设置Cookie 客户端设置Cookie 服务端设置方式参考上面Cookie的原理，具体的实现方式自行查阅相关资料。客户端设置Cookie方法如下：1document.cookie = \"name=zhangsan; age=20\"; Cookie的缺点 每个特定域名下的cookie数量有限，不同浏览器数量限制不同。如果超过数量限制后再设置Cookie，浏览器就会清除以前设置的Cookie。 大小只有4kb。 每次HTTP请求都会默认带上Cookie，影响获取资源的效率。 Cookie的获取、设置、删除方法需要我们自己去封装。 Web StorageWeb Storage分为localStorage和sessionStorage。 localStoragelocalStorage以键值对的方式存储，永久存储，永不失效，除非手动删除。 localStorage有以下几个特点： 保持的数据永久有效，除非手动删除； 大小为5M 仅在客户端使用，不和服务端进行通信 接口封装较好 使用方法：12345678910// 设置localStorage.setItem('name', '张三')localStorage.age = '25'// 取值localStorage.getItem('name')let age = localStorage.age// 移除localStorage.removeItem('name')// 移除所有localStorage.clear() sessionStoragesessionStorage对象存储特定于某个会话的数据，当这个会话的页签或浏览器关闭，sessionStorage也就消失了。 页面刷新之后，存储在sessionStorage中的数据仍然存在可用。 sessionStorage的特点： 会话级别的浏览器存储 大小为5M 仅在客户端使用，不和服务端通信 接口封装较好 使用方法：12345678910// 设置sessionStorage.setItem('name', '张三')sessionStorage.age = '25'// 取值sessionStorage.getItem('name')let age = sessionStorage.age// 移除sessionStorage.removeItem('name')// 移除所有sessionStorage.clear() sessionStorage和localStorage的区别：localStorage的数据可以长期保留，sessionStorage的数据在关闭页面后即被清空。 IndexedDBIndexedDB，全称Indexed Database API，是浏览器中保持结构化数据的一种数据库。 IndexedDB的思想是创建一套API，方便保存和读取JavaScript对象，同时支持查询和搜索。 IndexedDB特点 键值对存储：IndexedDB采用对象仓库存储数据，可以存储所有类型的数据。仓库中数据以键值对的形式保持。 异步：IndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作。 支持事务：有学过数据库的对事务肯定不陌生。事务意味着在一系列操作中，只要有一步失败，整个事务就都取消，数据库回滚到事务执行之前，不存在只改写一部分数据的情况。 同源限制：IndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。 储存空间大: IndexedDB 的储存空间比 localStorage大得多，一般来说不少于 250MB，甚至没有上限。 支持二进制储存: IndexedDB不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。 IndexedDB的入门教程，可以查看阮一峰老师的文章：浏览器数据库 IndexedDB 入门教程 总结 Cookie主要用于“维持状态”，而非本地存储数据 Web Storage是专门为浏览器提供的数据存储机制，不与服务端发生通信 IndexedDB 用于客户端存储大量结构化数据","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://www.chenhanpeng.com/tags/浏览器/"},{"name":"本地存储","slug":"本地存储","permalink":"http://www.chenhanpeng.com/tags/本地存储/"}]},{"title":"JavaScript设计模式—单例模式","slug":"javascript_design_pattern/JavaScript设计模式—单例模式","date":"2021-01-17T04:16:40.000Z","updated":"2021-01-18T02:33:53.428Z","comments":true,"path":"javascript-singleton-pattern/","link":"","permalink":"http://www.chenhanpeng.com/javascript-singleton-pattern/","excerpt":"","text":"在上一篇文章《JavaScript设计模式——工厂模式》中我们一起学习了工厂模式，接下来我们一起来学习另一种设计模式——单例模式。 定义单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点。无论创建多少次，都只返回第一次所创建的那唯一的一个实例。 单例模式是创建型设计模式的一种。针对全局仅需一个对象的场景。 欢迎关注我的微信公众号：前端极客技术(FrontGeek) 实现思路在JavaScript中，我们如何才能保证一个类只有一个实例？ 正常情况下，我们创建了一个类（本质上是构造函数），可以通过new关键字调用构造函数进而生成任意多个实例对象，例如： 123456789class SingleLoading &#123; show () &#123; console.log('这是一个单例Loading') &#125;&#125;let loading1 = new SingleLoading()let loading2 = new SingleLoading()console.log(loading1 === loading2) // false 上述代码中，我们先后new了loading1和loading2两个实例对象，两者是相互独立的对象，各占一块内存空间。 而单例模式想要做的，是不论我们创建多少次，它都只返回第一次创建的那唯一一个实例给你。 要实现上面的这一点，就需要构造函数具备判断自己是否已经创建过实例的能力。 现在我们将判断逻辑写成一个静态方法或直接写入构造函数的函数体内。 实现方式单例模式的实现方式主要有两种：静态方法和闭包。 静态方法实现下面我们用静态方法将上面的例子改造成单例模式： 1234567891011121314151617// 静态方法的实现class SingleLoading &#123; show () &#123; console.log('这是一个单例Loading') &#125; static getInstance()&#123; // 判断是否已经创建过实例 if (!SingleLoading.instance) &#123; // 将创建的实例对象保持下来 SingleLoading.instance = new SingleLoading() &#125; return SingleLoading.instance &#125;&#125;const loading1 = SingleLoading.getInstance()const loading2 = SingleLoading.getInstance()console.log(loading1 === loading2) // true 上面代码中有一个static关键字，在getInstance方法前加上static，表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 闭包getInstance的逻辑还可以用闭包的方式实现： 12345678910111213141516171819202122// 闭包// 闭包class SingleLoading &#123; show () &#123; console.log('这是一个单例Loading') &#125;&#125;SingleLoading.getInstance = (function()&#123; // 定义自由变量instance，模拟私有变量 let instance = null return function()&#123; if(!instance) &#123; // 如果为null则new出唯一实例 instance = new SingleLoading() &#125; return instance &#125;&#125;)();const loading3 = new SingleLoading().getInstance()const loading4 = new SingleLoading().getInstance()console.log(loading3 === loading4) 借助闭包，在内存中保留了 instance 变量，不会被垃圾回收，用来保存唯一的实例，多次调用 new 的时候，只返回第一次创建的实例。 真题练习我们已经学习了用静态方法和闭包来实现单例模式，接下来我们通过一道经典的面试题来巩固。 实现一个全局唯一的模态框（Modal弹框） 代码实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;单例模式弹框&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #modal &#123; height: 200px; width: 200px; line-height: 200px; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); border: 1px solid #999; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;button id=\"open\"&gt;打开弹窗&lt;/button&gt; &lt;button id=\"close\"&gt;关闭弹窗&lt;/button&gt;&lt;/body&gt;&lt;script&gt; const Modal = (function()&#123; let modal = null; return function() &#123; if (!modal) &#123; modal = document.createElement('div') modal.innerHTML = '全局唯一的modal弹窗' modal.id = 'modal' modal.style.display = 'none' document.body.appendChild(modal) &#125; return modal &#125; &#125;)() document.getElementById('open').addEventListener('click', function ()&#123; const modal = new Modal() modal.style.display = 'block' &#125;) document.getElementById('close').addEventListener('click', function ()&#123; const modal = new Modal() modal.style.display = 'none' &#125;)&lt;/script&gt;&lt;/html&gt; 上面采用的是闭包的方法实现的，你也可以自己尝试用静态方法来实现。 总结单例模式的核心：确保一个类只有一个实例。 对于单例模式的实现，如果采用class来实现，记住getInstance静态方法；如果采用闭包来实现，记住instance变量。 在许多优秀的前端库里，我们都能看到单例模式的身影。比如：Vuex和Redux这两个状态管理的库，它们都实现了一个全局的Store用于存储应用的所有状态。这个Store的实现，就是单例模式的典型应用。感兴趣的可以自己下载相应的源码研究一下。 最后，总结一下单例模式的优缺点： 优点：适用于单一对象，只生成一个对象实例，避免频繁创建和销毁实例，减少内存占用。 缺点：不适用动态扩展对象，或需创建多个相似对象的场景。 文章示例代码见：singleton-pattern 参考文章 JavaScript 设计模式（一）：单例模式 JavaScript 设计模式核⼼原理与应⽤实践 如果你觉得这篇内容对你有帮助的话： 1、点赞支持下吧，让更多的人也能看到这篇内容 2、关注公众号：前端极客技术(FrontGeek)，我们一起学习一起进步。 实现一个Storage 实现Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。 123456789101112131415161718192021222324252627282930313233343536373839404142// 静态方法class Storage &#123; static getInstance ()&#123; if (!Storage.instance) &#123; Storage.instance = new Storage() &#125; return Storage.instance &#125; getItem(key) &#123; return localStorage.getItem(key) &#125; setItem(key, value) &#123; return localStorage.setItem(key, value) &#125;&#125;// 闭包// 先实现一个基础的StorageBase类，将getItem和setItem放在它的原型上function StorageBase()&#123;&#125;StorageBase.prototype.getItem = function (key) &#123; return localStorage.getItem(key)&#125;StorageBase.prototype.setItem = function (key, value) &#123; return localStorage.setItem(key, value)&#125;// 以闭包的形式创建一个引用自由变量的构造函数const Storage = (function()&#123; let instance = null; return function()&#123; if(!instance) &#123; instance = new StorageBase() &#125; return instance &#125;&#125;)()const s1 = new Storage()const s2 = new Storage()s1.setItem('name', 'zhangsan')s1.getItem('name')s2.getItem('name')console.log(s1 === s2) Vuex中的单例模式Vuex：实现了一个全局的store用来存储应用的所有状态。这个store的实现就是单例模式的典型应用。 Vuex中如何确保store的唯一性项目引入vuex的方式：12345678// 安装插件Vue.use(Vuex)// 将store注入到vue实例new Vue(&#123; el: '#app', store&#125;) vuex内部的install方法：123456789101112131415161718let Vue // 这个Vue的作用和楼上的instance作用一样...export function install (_Vue) &#123; // 判断传入的Vue实例对象是否已经被install过Vuex插件（是否有了唯一的state） if (Vue &amp;&amp; _Vue === Vue) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) &#125; return &#125; // 若没有，则为这个Vue实例对象install一个唯一的Vuex Vue = _Vue // 将Vuex的初始化逻辑写进Vue的钩子函数里 applyMixin(Vue)&#125; 如果vuex的install没有实现单例，假如中途重新install，会为当前的Vue实例重新注入一个新的store，前面操作的数据全部没了。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.chenhanpeng.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.chenhanpeng.com/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"http://www.chenhanpeng.com/tags/单例模式/"}]},{"title":"JavaScript设计模式——工厂模式","slug":"javascript_design_pattern/JavaScript设计模式——工厂模式","date":"2021-01-13T15:37:21.000Z","updated":"2021-01-14T01:28:01.445Z","comments":true,"path":"javascript-factory-pattern/","link":"","permalink":"http://www.chenhanpeng.com/javascript-factory-pattern/","excerpt":"","text":"在瞬息万变的前端领域，技术更新迭代非常快，我们经常能在网络上看到诸如“学不动了”之类的言论。但是作为一名前端开发工程师，除了各种新技术，还有许多“一次学习，终身受益”的知识值得我们花时间去学习，设计模式就是其中之一。 设计模式在学习设计模式之前，我们先要知道什么是设计模式。 我们先来看下维基百科上关于设计模式的定义： 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 设计模式并不是一种固定的公式，而是一种思想，是一种解决问题的思路；恰当的使用设计模式，可以实现代码的复用和提高可维护性。 SOLID设计原则设计原则是设计模式的知道理论，可以帮助我们规避不良的软件设计。SOLID指代的五个基本原则分别是： 单一功能原则(Single Responsibiity Principle) 一个程序只做好一件事 如果功能过于复杂就拆分开，每个部分保持独立 开放封闭原则(Opened Closed Principle) 对扩展开放，对修改封闭 增加需求时，扩展新代码，而非修改已有代码 里氏替换原则(Liskov Substitution Principle) 子类能覆盖父类 父类能够出现的地方子类就能出现 接口隔离原则(Interface Segregation Principle) 保持接口的单一独立 类似单一职责原则，这里更关注接口 依赖反转原则(Dependency Inversion Principle) 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口而不关注具体类的实现 Javascript设计模式中，主要用到的设计模式基本都是围绕单一功能和开放封闭两个原则展开的。 设计模式分类设计模式有23种，可以按照创建型、行为型、结构型划分成三类，具体见下图： 针对这23中设计模式，我们将选一些比较重要、实际开发中能用到、面试中常见的来详细学习。 欢迎关注我的微信公众号：前端极客技术(FrontGeek) 下面我们先来学习工厂模式： 工厂模式工厂模式是用来创建对象的一种最常用的设计模式。所谓工厂模式就是将创建对象的过程单独封装。 工厂模式根据抽象程度的不同可以分为： 简单工厂模式（Simple Factory） 工厂方法模式（Factory Method） 抽象工厂模式（Abstract Factory） 这里我们要先理解什么是抽象。 抽象：将复杂事物的一个或多个共有特征抽取出来的思维过程。 简单工厂模式简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例。 假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致。 代码如下： 1234567891011121314151617181920212223242526272829function Factory(career) &#123; function User(career, work) &#123; this.career = career this.work = work &#125; let work switch(career) &#123; case 'coder': work = ['写代码', '修Bug'] return new User(career, work) break case 'hr': work = ['招聘', '员工信息管理'] return new User(career, work) break case 'driver': work = ['开车'] return new User(career, work) break case 'boss': work = ['喝茶', '开会', '审批文件'] return new User(career, work) break &#125;&#125;let coder = new Factory('coder')console.log(coder)let boss = new Factory('boss')console.log(boss) Factory就是一个简单工厂。当我们调用工厂函数时，只需要传递name、age、career就可以获取到包含用户工作内容的实例对象。 简单工厂的优点就是我们只要传递正确的参数，就能获得所需的对象，而不需要关心其创建的具体细节。 应用场景也非常容易识别：有构造函数的地方，就应该想到简单工厂；在写了大量构造函数、调用了大量的new、自觉非常不爽的情况下，就应该思考是不是可以掏出工厂模式重构代码。 但是也不是所有情况都能简单工厂。比如：在函数内包含了所有对象的创建逻辑和判断逻辑代码，每增加新的构造函数还需要修改判断逻辑代码。如果我们的岗位不止上面的四个，而是1000个甚至更多，那么这个函数就会变得非常庞大，使得代码难以维护。所以简单工厂模式只能作用于创建的对象比较少，对象的创建逻辑不复杂时使用。 工厂方法模式工厂方法模式是将创建对象的工作推到子类中进行，这样核心类就变成了抽象类。 也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产；但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产，如果不行，那么要么新建工厂生产要么就生产不了。 我们可以将工厂方法看作是一个实例化对象的工厂类。 我们对上面简单工厂模式的代码进行改造，刚才提到将工厂方法看作一个实例化对象的工厂，它只做实例化对象这一件事情。1234567891011121314151617181920212223242526272829303132// 工厂方法function Factory(career)&#123; if(this instanceof Factory)&#123; var a = new this[career](); return a; &#125;else&#123; return new Factory(career); &#125;&#125;// 工厂方法函数的原型中设置所有对象的构造函数Factory.prototype=&#123; 'coder': function()&#123; this.careerName = '程序员' this.work = ['写代码', '修Bug'] &#125;, 'hr': function()&#123; this.careerName = 'HR' this.work = ['招聘', '员工信息管理'] &#125;, 'driver': function () &#123; this.careerName = '司机' this.work = ['开车'] &#125;, 'boss': function()&#123; this.careerName = '老板' this.work = ['喝茶', '开会', '审批文件'] &#125;&#125;let coder = new Factory('coder')console.log(coder)let hr = new Factory('hr')console.log(hr) 使用工厂方法改造之后，如果我们需要添加新的岗位信息，只要在Factory.prototype中添加。 工厂方法关键核心代码是工厂里面的判断this是否属于工厂，也就是做了分支判断，这个工厂只做我能做的产品，如果你的产品我目前做不了，请找其他工厂代加工。 抽象工厂模式上面介绍了简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建。 通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的。 我们还是来看上面的例子：例子中有coder、hr、boss、driver四种岗位，其中coder可能使用不同的开发语言进行开发，比如JavaScript、Java等等。那么这两种语言就是对应的类簇。 在抽象工厂中，类簇一般用父类定义，并在父类中定义一些抽象方法，再通过抽象工厂让子类继承父类。所以，抽象工厂其实是实现子类继承父类的方法。 抽象方法：指声明但不能使用的方法。在Javascript中，abstract是保留字，我们一般通过在类的方法中抛出错误来模拟抽象类。 例如：123456let JavaCoder = function ()&#123;&#125;JavaCoder.prototype = &#123; getCareerName: function()&#123; return new Error('抽象方法不能调用') &#125;&#125; 上面代码中的getCareerName就是抽象方法，我们虽然定义了它，但没有去实现。如果子类继承了父类，但没有去重写getCareerName，那么子类的实例化对象会调用父类的getCareerName方法并抛出错误提示。 下面我们先来实现岗位管理的抽象工厂方法：1234567891011121314151617181920212223242526272829303132333435let CareerAbstractFactory = function(subType, superType) &#123; // 判断抽象工厂中是否有该抽象类 if (typeof CareerAbstractFactory[superType] === 'function') &#123; // 缓存类 function F() &#123;&#125; // 继承父类属性和方法 F.prototype = new CareerAbstractFactory[superType]() // 将子类的constructor指向父类 subType.constructor = subType; // 子类原型继承父类 subType.prototype = new F() &#125; else &#123; throw new Error('抽象类不存在') &#125;&#125;// JavaScript开发者抽象类CareerAbstractFactory.JavaScriptCoder = function ()&#123; this.language = 'javascript'&#125;CareerAbstractFactory.JavaScriptCoder.prototype = &#123; getCareerName: function()&#123; return new Error('抽象方法不能调用') &#125;&#125;// Java开发者抽象类CareerAbstractFactory.JavaCoder = function()&#123; this.language = 'java'&#125;CareerAbstractFactory.JavaCoder.prototype = &#123; getCareerName: function()&#123; return new Error('抽象方法不能调用') &#125;&#125; 上面代码中CareerAbstractFactory就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承。对抽象工厂方法添加抽象类的方法我们是通过点语法进行添加的。 接下来我们来定义coder的子类：1234567891011121314151617181920212223// JavaScriptCoder的子类function CoderOfJavaScript (careerName) &#123; this.careerName = careerName this.work = ['写代码', '修Bug']&#125;// 抽象工厂实现JavaScriptCoder类的继承CareerAbstractFactory(CoderOfJavaScript, 'JavaScriptCoder')// 重写抽象方法CoderOfJavaScript.prototype.getLanguage = function ()&#123; return this.careerName;&#125;function CoderOfJava (careerName) &#123; this.careerName = careerName this.work = ['写代码', '修Bug']&#125;// 抽象工厂实现JavaScriptCoder类的继承CareerAbstractFactory(CoderOfJava, 'JavaCoder')// 重写抽象方法CoderOfJava.prototype.getLanguage = function ()&#123; return this.careerName;&#125; 上面我们分别定义了CoderOfJavaScript、CoderOfJava两种类。这两个类作为子类通过抽象工厂方法实现继承。特别需要注意的是，调用抽象工厂方法后不要忘记重写抽象方法，否则在子类的实例中调用抽象方法会报错。 接下来我们进行实例化，检测抽象工厂方法是否实现了类簇的管理。 123456789let javaCode1 = new CoderOfJava('Java后端开发')console.log(javaCode1.getCareerName(), javaCode1.language)let javaCode2 = new CoderOfJava('Java大数据开发')console.log(javaCode2.getCareerName(), javaCode2.language)let javascriptCoder1 = new CoderOfJavaScript('前端开发')console.log(javascriptCoder1.getCareerName(), javascriptCoder1.language);let nodejsCoder = new CoderOfJavaScript('node全栈开发')console.log(nodejsCoder.getCareerName(), nodejsCoder.language) 从结果来看CareerAbstractFactory这个抽象工厂很好地实现了它的作用，将不同岗位按照开发语言这一类簇进行了分类。 抽象工厂的作用：它不直接创建实例，而是通过类的继承进行类簇的管理。 抽象工厂模式一般用于严格要求以面向对象思想进行开发的超大型项目中，我们一般常规的开发的话一般就是简单工厂和工厂方法模式会用的比较多一些 上面的代码我们是用ES5写的，ES6中提供了class语法，虽然class本质上是一颗语法糖，并也没有改变JavaScript是使用原型继承的语言，但是确实让对象的创建和继承的过程变得更加的清晰和易读。有兴趣的可以自己尝试用ES6的新语法重写上面三个例子。 总结工厂模式是属于创建型的设计模式。简单工厂模式又叫静态工厂方法，用来创建某一种产品对象的实例，用来创建单一对象；工厂方法模式是将创建实例推迟到子类中进行；抽象工厂模式是对类的工厂抽象用来创建产品类簇，不负责创建某一类产品的实例。 工厂模式的优点： 创建对象过程可能很复杂，但我们只需要关心创建结果 构造函数和创建者分离，符合“开闭原则” 一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 工厂模式的缺点： 添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度 考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度 适用场景： 如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择 将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式； 需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性 本文中示例代码：工厂模式示例代码 参考文章 JavaScript 设计模式核⼼原理与应⽤实践 JavaScript设计模式es6（23种)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.chenhanpeng.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.chenhanpeng.com/tags/设计模式/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://www.chenhanpeng.com/tags/工厂模式/"}]},{"title":"前端性能指标：白屏和首屏时间的计算","slug":"fe/白屏和首屏时间计算","date":"2021-01-11T16:05:43.000Z","updated":"2021-01-12T07:04:17.372Z","comments":true,"path":"fp-and-fcp/","link":"","permalink":"http://www.chenhanpeng.com/fp-and-fcp/","excerpt":"","text":"前言页面性能优化是前端开发中一个重要的环节，而评判前端性能的优劣有两个比较经常听说的指标：白屏时间和首屏时间。 接下来我们一起来看看什么是白屏时间和首屏时间，如何去计算。 什么是白屏和首屏时间白屏时间(FP)白屏时间(First Paint)：是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。 白屏时间 = 页面开始展示的时间点 - 开始请求的时间点 首屏时间(FCP)首屏时间(First Contentful Paint)：是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。 首屏时间 = 首屏内容渲染结束时间点 - 开始请求的时间点 欢迎关注我的微信公众号：前端极客技术(FrontGeek) 常规计算方式白屏时间白屏时间是从用户开始请求页面时开始计算到开始显示内容结束，中间过程包括DNS查询、建立TCP链接、发送首个HTTP请求、返回HTML文档、HTML文档head解析完毕。 因此影响白屏时间的因素：网络、服务端性能、前端页面结构设计。 通常认为浏览器开始渲染&lt;body&gt;或者解析完&lt;head&gt;的时间是白屏结束的时间点。所以我们可以在html文档的head中所有的静态资源以及内嵌脚本/样式之前记录一个时间点，在head最底部记录另一个时间点，两者的差值作为白屏时间 代码实现：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;白屏时间计算-常规方法&lt;/title&gt; &lt;script&gt; window.pageStartTime = Date.now() &lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"https://b-gold-cdn.xitu.io/ionicons/2.0.1/css/ionicons.min.css\"&gt; &lt;link rel=\"stylesheet\" href=\"https://b-gold-cdn.xitu.io/asset/fw-icon/1.0.9/iconfont.css\"&gt; &lt;script&gt; window.firstPaint = Date.now() console.log(`白屏时间：$&#123;window.firstPaint - window.pageStartTime&#125;`) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;这是常规计算白屏时间的示例页面&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 白屏时间 = window.firstPaint - window.pageStartTime 这个方法有个缺点：无法获取解析HTML文档之前的时间信息。 首屏时间首屏时间要知道两个时间点：开始请求时间点和首屏内容渲染结束时间点。开始请求时间点和白屏时间一样，下面就是如何拿到首屏内容渲染结束时间点。 首屏结束时间应该是页面的第一屏绘制完，但是目前没有一个明确的API可以来直接得到这个时间点，所以我们只能智取，比如我们要知道第一屏内容底部在HTML文档的什么位置，那么这个第一屏内容底部，也称之为首屏线。 现在的问题是：首屏线在哪里？ 实际情况分很多种，不同的场景有不同的计算方式。 标记首屏标签模块这种方式比较简单，通过在HTML文档中，在首屏线的位置添加脚本去获取这个位置的时间。 但是在哪里添加我们只能大约估摸一个位置，以手机屏幕为例，不同型号手机屏幕大小不一样，我们取的位置可能在首屏线上面，也可以在下面，只能得到一个大约的值。 代码实现123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;首屏时间计算-标记首屏标签模块&lt;/title&gt; &lt;script&gt; window.pageStartTime = Date.now() &lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"https://b-gold-cdn.xitu.io/ionicons/2.0.1/css/ionicons.min.css\"&gt; &lt;link rel=\"stylesheet\" href=\"https://b-gold-cdn.xitu.io/asset/fw-icon/1.0.9/iconfont.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;首屏时间计算-标记首屏标签模块&lt;/div&gt; &lt;div class=\"module-1\"&gt;&lt;/div&gt; &lt;div class=\"module-2\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; window.firstScreen = Date.now(); console.log(`首屏时间：$&#123;window.firstScreen - window.pageStartTime&#125;`) &lt;/script&gt; &lt;div class=\"module-3\"&gt;&lt;/div&gt; &lt;div class=\"module-4\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 首屏时间 = window.firstScreen - window.pageStartTime 这种方法的适用场景： 首屏内不需要拉取数据，否则可能拿到首屏线获取时间的时候，首屏还是空白 不需要考虑图片加载，只考虑首屏主要模块 在业务中，较少使用这种算法，大多数页面需要使用接口，所以这种方法就太不常用 但是如果你的页面是静态页面，或者异步数据不影响整体的首屏体验，那么就可以使用这种办法 统计首屏最慢图片加载时间我们知道在一个页面中，图片资源往往是比较后加载完的，因此可以统计首屏加载最慢的图片是否加载完成，加载完了，记录结束时间。 如何知道首屏内哪张图片加载最慢？ 我们可以拿到首屏内所有的图片，遍历它们，逐个监听图片标签的onload事件，并收集到它们的加载时间，最后比较得到加载时间的最大值。 代码实现：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;首屏时间计算-统计首屏最慢图片加载时间&lt;/title&gt; &lt;script&gt; window.pageStartTime = Date.now() &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2021/spring/20210107155629.png\" alt=\"img\" onload=\"load()\"&gt; &lt;img src=\"https://gitee.com/HanpengChen/blog-images/raw/master/blogImages/2020/autumn/article-gzh-qrcode.png\" alt=\"img\" onload=\"load()\"&gt; &lt;script&gt; function load() &#123; window.firstScreen = Date.now() &#125; window.onload = function () &#123; // 首屏时间 console.log(window.firstScreen - window.pageStartTime) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 首屏时间 = window.firstScreen - window.pageStartTime 适用场景： 首屏元素数量固定的页面，比如移动端首屏不论屏幕大小都展示相同数量的内容。 但是对于首屏元素不固定的页面，这种方案并不适用，最典型的就是PC端页面，不同屏幕尺寸下展示的首屏内容不同。上述方案便不适用于此场景。 自定义模块计算法这种算法和标记首屏的方法相似，同样忽略了首屏内图片加载的情况，这个方法主要考虑的是异步数据。 在首屏标签标记法中，是无法计算到异步数据带来的首屏空白的，所以它的适配场景十分有限 自定义模块，就是根据首屏内接口计算比较得出最迟的时间 代码实现：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;首屏时间计算-自定义模块计算法&lt;/title&gt; &lt;script&gt; window.pageStartTime = Date.now() &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"module-1\"&gt;&lt;/div&gt; &lt;div class=\"module-2\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; setTimeout(() =&gt; &#123; // 假设这里异步加载首屏要显示的文章列表数据 window.firstScreen = Date.now(); console.log(window.firstScreen - window.pageStartTime) &#125;, 500) &lt;/script&gt; &lt;div class=\"module-3\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; window.performance上面我们学习了几种常规的计算首屏和白屏时间的方法，其实现在w3c提供了一个用来测量网页和web应用程序的API：window.performance，通过这个API，我们可以更方便获取到相应的时间节点。 这个API在IE9以上的浏览器都支持。 window.performance是一个浏览器中用于记录页面加载和解析过程中关键时间点的对象，放置在global环境下，通过JavaScript可以访问到它。 通过以下代码可以探测和兼容performance：123456var performance = window.performance || window.msPerformance || window.webkitPerformance;if (performance) &#123; // 你的代码&#125; performance属性我们一起来看下performance都有哪些属性： memory：显示此刻内存占用情况，是一个动态值 usedJSHeapSize：JS对象占用的内存数 jsHeapSizeLimit：可使用的内存 totalJSHeapSize：内存大小限制 正常usedJSHeapSize不大于totalJSHeapSize，如果大于，说明可能出现了内存泄漏。 navigation：显示页面的来源信息 redirectCount：表示如果有重定向的话，页面通过几次重定向跳转而来，默认为0 type：表示页面打开的方式。0-正常进入；1-通过window.reload()刷新的页面；2-通过浏览器的前进后退按钮进入的页面；255-非以上方式进入的页面。 onresourcetimingbufferfull：在resourcetimingbufferfull事件触发时会被调用的一个event handler。它的值是一个手动设置的回调函数，这个回调函数会在浏览器的资源时间性能缓冲区满时执行。 timeOrigin：一系列时间点的基准点，精确到万分之一毫秒。 timing：一系列关键时间点，包含网络、解析等一系列的时间数据。 timing中的时间点下面我们来看下timing中的各个时间点： navigationStart：同一个浏览器上一个页面卸载(unload)结束时的时间戳。如果没有上一个页面，这个值会和fetchStart相同 unloadEventStart: 上一个页面unload事件抛出时的时间戳。如果没有上一个页面，这个值会返回0。 unloadEventEnd: 和 unloadEventStart 相对应，unload事件处理完成时的时间戳。如果没有上一个页面,这个值会返回0。 redirectStart: 第一个HTTP重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0 redirectEnd: 最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0 fetchStart: 浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前。 domainLookupStart: DNS 域名查询开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和fetchStart一致。 domainLookupEnd: DNS 域名查询完成的时间。如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 connectStart: HTTP（TCP） 域名查询结束的时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart一致。 connectEnd: HTTP（TCP） 返回浏览器与服务器之间的连接建立时的时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。 secureConnectionStart: HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。 requestStart: 返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。 responseStart: 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。 responseEnd: 返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时。（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳。 domLoading: 当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的 readystatechange事件触发时）的时间戳。 domInteractive: 当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳。 domContentLoadedEventStart: 当解析器发送DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。 domContentLoadedEventEnd: 当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。 domComplete: 当前文档解析完成，即Document.readyState 变为 ‘complete’且相对应的readystatechange 被触发时的时间戳 loadEventStart: load事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是0。 loadEventEnd: 当load事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0 通过上面这些时间点，我们看能计算到哪些时间： 重定向耗时：redirectEnd - redirectStart DNS查询耗时：domainLookupEnd - domainLookupStart TCP链接耗时：connectEnd - connectStart HTTP请求耗时：responseEnd - responseStart 解析dom树耗时：domComplete - domInteractive 白屏时间：responseStart - navigationStart DOM ready时间：domContentLoadedEventEnd - navigationStart onload时间：loadEventEnd - navigationStart 资源性能APIperformance.timing记录的是用于分析页面整体性能指标。如果要获取个别资源（例如JS、图片）的性能指标，就需要使用Resource Timing API。 performance.getEntries()方法，包含了所有静态资源的数组列表；每一项是一个请求的相关参数有name，type，时间等等。 除了performance.getEntries之外，performance还包含一系列有用的方法，比如： performance.now() Performance.getEntriesByName() …. 上面这些方法我不具体介绍，大家可以自行查阅相关文档了解，这里我主要说一下我们可以利用getEntriesByName()这个方法来计算首屏时间： 首屏时间：performance.getEntriesByName(“first-contentful-paint”)[0].startTime - navigationStart 欢迎关注我的微信公众号：前端极客技术(FrontGeek) 我该计算首屏时间还是白屏时间？在评估页面是否开始渲染方面，首屏时间会比白屏时间更精确，但是二者的结束时间往往很接近。所以要根据自己的业务场景去决定到底该用哪种计算方式。 对于交互性比较少的简单网页，由于加载比较快，所以二者区别不大，因此，可以根据喜好任选一种计算方式。 对于大型的复杂页面，你会发现由于需要处理更多复杂的元素，白屏时间和首屏时间相隔比较远，这时候，计算首屏时间会更有用。 白屏和首屏的优化目前白屏常见的优化方案有： SSR 预渲染 骨架屏 优化首屏加载时间的方法： CDN分发（减少传输距离） 后端在业务层的缓存 静态文件缓存方案 前端的资源动态加载 减少请求的数量 利用好HTTP压缩 白屏时间和首屏时间的优化方法不止上面这些，感兴趣的小伙伴可以自行查找相关内容。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/tags/前端/"},{"name":"性能监控","slug":"性能监控","permalink":"http://www.chenhanpeng.com/tags/性能监控/"}]},{"title":"一文彻底掌握HTTP缓存","slug":"fe/HTTP缓存","date":"2021-01-07T16:05:43.000Z","updated":"2021-01-12T07:04:17.371Z","comments":true,"path":"http-cache/","link":"","permalink":"http://www.chenhanpeng.com/http-cache/","excerpt":"","text":"缓存，作为性能优化的最有效方法之一，在面试过程中经常被问到，作为一名开发人员，缓存是必须掌握的一块知识。 浏览器缓存机制有四个方面：Memory Cache、Service Worker Cache、HTTP Cache、Push Cache。 对于前端开发工程师来说，比较熟悉的就是HTTP缓存，这也是每一个前端工程师都要掌握的知识点，下面我们一起来学习HTTP缓存，争取通过这篇文章就彻底掌握HTTP缓存。 HTTP缓存机制HTTP缓存机制是根据HTTP报文的缓存标识进行的。HTTP缓存分为强缓存和协商缓存。优先级最高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。接下来我们一起来看下这两个缓存机制： 强缓存强缓存是利用http头中的Expires和Cache-Control两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的Expires和Cache-Control判断目标资源是否“命中”强缓存，如果命中则直接从缓存中获取资源，不会再与服务端发生通信。命中强缓存的情况下，返回的HTTP状态码为200。 Expires过去我们一直使用Expires来实现强缓存：当服务器返回响应时，在Response Headers中将过期时间写入Expires字段。例如： 从上图我们可以看到Expires是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和expires的时间戳，如果本地时间小于expires设定的过期时间，就直接从缓存中获取这个资源。 到这里聪明的你可能已经发现了下面这个问题：由于expires的时间戳是服务器定义的，而本地时间的取值来自客户端，因此expires的工作机制对于客户端时间和服务器时间的一致性要求极高，如果两者的时间存在时差，会带来意料之外的结果。 由于上面的原因，加上expires是HTTP1.0的产物，现在实现强缓存大多数是使用Cache-Control。 Cache-ControlCache-Control是HTTP1.1提出的特性，为了弥补Expires缺陷提出的，提供了更精确细致的缓存功能。 Cache-Control包含的值很多： public：表明响应可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。 private：表明响应只能被客户端缓存。 no-cache：跳过强缓存，直接进入协商缓存阶段。 no-store：表示当前请求资源禁用缓存 max-age=：设置缓存存储的最大周期，超过这个时间缓存被认为过期（单位秒） s-maxage=：覆盖max-age或者Expires头。如果s-maxage未过期，则向代理服务器请求其缓存内容。 这里需要注意的是：s-maxage仅在代理服务器中生效，客户端只需要考虑max-age。 下面我们来看个例子： 从上面的例子我们可以看到，HTTP响应报文中同时有Cache-Control和Expires两个字段，由于Cache-Control优先级较高，那么直接根据Cache-Control的值进行缓存，也就是说在315360000秒内重新发起该请求，会直接使用缓存结果，强制缓存生效。 在 HTTP1.1 标准试图将缓存相关配置收敛进 Cache-Control 这样的大背景下， max-age可以视作是对 expires 能力的补位/替换。在当下的前端实践里，我们普遍会倾向于使用max-age。但如果你的应用对向下兼容有强诉求，那么 expires 仍然是不可缺少的。 协商缓存协商缓存，也称为对比缓存。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。 如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304（如下图）。 协商缓存依赖于服务端与浏览器之间的通信。 同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified和Etag，其中Etag的优先级比Last-Modified高。 Last-Modified &amp; If-Modified-SinceLast-Modified（Response Header）和If-Modified-Since（Request Header）是一对报文头，属于HTTP1.0。 Last-Modified表示资源的最后修改时间，是一个时间戳，如果启用了协商缓存，它会在首次请求时随着Response Headers返回。1Last-Modified: Sat, 09 May 2020 09:33:56 GMT If-Modified-Since是一个请求首部字段，并且只能用在GET或HEAD请求中。客户端再次请求服务器时，请求头会包含这个字段，后面跟着在缓存中获取的资源的最后修改时间。 1If-Modified-Since: Sat, 09 May 2020 09:33:56 GMT 服务端收到请求发现此请求头中有If-Modified-Since字段，会与被请求资源的最后修改时间进行对比，如果一致则会返回304和响应报文头，浏览器从缓存中获取数据即可。从字面上看，就是说从某个时间节点开始看，是否被修改了，如果被修改了，就返回整个数据和200 OK，如果没有被修改，服务端只要返回响应头报文，304 Not Modified，Response Headers不会再添加Last-Modified字段。 使用Last-Modified是有一定缺陷的： 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为 If-Modified-Since 只能检查到以秒为最小计量单位的时间差。 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。 我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。 为了解决上面服务器没有正确感知文件变化的问题，Etag作为Last-Modified的补充出现了。 Etag &amp; If-None-MatchEtag和If-None-Match是一对报文头，属于HTTP1.1。 Etag是一个响应首部字段，是根据实体内容生成的一段hash字符串，标识资源的状态，由服务端产生。1ETag: W/&quot;324023994867772d0dd9fac01f1420bd&quot; If-None-Match是一个条件式的请求首部，如果请求资源时在请求首部加上这个字段，值为之前服务器返回的Etag，则当且仅当服务器上没有任务资源的Etag属性值与这个值相符，服务器才会返回带有请求资源实体的200响应，否正服务器会返回不带实体的304响应。1If-None-Match: W/&quot;324023994867772d0dd9fac01f1420bd&quot; Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的：Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。 如何设置一个可靠的缓存规则上面我们已经学完了HTTP缓存机制，是不是迫不及待想要实践一番？但是如何设置一个可靠的缓存规则，需要根据实际需求决定，绝大部分需求的缓存规则都可以根据Chrome官方提供的流程图来进行设置。 我们一起来看上面这张流程图： 如果资源不可复用，直接为Cache-Control设置no-store，拒绝一切形式的缓存； 如果资源可复用，考虑是否每次都需要向服务器进行缓存确认，如果是，设置Cache-Control的值为no-cache； 如果不需要每次都向服务器确认，考虑资源是否可以被代理服务器缓存，根据其结果决定是设置为private还是public； 接下来考虑资源的过期时间，设置对应的max-age； 最后，配置协商缓存需要用到的Etag、Last-Modified等参数。 后续根据这个流程，我们就可以设计出可靠的缓存规则了。 看到这里，文章也即将结束，关于HTTP缓存你掌握了吗？希望大家看完这篇文章有所收获，以后面试碰到HTTP缓存的相关问题也能够从容应答。 参考资料Cache-Control MDN一文读懂前端缓存前端性能优化原理与实践","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/tags/前端/"},{"name":"HTTP缓存","slug":"HTTP缓存","permalink":"http://www.chenhanpeng.com/tags/HTTP缓存/"}]},{"title":"LeetCode题解|206.反转链表","slug":"leetcode/LeetCode题解-206-反转链表","date":"2020-12-17T15:50:48.000Z","updated":"2021-04-21T01:17:31.924Z","comments":true,"path":"leetcode-reverse-linked-list/","link":"","permalink":"http://www.chenhanpeng.com/leetcode-reverse-linked-list/","excerpt":"","text":"前言链表（Linked List）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针（Pointer）。 链表的结构如下图所示： 由于不是必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，但是在查找一个节点或者访问特定编号的节点则需要O(n)的时间。 对于如何反转单向链表、移除链表元素、合并两个链表等问题都是面试中比较常遇到的，今天我们来看LeetCode上的一道题：反转链表。 题目链接：https://leetcode-cn.com/problems/reverse-linked-list/ 题目描述反转一个单链表。 示例 1:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 该题主要有两种解法：循环实现和递归实现 解法1：循环实现思路1、初始化一个pre指针指向null，一个cur指针指向head。 2、开始遍历列表，在每一次循环中： 先保存cur.next; 把cur.next倒装方向指向pre; pre和cur都分别向前一步 图解 代码12345678910111213141516171819202122/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; let pre = null; let cur = head; while (cur != null) &#123; let tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; &#125; return pre;&#125;; 解法2：递归实现思路我们可以将链表分为两部分： 第一个节点 余下的部分 假设余下的部分都是反转好的列表，那么我们只需要将已经反转好的这部分链表的最后一个节点指向原来的第一个节点，并且返回已经返回好的head。 对于上述说的余下部分，我们也可以将链表分为两部分： 第一个节点 余下的部分 由此，我们就可以用递归的方式来实现。递归的关键在于出口，在反转链表中，出口就是当链表被分成只剩下最后一个节点的时候，我们只需要直接返回当前节点作为 head。 图解 代码123456789101112131415161718/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; if (head == null || head.next == null) return head; let newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.chenhanpeng.com/categories/算法/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://www.chenhanpeng.com/categories/算法/LeetCode/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/tags/面试/"},{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://www.chenhanpeng.com/tags/LeetCode题解/"},{"name":"链表","slug":"链表","permalink":"http://www.chenhanpeng.com/tags/链表/"}]},{"title":"一文掌握9大跨域解决方案","slug":"interview/跨域及其九种解决方法","date":"2020-12-14T15:36:12.000Z","updated":"2021-04-21T01:17:30.320Z","comments":true,"path":"cross-domain-and-9-solutions/","link":"","permalink":"http://www.chenhanpeng.com/cross-domain-and-9-solutions/","excerpt":"","text":"什么是跨域跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。通常我们讲的跨域，是由浏览器同源策略限制的一类请求场景。 同源策略同源指的是两个URL的协议、域名和端口三者都相同，即使两个不同 的域名指向相同的IP地址，也非同源。 同源策略(SOP:Same origin policy)是浏览器的一套基础的安全策略制约，用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。 同源策略主要表现在DOM、web数据和网络三个层面。 DOM层面： 同源策略限制了来自不同源的JavaScript脚本对当前DOM对象读和写的操作。 数据层面： 同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。 网络层面： 同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。 跨域的解决方法主要有以下九种解决方案： JSONP CORS(跨域资源共享，最常用) postMessage + iframe document.domain + iframe window.name + iframe location.hash + iframe WebSocket nginx代理跨域 nodejs中间件代理跨域 JSONP浏览器只对XMLHttpRequest请求有同源请求限制，而对script标签src属性、link标签ref属性和img标签src属性没有这这种限制，利用这个“漏洞”就可以很好的解决跨域请求。JSONP就是利用了script标签无同源限制的特点来实现的。当然需要后端服务器的配合，返回一个合法的JS脚本，一般是一条调用js函数的语句，数据作为函数的入参。 我们通过下面的例子来简单展示如何通过JSONP来解决跨域。 123456789101112const express = require('express');const app = express();app.get('/jsonp', (req, res) =&gt; &#123; let &#123;wd, cb&#125; = req.query; console.log(wd, cb); res.end(`$&#123;cb&#125;('接口返回测试数据')`);&#125;)app.listen(3000, () =&gt; &#123; console.log('app listening on port 3000');&#125;) 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;jsonp解决跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function jsonp(&#123;url, params, cb&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement('script'); window[cb] = function(data) &#123; resolve(data) document.body.removeChild(script); &#125; params = &#123;...params, cb&#125;; let arrs = []; for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;`; document.body.appendChild(script); &#125;) &#125; jsonp(&#123; url: 'http://localhost:3000/jsonp', params: &#123; wd: 'b' &#125;, cb: 'show' // 回调函数名 &#125;).then(data =&gt; &#123; console.log(data) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSONP有以下几个缺点： 只支持GET请求而不支持POST等其它类型的HTTP请求 只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 JSONP在调用失败的时候不会返回各种HTTP状态码。 不安全。万一提供jsonp的服务存在页面注入漏洞，容易遭受xss攻击。 CORS(跨域资源共享，最常用)跨源资源共享 (CORS,Cross-origin resource sharing)是一种基于HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它origin（域，协议和端口），这样浏览器可以访问加载这些资源。 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 接下来我们通过一个简单的例子来一起看下CORS的用法： 12345678910111213141516171819202122const express = require('express');const app = express();let whiteList = ['http://localhost:3000']app.use(function (req, res, next) &#123; console.log(req.headers); let origin = req.headers.origin; if (whiteList.includes(origin)) &#123; res.setHeader('Access-Control-Allow-Origin', origin); // 接受origin这个域名的请求 res.setHeader('Access-Control-Allow-Headers', 'x-name'); // 表明服务器支持的所有头信息字段 &#125; next();&#125;)app.get('/getData', (req, res) =&gt; &#123; res.end('接口返回测试数据');&#125;)app.use(express.static(__dirname));app.listen(4000) 我们通过http://localhost:3000/index.html打开下面的HTML：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;CORS&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;cors test html&lt;/p&gt; &lt;script&gt; let xhr = new XMLHttpRequest(); xhr.open('GET', 'http://localhost:4000/getData', true) xhr.setRequestHeader('x-name', 'test') xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; console.log(xhr.response) &#125; &#125; &#125; xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 该方法主要是后端服务接口在响应报文中设置相应的正确CORS响应头。这也是目前最常用的解决跨域问题的方法。 更多详细内容可以查看阮一峰老师的文章：https://www.ruanyifeng.com/blog/2016/04/cors.html postMessage + iframepostMessage是H5引入的一个API，该方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 我们起两个服务，a.html在http://localhost:3000上，b.html在http://localhost:4000上。 两个HTML代码如下： a.html123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;a page&lt;/p&gt; &lt;span id=\"message\"&gt;&lt;/span&gt; &lt;iframe src=\"http://localhost:4000/b.html\" frameborder=\"1\" id=\"frame\"&gt;&lt;/iframe&gt; &lt;script&gt; window.onload = function() &#123; let frame = document.getElementById('frame'); frame.contentWindow.postMessage('测试消息', 'http://localhost:4000/b.html') &#125; window.onmessage = function (e) &#123; // 接受消息 document.getElementById('message').innerHTML = `收到$&#123;e.origin&#125;的消息：$&#123;e.data&#125;`; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b.html123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;b page&lt;/p&gt; &lt;span id=\"message\"&gt;&lt;/span&gt; &lt;script&gt; window.onmessage = function (e) &#123; // 接受消息 console.log('b page onmessage', e.data); document.getElementById('message').innerHTML = `收到$&#123;e.origin&#125;的消息：$&#123;e.data&#125;`; top.postMessage('b 页面收到消息', 'http://localhost:3000/a.html'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; window.name页面在浏览器端展示时，我们能拿到全局变量window，window变量有个name属性，该属性具有下面几个特征： 每个窗口都有独立的window.name与之对应 在一个窗口的生命周期中（被关闭前），窗口载入的所有页面同时共享一个window.name，每个页面对window.name都有读写的权限。 window.name一直存在于当前窗口，即使是有新的页面载入也不会改变window.name的值。 window.name可以存储不超过2M的数据，数据格式按需自定义 我们准备三个页面：a.html和b.html在http://localhost:3000上，c.html在http://localhost:4000上。 目标：要在a页面获取c页面发送的数据 思路：a先引用c，c把值放到window.name，把a的引用地址改到b 代码如下：a.html12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;a page&lt;/p&gt; &lt;iframe src=\"http://localhost:4000/c.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt; &lt;script&gt; let first = true; function load() &#123; if (first) &#123; let frame = document.getElementById('frame'); frame.src = 'http://localhost:3000/b.html'; first = false; &#125; else &#123; console.log(frame.contentWindow.name); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b.html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;b page&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; c.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.name = 'window.name实现跨域' &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; location.hash实现原理： a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。 我们准备三个页面：a.html和b.html在http://localhost:3000上，c.html在http://localhost:4000上。 目标：在a页面获取c页面发送的数据。 思路：a给c传一个hash值，c收到hash值后，c把hash值传递给b，b将结果放到a的hash值中 代码如下： a.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=\"http://localhost:4000/c.html#testData\" frameborder=\"0\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt; &lt;script&gt; window.onhashchange = function() &#123; console.log(location.hash); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.parent.parent.location.hash = location.hash &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; c.html123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; console.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#cPageToBData'; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; document.domain该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain =’test.com’ 表示二级域名都相同就可以实现跨域。 实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。 a.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=\"http://b.test.com/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'test.com' function load() &#123; console.log(frame.contentWindow.data); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; document.domain = 'test.com'; var data = '这是b页面的数据'; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; WebSocketWebSocket是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 同源策略对WebSocket不适用。 我们来看个简单例子：本地socket.html向localhost:3000发送数据和接受数据： 123456789101112131415161718192021// socket.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 高级API 不兼容， socket.io 库 let socket = new WebSocket('ws://localhost:3000'); socket.onopen = function() &#123; socket.send('test data'); &#125; socket.onmessage = function(e) &#123; console.log(e.data); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112// server.jslet express = require('express');let app = express();let WebSocket = require('ws');let wss = new WebSocket.Server(&#123;port:3000&#125;)wss.on('connection', function(ws) &#123; ws.on('message', function(data) &#123; console.log(data); ws.send('response data'); &#125;)&#125;) nodejs中间件代理跨域同源策略针对的是浏览器，如果是服务器向服务器请求则无需遵循同源策略。nodejs中间件代理跨域就是利用这个原理，将跨域请求发给代理服务器，代理服务器去做请求转发。 代理服务器需要做以下几个步骤： 接受客户端请求 将请求转发给服务器 拿到服务器响应数据 将响应转发给客户端 我们来看下面的例子：本地index.html文件，通过代理服务器 localhost:3000 向目标服务器 localhost:4000 请求数据： index.html12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;http proxy&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;http://localhost:3000/index.html&lt;/p&gt; &lt;script&gt; let xhr = new XMLHttpRequest(); xhr.open('GET', 'http://localhost:3000/getData', true) xhr.setRequestHeader('x-name', 'test') xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; console.log(xhr.response) &#125; &#125; &#125; xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; proxyServer.js12345678910111213141516171819202122const express = require('express');const &#123; createProxyMiddleware &#125; = require('http-proxy-middleware');const app = express();// 利用 Express 托管静态文件，可通过http://localhost:3000/index.html来访问index.html，实现跨域app.use(express.static(__dirname));// 代理服务器操作// 设置允许跨域访问该服务app.all('*', (req, res, next) =&gt; &#123; res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Access-Control-Allow-Methods', '*'); res.header('Content-Type', 'application/json;charset=utf-8'); next();&#125;);// http-proxy-middleware// 中间件 每个请求来之后 都会转发到 http://localhost:3001 后端服务器app.use('/', createProxyMiddleware(&#123;target: 'http://localhost:4000', changeOrigin: true&#125;))app.listen(3000) server.js12345678910const express = require('express');const app = express();app.get('/getData', (req, res) =&gt; &#123; res.end('nodejs中间件代理跨域 返回数据');&#125;)app.use(express.static(__dirname));app.listen(4000) nginx实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。 使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。 nginx的配置简单示例如下：1234567891011121314// proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 文中示例代码： cross-domain 参考资料 https://www.jianshu.com/p/e1e2920dac95 https://www.ruanyifeng.com/blog/2016/04/cors.html","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/categories/面试/"},{"name":"面试","slug":"前端/面试","permalink":"http://www.chenhanpeng.com/categories/前端/面试/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/tags/前端/"},{"name":"跨域","slug":"跨域","permalink":"http://www.chenhanpeng.com/tags/跨域/"}]},{"title":"CSS面试题：什么是BFC？BFC有什么用？","slug":"css/BFC","date":"2020-12-09T01:30:48.000Z","updated":"2021-04-21T01:17:29.302Z","comments":true,"path":"css-bfc/","link":"","permalink":"http://www.chenhanpeng.com/css-bfc/","excerpt":"","text":"BFC是之前前端面试中经常问到一个问题，这篇文章我们一起来学习BFC。 什么是BFCBFC(Block Formatting Context)：快格式化上下文，是web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。它有一套渲染规则，决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 快格式化上下文包含创建它的元素内部的所有内容。 具有BFC特性的元素我们可以将其看作隔离的独立容器，容器内的元素不会在布局上影响到容器外的元素，而且BFC具有普通容器所没有的一些特性。 如何创建BFC在了解BFC特性之前，我们先来看下都有哪些方式会创建BFC(摘抄自MDN)： 根元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content 或 paint 的元素 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素） 网格元素（display 为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 欢迎关注我的微信公众号：前端极客技术(FrontGeek) BFC的布局规则 内部的Box会在垂直方向上一个接一个的放置 内部的Box垂直方向上的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界） BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC特性及应用同一BFC下发生外边距塌陷我们先来看下面的代码 123456789101112&lt;style&gt; div &#123; width: 100px; height: 100px; margin: 50px; background-color: #108EE9; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 从代码和实际渲染效果看出：两个div处于同一个BFC容器下（body元素）,第一个div元素的下边距和第二个div元素的上边距发生了重叠，两个盒子之间的距离只有50px，这就是外边距折叠，也就叫外边距塌陷。 这个不是CSS的bug，我们可以理解为这是一种规范。如果想要避免外边距发生重叠，可以将其放在不同的BFC容器中。 我们将上面代码做以下调整，代码及效果如下： 12345678910111213141516171819&lt;style&gt; .container &#123; overflow: hidden; &#125; p &#123; width: 100px; height: 100px; margin: 50px; background-color: #108EE9; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; BFC可以包含浮动的元素（清除浮动）我们先来看下面的代码及其执行结果： 12345678910111213141516&lt;style&gt; .father &#123; border: 1px solid royalblue; overflow: auto; &#125; .float-child &#123; width: 100px; height: 100px; background-color: #108EE9; float: right; &#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"float-child\"&gt;&lt;/div&gt;&lt;/div&gt; 容器内的子元素都设置为浮动，容器的高度只剩下2px的边框高度，出现这个结果是由于浮动元素会脱离文档流，所以导致不占据页面空间，所以会对父元素高度带来一定影响。如果一个元素中包含的元素全部是浮动元素，那么该元素高度将变成0，也就是我们常说的高度塌陷。 如果使触发容器的 BFC，那么容器将会包裹着浮动元素。 123456789101112131415&lt;style&gt; .father &#123; border: 1px solid royalblue; &#125; .float-child &#123; width: 100px; height: 100px; background-color: #108EE9; float: right; &#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"float-child\"&gt;&lt;/div&gt;&lt;/div&gt; BFC可以阻止元素被浮动元素覆盖BFC可以阻止元素被浮动元素覆盖，在了解这个特性之前，先看下面的代码： 1234567&lt;div style=\"float: left;width: 200px;background-color: #108EE9;\"&gt; 浮动区域&lt;/div&gt;&lt;div style=\"height: 100px;background-color: #808080;\"&gt; 非浮动区域，height: 100px;background-color: #808080;&lt;/div&gt; 这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成： 利用BFC可以阻止元素被浮动元素覆盖的特性，我们解决CSS的两列自适应布局问题。 阻止因为浏览器因为四舍五入造成的多列布局换行的情况有时候因为多列布局采用小数点位的width导致因为浏览器因为四舍五入造成的换行的情况，可以在最后一列触发BFC的形式来阻止换行的发生。比如下面的例子： 123456789101112131415161718192021222324&lt;style&gt;.container &#123; min-height: 200px;&#125;.column1,.column2 &#123; width: 31.3%; background-color: green; float: left; min-height: 100px; margin: 0 1%;&#125;.column3 &#123; width: 31.3%; background-color: green; min-height: 100px; margin: 0 1%;&#125;&lt;/style&gt;&lt;div class=\"container\"&gt; &lt;div class=\"column1\"&gt;column 1&lt;/div&gt; &lt;div class=\"column2\"&gt;column 2&lt;/div&gt; &lt;div class=\"column3\"&gt;column 3&lt;/div&gt;&lt;/div&gt; 从上图看出，我们最后一列出现换行情况，我们在对最后一列触发BFC特性，加入overflow: hidden，页面重新渲染结果如下： 参考资料：https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context https://mp.weixin.qq.com/s/K7Ph4yuG0UMZYGKuDyMHjg https://zhuanlan.zhihu.com/p/25321647","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://www.chenhanpeng.com/categories/前端/CSS/"},{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/categories/面试/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"http://www.chenhanpeng.com/tags/CSS/"},{"name":"BFC","slug":"BFC","permalink":"http://www.chenhanpeng.com/tags/BFC/"}]},{"title":"LeetCode题解|215.数组中的第K个最大元素","slug":"leetcode/LeetCode题解-215-数组中的第K个最大元素","date":"2020-09-01T15:12:14.000Z","updated":"2021-04-21T01:17:31.926Z","comments":true,"path":"kth-largest-element-in-an-array/","link":"","permalink":"http://www.chenhanpeng.com/kth-largest-element-in-an-array/","excerpt":"","text":"前言前面我们一起学过十种常见的排序算法，我们一起来看一道和排序有关的LeetCode题目：215.数组中的第K个最大元素，题目链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/。 题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1:12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 解法1：Array.sort()求解Kth Element问题，我们可以利用Array.sort()方法对数组进行升序排序，然后返回倒数第k个元素即可。 实现代码如下：123456789/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var findKthLargest = function(nums, k) &#123; nums = nums.sort((a, b) =&gt; a - b); return nums[nums.length - k];&#125;; 注意：sort方法如果没有指定排序函数的话，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 解法2：堆排序堆排序可以用于求解TopK Element问题，也就是K个最小元素的问题。可以维护一个大小为K的最小堆，最小堆中的元素就是最小元素。最小堆需要使用大顶堆来实现，大顶堆表示堆顶元素是堆中最大元素。这是因为我们要得到 k 个最小的元素，因此当遍历到一个新的元素时，需要知道这个新元素是否比堆中最大的元素更小，更小的话就把堆中最大元素去除，并将新元素添加到堆中。所以我们需要很容易得到最大元素并移除最大元素，大顶堆就能很好满足这个要求。 堆也可以用于求解 Kth Element 问题，得到了大小为 k 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 k 大的元素。 我们来看下这道题用堆排序的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let findKthLargest = function(nums, k) &#123; // 从nums中取出前k个数，构建一个小顶堆 let heap = [,], i = 0 while (i &lt; k) &#123; heap.push(nums[i++]) &#125; buildHeap(heap, k) // 从k位开始遍历数组 for (let i = k; i &lt; nums.length; i++) &#123; if (heap[1] &lt; nums[i]) &#123; // 替换并堆化 heap[1] = nums[i] heapify(heap, k, 1) &#125; &#125; return heap[1]&#125;// 原地建堆，从后往前，自上而下式建小顶堆let buildHeap = function (arr, k) &#123; if (k === 1) return // 从最后一个非叶子节点开始，自上而下式堆化 for (let i = Math.floor(k / 2); i &gt;= 1; i--) &#123; heapify(arr, k, i) &#125;&#125;// 堆化let heapify = function (arr, k, i) &#123; while (true) &#123; let minIndex = i if (2 * i &lt;= k &amp;&amp; arr[2 * i] &lt; arr[i]) &#123; minIndex = 2 * i &#125; if (2 * i + 1 &lt;= k &amp;&amp; arr[2 * i +1] &lt; arr[minIndex]) &#123; minIndex = 2 * i + 1 &#125; if (minIndex !== i) &#123; swap(arr, i, minIndex) i = minIndex &#125; else &#123; break &#125; &#125;&#125;// 交换let swap = (arr, i , j) =&gt; &#123; let temp = arr[i] arr[i] = arr[j] arr[j] = temp&#125; 复杂度分析： 时间复杂度：O(NlogK) 空间复杂度：O(K) 解法3：快速排序快速排序可以用于求解Kth Element问题，也就是第K个元素的问题。 快速排序也可以求解TopK Element问题，因为找到Kth Element之后，再遍历一次数组，所有小于等于Kth Element的元素都是TopK Elements。 我们来看下使用快速排序解决这道题的实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let findKthLargest = function(nums, k) &#123; return quickSelect(nums, nums.length - k)&#125;;let quickSelect = (arr, k) =&gt; &#123; return quick(arr, 0 , arr.length - 1, k)&#125;let quick = (arr, left, right, k) =&gt; &#123; let index if(left &lt; right) &#123; // 划分数组 index = partition(arr, left, right) // Top k if(k === index) &#123; return arr[index] &#125; else if(k &lt; index) &#123; // Top k 在左边 return quick(arr, left, index-1, k) &#125; else &#123; // Top k 在右边 return quick(arr, index+1, right, k) &#125; &#125; return arr[left]&#125;let partition = (arr, left, right) =&gt; &#123; // 取中间项为基准 var datum = arr[Math.floor(Math.random() * (right - left + 1)) + left], i = left, j = right // 开始调整 while(i &lt; j) &#123; // 左指针右移 while(arr[i] &lt; datum) &#123; i++ &#125; // 右指针左移 while(arr[j] &gt; datum) &#123; j-- &#125; // 交换 if(i &lt; j) swap(arr, i, j) // 当数组中存在重复数据时，即都为datum，但位置不同 // 继续递增i，防止死循环 if(arr[i] === arr[j] &amp;&amp; i !== j) &#123; i++ &#125; &#125; return i&#125;// 交换let swap = (arr, i , j) =&gt; &#123; let temp = arr[i] arr[i] = arr[j] arr[j] = temp&#125; 复杂度分析： 时间复杂度：O(N) 空间复杂度：O(1)","categories":[{"name":"算法","slug":"算法","permalink":"http://www.chenhanpeng.com/categories/算法/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://www.chenhanpeng.com/categories/算法/LeetCode/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/tags/面试/"},{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://www.chenhanpeng.com/tags/LeetCode题解/"},{"name":"排序","slug":"排序","permalink":"http://www.chenhanpeng.com/tags/排序/"}]},{"title":"十大经典排序算法","slug":"algorithm/十大经典排序算法","date":"2020-08-20T15:39:24.000Z","updated":"2020-08-21T01:19:01.145Z","comments":true,"path":"ten-classic-sort-algorithms/","link":"","permalink":"http://www.chenhanpeng.com/ten-classic-sort-algorithms/","excerpt":"","text":"前言在上一篇文章《Javascript-数组乱序》中我们提到不同浏览器采用不同的排序算法来实现Array.prototype.sort方法，今天我们一起来学习常见的几种排序算法。 我们常说的十大经典排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序。 算法概述算法分类上面的十种排序算法可以分为两类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 每个排序算法属于哪一类如下图所示： 算法复杂度 相关概念在上图中我们标注了每个算法是否稳定，那么如何区分稳定和不稳定？ 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b前面，而a=b，排序之后a可能会出现在b的后面。 冒泡排序冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。 算法步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤1-3，直到没有任何一对数字需要比较。 代码实现：python版本12345678def bubble_sort(arr): length = len(arr) for x in range(1, length): for i in range(0, length - x): if arr[i] &gt; arr[i + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr JavaScript 代码实现12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - i -1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; return arr;&#125; 选择排序选择排序（Selection sort）是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 其算法思想：从数组中选择最小元素，并将其与第一个元素交换位置。再从数组中剩下的元素中选择出最小元素，将其与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复步骤2，直到所有元素均排序完毕。 代码实现Python代码实现：12345678910def selectionSort(arr): for i in range(0, len(arr)): index = i for j in range(i + 1, len(arr)): if arr[j] &lt; arr[index]: index = j if i != index: arr[i], arr[index] = arr[index], arr[i] return arr JavaScript代码实现： 12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var index, temp; for (var i = 0; i &lt; len - 1; i++) &#123; index = i; for (var j = i + 1; j &lt; len -1; j++) &#123; if (arr[j] &lt; arr[index]) &#123; index = j; &#125; temp = arr[i]; arr[i] = arr[index]; arr[index] = temp; &#125; &#125; return arr;&#125; 插入排序插入排序（Insertion sort）是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。 平均情况下插入排序需要 N^2/4 比较以及 N^2/4 次交换； 最坏的情况下需要 N^2/2 比较以及 N^2/2 次交换，最坏的情况是数组是倒序的； 最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。 算法步骤 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 代码实现python代码实现123456789def insertionSort(arr): for i in range(len(arr)): preIndex = i current = arr[i] while preIndex &gt;= 0 and arr[preIndex] &gt; current: arr[preIndex + 1] = arr[preIndex] preIndex -= 1 arr[preIndex + 1] = current return arr JavaScript代码实现1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125; 希尔排序对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于1。 希尔排序(Shell’s Sort)，也称为递减增量排序算法，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法。 希尔排序使用插入排序对间隔h的序列进行排序。通过不断减小h，最后令h=1，就可以使得整个数组是有序的。 希尔排序的运行时间达不到平方级别，使用递增序列1,4,10,20…的希尔排序所需要的比较次数不会超过N的若干倍乘以递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。 算法步骤 选择一个增量序列 t1, t2, …, tk，其中ti &gt; tj, tk = 1; 按增量序列个数k，对序列进行k趟排序； 每趟排序，根据对应的增量ti， 将待排序列分割为若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。 代码实现python实现123456789101112131415def shellSort(arr): import math gap = 1 while(gap &lt; len(arr)/3): gap = gap * 3 + 1 while gap &gt; 0: for i in range(gap, len(arr)): temp = arr[i] j = i - gap while j &gt;= 0 and arr[j] &gt; temp: arr[j + gap] = arr[j] j -= gap arr[j + gap] = temp gap = math.floor(gap/3) return arr javascript实现123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while(gap &lt; len / 3) &#123; gap = gap * 3 + 1 &#125; for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i - gap; j &gt;=0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; arr[j + gap] = arr[j]; &#125; arr[j + gap] = temp; &#125; &#125; return arr;&#125; 归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 归并排序是一种稳定的排序方法，和选择排序一样，性能不受输入数据的影响，但表现比选择排序好很多，因为时间复杂度始终都是O(nlogn)，代价就是需要额外的内存空间。 算法步骤 把长度为n的输入序列分为两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排好序的子序列合并成一个最终的排序序列。 代码实现JavaScript1234567891011121314151617181920212223242526272829303132function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125; python1234567891011121314151617181920def mergeSort(arr): import math if (len(arr) &lt; 2): return arr middle = math.floor(len(arr) / 2) left, right = arr[0:middle], arr[middle:] return merge(mergeSort(left), mergeSort(right))def merge(left,right): result = [] while left and right: if left[0] &lt;= right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)); while left: result.append(left.pop(0)) while right: result.append(right.pop(0)); return result 快速排序快速排序(quick sort)通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 性能分析快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。 最坏情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N^2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 代码实现javascript1234567891011121314151617181920212223242526272829303132function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr;&#125;function partition(arr, left ,right) &#123; // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; python1234567891011121314151617181920212223def quickSort(arr, left=None, right=None): left = 0 if not isinstance(left,(int, float)) else left right = len(arr)-1 if not isinstance(right,(int, float)) else right if left &lt; right: partitionIndex = partition(arr, left, right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) return arrdef partition(arr, left, right): pivot = left index = pivot+1 i = index while i &lt;= right: if arr[i] &lt; arr[pivot]: swap(arr, i, index) index+=1 i+=1 swap(arr,pivot,index-1) return index-1def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] 堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。 算法步骤 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 代码实现JavaScript1234567891011121314151617181920212223242526272829303132333435363738394041424344var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123; // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest); &#125;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (var i = arr.length-1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0); &#125; return arr;&#125; Python123456789101112131415161718192021222324252627282930def buildMaxHeap(arr): import math for i in range(math.floor(len(arr)/2),-1,-1): heapify(arr,i)def heapify(arr, i): left = 2*i+1 right = 2*i+2 largest = i if left &lt; arrLen and arr[left] &gt; arr[largest]: largest = left if right &lt; arrLen and arr[right] &gt; arr[largest]: largest = right if largest != i: swap(arr, i, largest) heapify(arr, largest)def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i]def heapSort(arr): global arrLen arrLen = len(arr) buildMaxHeap(arr) for i in range(len(arr)-1,0,-1): swap(arr,0,i) arrLen -=1 heapify(arr, 0) return arr 计数排序计数排序（Counting Sort）不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 计数排序的特征当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。 通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。 算法的步骤 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 代码实现JavaScript12345678910111213141516171819202122function countingSort(arr, maxValue) &#123; var bucket = new Array(maxValue+1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr;&#125; Python123456789101112131415def countingSort(arr, maxValue): bucketLen = maxValue+1 bucket = [0]*bucketLen sortedIndex =0 arrLen = len(arr) for i in range(arrLen): if not bucket[arr[i]]: bucket[arr[i]]=0 bucket[arr[i]]+=1 for j in range(bucketLen): while bucket[j]&gt;0: arr[sortedIndex] = j sortedIndex+=1 bucket[j]-=1 return arr 桶排序桶排序（Bucket Sort）是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 算法步驟 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 算法分析为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快当输入的数据可以均匀的分配到每一个桶中。 什么时候最慢当输入的数据被分配到了同一个桶中。 代码实现JavaScript12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; //桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; //利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125; python12345678910111213141516171819202122232425262728293031def bucket_sort(array, n): # 1.创建n个空桶 new_list = [[] for _ in range(n)] # 2.把arr[i] 插入到bucket[n*array[i]] for data in array: index = int(data * n) new_list[index].append(data) # 3.桶内排序 for i in range(n): new_list[i].sort() # 4.产生新的排序后的列表 index = 0 for i in range(n): for j in range(len(new_list[i])): array[index] = new_list[i][j] index += 1 return arraydef main(): array = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434] n = len(array) array = bucket_sort(array, n) print(array)if __name__ == '__main__': main() 基数排序基数排序（Radix Sort）是一种非比较型整数排序算法，其原理是将数据按位数切割成不同的数字，然后按每个位数分别比较。 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法步骤 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）。 算法分析基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； 代码实现JavaScript12345678910111213141516171819202122232425//LSD Radix Sortvar counter = [];function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr;&#125; python123456789101112131415161718192021222324252627282930313233343536373839404142434445#确定排序的次数#排序的顺序跟序列中最大数的位数相关def radix_sort_nums(L): maxNum = L[0]#寻找序列中的最大数 for x in L: if maxNum &lt; x: maxNum = x#确定序列中的最大元素的位数 times = 0 while (maxNum &gt; 0): maxNum = (int)(maxNum/10) times = times+1 return times#找到num从低到高第pos位的数据def get_num_pos(num,pos): return ((int)(num/(10**(pos-1))))%10#基数排序def radix_sort(L): count = 10*[None] #存放各个桶的数据统计个数 bucket = len(L)*[None] #暂时存放排序结果#从低位到高位依次执行循环 for pos in range(1,radix_sort_nums(L)+1): #置空各个桶的数据统计 for x in range(0,10): count[x] = 0 #统计当前该位(个位，十位，百位....)的元素数目 for x in range(0,len(L)): #统计各个桶将要装进去的元素个数 j = get_num_pos(int(L[x]),pos) count[j] = count[j]+1 #count[i]表示第i个桶的右边界索引 for x in range(1,10): count[x] = count[x] + count[x-1] #将数据依次装入桶中 for x in range(len(L)-1,-1,-1): #求出元素第K位的数字 j = get_num_pos(L[x],pos) #放入对应的桶中，count[j]-1是第j个桶的右边界索引 bucket[count[j]-1] = L[x] #对应桶的装入数据索引-1 count[j] = count[j]-1 # 将已分配好的桶中数据再倒出来，此时已是对应当前位数有序的表 for x in range(0,len(L)): L[x] = bucket[x] 文章参考资料： https://www.runoob.com/w3cnote/ten-sorting-algorithm.html https://www.cnblogs.com/onepixel/articles/7674659.html","categories":[{"name":"算法","slug":"算法","permalink":"http://www.chenhanpeng.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.chenhanpeng.com/tags/算法/"},{"name":"排序算法","slug":"排序算法","permalink":"http://www.chenhanpeng.com/tags/排序算法/"}]},{"title":"JavaScript数组乱序","slug":"javascript/JavaScript数组乱序","date":"2020-08-12T12:56:25.000Z","updated":"2021-04-21T01:17:30.410Z","comments":true,"path":"javascript-array-shuffle/","link":"","permalink":"http://www.chenhanpeng.com/javascript-array-shuffle/","excerpt":"","text":"前言对数组进行排序对我们来说很容易就能够实现，但是你有考虑过如何对一个有序的数组实现乱序，即随机排序吗？ 数组乱序在实际开发过程中是可能碰到的，下面我们一起看看如何实现数组乱序。 sort + Math.random我们一开始可能会想到利用数组的sort方法，判断随机出来的0-1的值与0.5的大小，实现排序。该方法实现如下： 1234567var arr = [1, 2, 3, 4, 5, 6];arr.sort(function()&#123; return Math.random() - 0.5;&#125;);console.log(arr) 上面的实现方法看起来很完美地实现了乱序的需求，但实际的效果如何我们还是要进行测试。 对sort + Math.random方法进行测试在Chrome浏览器上将[1, 2, 3, 4, 5]数组进行乱序10万次，计算乱序后每个值出现在各个位置的概率。测试代码如下： 123456789let statistics = new Array(5).fill(0).map(() =&gt; new Array(5).fill(0));for (let i = 0; i &lt; 100000; i++) &#123; let arr = [1, 2, 3, 4, 5]; arr.sort(() =&gt; Math.random() - 0.5); arr.forEach((value, index) =&gt; &#123; statistics[index][value - 1]++; &#125;)&#125;console.table(statistics.map(item =&gt; item.map(value =&gt; (value / 100000 * 100).toFixed(2) + '%'))); 在Chrome浏览器上执行得到如下结果： 从上图我们可以看出：元素出现在每个位置上的概率并没有趋向于相等，反而元素停留在原位置上的概率更大，所以Array.sort()方法进行乱序是存在问题的。要知道问题具体出现在哪，我们需要了解sort方法实现原理。 Array.sort()方法的实现ECMAScript对 Array.prototype.sort 的定义只规定了效果，没有要求用什么样的排序方式实现sort()方法，也没有要求是否要采用稳定排序算法，所以不同的浏览器实现的方式都不太一样。 Chrome的sort基于V8引擎，它的排序算法进行了很多的优化，但核心是小于等于10的数组用插入排序，大于10的采用快速排序。 FireFox的sort基于SpiderMonkey引擎，采用归并排序。 Safari的sort基于Nitro(JavaScriptCore) 引擎，如果没有自定义的排序规则传入，采用桶排序；传入自定义规则，采用归并排序。 Microsoft Edge/IE9+ 的sort基于Chakra引擎，采用快速排序。 分析其实不管用什么排序方法，大多数排序算法的时间复杂度介于O(n)到O(n2)之间，元素之间的比较次数通常情况下要远小于n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。 怎么理解上边这句话呢？其实我们想使用array.sort进行乱序，理想的方案或者说纯乱序的方案是数组中每两个元素都要进行比较，这个比较有50%的交换位置概率。这样一来，总共比较次数一定为n(n-1)。而在sort排序算法中，大多数情况都不会满足这样的条件。因而当然不是完全随机的结果了。 这里我们以Chrome使用的插入排序算法为例：在插入排序的算法中，当待排序元素跟有序元素进行比较时，一旦确定了位置，就不会再跟位置前面的有序元素进行比较，所以就出现了前面说的“没有了随机交换的可能”的情况，导致乱序不彻底。 要实现真正意义上的乱序，这就要提到经典的 洗牌算法Fisher–Yates_shuffle。 洗牌算法Fisher–Yates_shuffleFisher–Yates_shuffle的原理如下： 1、写下从 1 到 N 的数字2、取一个从 1 到剩下的数字（包括这个数字）的随机数 k3、从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位4、重复第 2 步，直到所有的数字都被取出5、第 3 步写出的这个序列，现在就是原始数字的随机排列 简单的说：就是随机抽一个放到最后。把剩余的数继续抽，继续放到次后。。。。依次执行 实现代码如下： 12345678910function shuffle(array) &#123; var j, x, i; for (i = array.length; i; i--) &#123; j = Math.floor(Math.random() * i); x = array[i - 1]; array[i - 1] = array[j]; array[j] = x; &#125; return array;&#125; 我们对上面实现的方法进行10万次乱序：123456789var statistics = new Array(5).fill(0).map(() =&gt; new Array(5).fill(0));for (let i = 0; i &lt; 100000; i++) &#123; let arr = [1, 2, 3, 4, 5]; arr = shuffle(arr); arr.forEach((value, index) =&gt; &#123; statistics[index][value - 1]++; &#125;)&#125;console.table(statistics.map(item =&gt; item.map(value =&gt; (value / 100000 * 100).toFixed(2) + '%'))); 统计结果如下： 从上图可以看出，数组中任意一个元素出现在任何一个位置的概率都是相等的，这样我们就真正实现了乱序的效果。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"},{"name":"乱序","slug":"乱序","permalink":"http://www.chenhanpeng.com/tags/乱序/"}]},{"title":"JavaScript-数组去重","slug":"javascript/JavaScript数组去重","date":"2020-06-30T01:08:57.000Z","updated":"2021-04-21T01:17:30.481Z","comments":true,"path":"javascript-array-unique/","link":"","permalink":"http://www.chenhanpeng.com/javascript-array-unique/","excerpt":"","text":"前言JavaScript的数组去重是前端比较常见的一个问题，今天我们来学习几种常见的数组去重方法。 欢迎关注我的微信公众号：前端极客技术(FrontGeek) 双层循环大部分人最先想到的是通过双层循环来去重。双层循环的实现原理很简单：我们先新建一个空的数组res，通过遍历待去重数组array和res，判断array[i]是否存在于res中，如果不存在，将array[i]push到res中。 该方法虽然简单，但是其时间复杂度为 O(n^2)，如果数组长度很大，那么会非常耗费内存。 我们直接看下面的代码：123456789101112131415161718var array = [1, 1, '1', '1', 2, 3, '2']function unique(arr) &#123; var res = [] for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = 0, resLength = res.length; j &lt; resLength; j++) &#123; if (arr[i] === res[j]) &#123; break &#125; &#125; if (j === resLength) &#123; res.push(arr[i]) &#125; &#125; return res&#125;console.log(unique(array)) // [1, \"1\", 2, 3, \"2\"] indexOf针对上面的方法，我们可以利用 indexOf 来简化内层循环，将双层循环变为单层循环。实现代码如下： 12345678910111213var array = [1, 1, '1', '1', 2, 3, '2']function unique(arr) &#123; var res = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (res.indexOf(arr[i]) === -1) &#123; res.push(arr[i]) &#125; &#125; return res&#125;console.log(unique(array)) // [1, \"1\", 2, 3, \"2\"] sort()排序后相邻比对去重如果我们先将数组进行排序，排序后相同的元素就会被排在一起，这样我们只要将当前元素和上一个元素进行比较，看两者是否相同，相同则说明重复，不相同push进res中。 实现代码如下：1234567891011121314let array = [1, 1, '1', '1', 2, 3, '2']function unique(arr) &#123; let sortedArr = arr.concat().sort() let res = [] for (let i = 0; i &lt; sortedArr.length; i++) &#123; if (sortedArr[i] !== sortedArr[i-1]) &#123; res.push(sortedArr[i]) &#125; &#125; return res&#125;console.log(unique(array)) // [1, \"1\", 2, \"2\", 3] filterES5 提供了filter方法，我们可以用来简化外层循环。indexOf和排序后去重分别使用filter方法的实现代码如下： 1234567891011121314151617var array = [1, 1, '1', '1', 2, 3, '2']// indexOffunction unique(arr) &#123; var res = arr.filter(function(item, index, arr) &#123; return arr.indexOf(item) === index &#125;) return res&#125;console.log(unique(array))// sortfunction sortedUnique(arr) &#123; return arr.concat().sort().filter(function(item, index, arr) &#123; return !index || item !== arr[index - 1] &#125;)&#125; Set()和Map()如果你熟悉ES6的话，就知道利用Set()和Map()两个数据结构，我们也可以实现数组去重。 我们先来看下Set()的实现代码： 1234567891011var array = [1, 1, '1', '1', 2, 3, '2']function unique(arr) &#123; return Array.from(new Set(arr))&#125;console.log(unique(array))// 另一种写法function unique(arr) &#123; return [...new Set(arr)]&#125; 接下来我们来看下Map()的实现代码：123456var array = [1, 1, '1', '1', 2, 3, '2']function unique(arr) &#123; const tmp = new Map() return arr.filter(item =&gt; !tmp.has(item) &amp;&amp; tmp.set(item, 1))&#125; 特殊类型比较上面我们去重的数组包含的元素都是简单的string和number，但是数组的元素类型还可以是null、undefined、NaN、对象等，针对这些元素，用我们上面实现的方法是有问题的。 假设我们有下面这样一个数组需要去重，并且用上面的提到的方法去重，结果如下：1234567891011121314151617181920212223var array = ['true','true',true,true,0,0,1,1,'1','1',15,15,false,false,undefined,undefined,null,null,NaN,NaN,'NaN','NaN','a','a',&#123;&#125;,&#123;&#125;,&#123;a:2&#125;,&#123;a:2&#125;];// 去重结果如下：// 双层循环[\"true\", true, 0, 1, \"1\", 15, false, undefined, null, NaN, NaN, \"NaN\", \"a\", &#123;&#125;, &#123;&#125;, &#123;a:2&#125;, &#123;a:2&#125;]// indexOf[\"true\", true, 0, 1, \"1\", 15, false, undefined, null, NaN, NaN, \"NaN\", \"a\", &#123;&#125;, &#123;&#125;, &#123;a:2&#125;, &#123;a:2&#125;]// sort排序后去重[0, 1, \"1\", 15, NaN, NaN, \"NaN\", &#123;&#125;, &#123;&#125;, &#123;a:2&#125;, &#123;a:2&#125;, \"a\", false, null, \"true\", true, undefined]// filter + indexOf[\"true\", true, 0, 1, \"1\", 15, false, undefined, null, \"NaN\", \"a\", &#123;&#125;, &#123;&#125;, &#123;a:2&#125;, &#123;a:2&#125;]// filter + sort [0, 1, \"1\", 15, NaN, NaN, \"NaN\", &#123;&#125;, &#123;&#125;, &#123;a:2&#125;, &#123;a:2&#125;, \"a\", false, null, \"true\", true, undefined]// Set[\"true\", true, 0, 1, \"1\", 15, false, undefined, null, NaN, \"NaN\", \"a\", &#123;&#125;, &#123;&#125;, &#123;a:2&#125;, &#123;a:2&#125;]// Map[\"true\", true, 0, 1, \"1\", 15, false, undefined, null, NaN, \"NaN\", \"a\", &#123;&#125;, &#123;&#125;, &#123;a:2&#125;, &#123;a:2&#125;] 将各种方法和去重结果整理成下面的表格： 方法 去重结果 双层循环 ===判断 对象和NaN没去重 indexOf 对象和NaN没去重 filter + indexOf 对象没去重，NaN被忽略掉了 filter + sort 对象和NaN没去重 Set 对象没去重 Map 对象没去重 通过上面的表格，我们可以看出主要是对象和NaN两种类型的元素需要注意。 使用=== 判断两个NaN是否相等，得到的结果为false。 优化：数组元素包含对象的去重如果元素是对象，我们利用Object键值对的方式来进行去重，利用JSON.stringify将对象序列化后存为Object的key值，比如：Object[value]=1，在判断另一个元素时，如果Object[value2]存在的话，说明该值重复。 如果元素不是对象，我们使用includes来判断新的数组res中是否有当前值。 实现代码如下： 12345678910111213141516171819202122var array = ['true','true',true,true,0,0,1,1,'1','1',15,15,false,false,undefined,undefined,null,null,NaN,NaN,'NaN','NaN','a','a',&#123;&#125;,&#123;&#125;,&#123;a:2&#125;,&#123;a:2&#125;];function unique(arr) &#123; var res = [] var obj = &#123;&#125; arr.forEach(item =&gt; &#123; if (typeof item !== 'object') &#123; if (!res.includes(item)) &#123; res.push(item) &#125; &#125; else &#123; var valueStr = JSON.stringify(item) if (!obj[valueStr]) &#123; res.push(item) obj[valueStr] = 1 &#125; &#125; &#125;) return res&#125;console.log(unique(array))// [\"true\", true, 0, 1, \"1\", 15, false, undefined, null, NaN, \"NaN\", \"a\", &#123;&#125;, &#123;a:2&#125;] 总结数组去重是开发中经常会碰到的一个问题，我们可以根据不同的应用场景来选择不同的实现方式。如果数组中不包含对象，我们可以直接使用Set进行去重，如果存在对象，则可以选择最后Object键值对的方式。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"},{"name":"数组去重","slug":"数组去重","permalink":"http://www.chenhanpeng.com/tags/数组去重/"}]},{"title":"JavaScript-数组扁平化","slug":"javascript/JavaScript数组扁平化","date":"2020-06-20T08:28:25.000Z","updated":"2021-04-21T01:17:30.940Z","comments":true,"path":"javascript-array-flatten/","link":"","permalink":"http://www.chenhanpeng.com/javascript-array-flatten/","excerpt":"","text":"上一篇文章我们将JavaScript中数组的方法汇总了一下，本文我们一起来看看JavaScript数组常见的一个问题：数组扁平化。 什么是数组扁平化数组扁平化：就是讲一个复杂的嵌套多层的数组，一层一层地转化为层级较少或者只有一层的数组。 下面我们通过实际例子来看看都有哪些解决方法：123let array = [1, [2, [3, [4, 5]]]]// 需要将上面的array展开得到下面的一维数组[1, 2, 3, 4, 5] 欢迎关注我的微信公众号：前端极客技术(FrontGeek) flat()从上一篇文章中我们可以知道，在ES6 新增的flat()方法可以用于将嵌套的数组“拉平”，变成一维的数组。 12let array = [1, [2, [3, [4, 5]]]]array.flat() // [1, 2, [3, [4, 5]]] 但是flat()方法默认只会“拉平”一层，如果不管多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。12let array = [1, [2, [3, [4, 5]]]]array.flat(Infinity) // [1, 2, 3, 4, 5] replace + JSON.parse除了直接使用上面说的flat()方法，我们还可以通过replace和JSON.parse方法结合将数组扁平化。 我们先利用JSON.stringify将数组转出JSON字符串，在通过replace方法，利用正则表达式将字符串中的[、]替换成掉，再在字符串首尾加上[]，最后利用JSON.parse方法将字符串重新转为数组。 12345let array = [1, [2, [3, [4, 5]]]]let str = JSON.stringify(array) // \"[1,[2,[3,[4,5]]]]\"str = str.replace(/(\\[|\\])/g, '') // \"1,2,3,4,5\"str = '[' + str + ']' // \"[1,2,3,4,5]\"let arr = JSON.parse(str) // [1, 2, 3, 4, 5] 递归除了上面两种方法，我们比较容易想到的是循环数组元素，如果元素还是一个数组，就递归调用该方法。实现代码如下： 123456789101112131415let array = [1, [2, [3, [4, 5]]]]function flatten(arr) &#123; let result = [] for (let i = 0; i &lt; arr.length; i++) &#123; if (Array.isArray(arr[i])) &#123; result = result.concat(flatten(arr[i])) &#125; else &#123; result.push(arr[i]) &#125; &#125; return result&#125;console.log(flatten(array)) // [1, 2, 3, 4, 5] reduce函数迭代从上面递归的方法来看，其实就是对数组进行处理，最终返回一个一维数组，那么我们可以考虑使用 reduce 来简化代码： 123456789let array = [1, [2, [3, [4, 5]]]]function flatten(arr) &#123; return arr.reduce(function (prev, next) &#123; return prev.concat(Array.isArray(next) ? flatten(next) : next) &#125;, [])&#125;console.log(flatten(array)) // [1, 2, 3, 4, 5] 扩展运算符…ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象中。 我们先通过下面的例子来看看扩展运算符的用法：123let array = [1, [2, [3, [4, 5]]]]console.log([].concat(...array)) // [1, 2, [3, [4, 5]]] 我们可以使用扩展运算符对递归方法进行修改，具体代码如下：12345678910let array = [1, [2, [3, [4, 5]]]]function flatten(arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr) &#125; return arr&#125;console.log(flatten(array)) // [1, 2, 3, 4, 5]","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"},{"name":"数组扁平化","slug":"数组扁平化","permalink":"http://www.chenhanpeng.com/tags/数组扁平化/"}]},{"title":"JavaScript-数组方法汇总","slug":"javascript/JavaScript数组方法汇总","date":"2020-06-15T06:52:59.000Z","updated":"2021-04-21T01:17:31.031Z","comments":true,"path":"javascript-array-methods/","link":"","permalink":"http://www.chenhanpeng.com/javascript-array-methods/","excerpt":"","text":"valueOf()、toString()valueOf()和toString()是JavaScript对象的通用方法。 valueOf()表示对该对象求值。不同的对象的valueOf方法不尽一致，数组的valueOf方法返回数组的本身。 12345let array = [1, 2, 3]array.valueOf() // [1, 2, 3]let array1 = [1, 3, 3, 'a', [1, 2, 3]]array1.valueOf() // [1, 3, 3, 'a', [1, 2, 3]] toString()返回的是数组的字符串形式。12345let array = [1, 2, 3]array.toString() // 1,2,3let array1 = [1, 3, 3, 'a', [1, 2, 3], &#123;obj: 1&#125;]array1.toString() // 1,3,3,a,1,2,3,[object Object] 欢迎关注我的微信公众号：前端极客技术(FrontGeek) Array.isArray()该方法返回一个布尔值，表示参数是否为数组。 因为数组本质上是一种特殊的对象，所以typeof运算符会返回数组的类型为object。使用Array.isArray方法可以识别数组，可以弥补typeof运算符的不足。 1234let array = [1, 2, 3]typeof array // objectArray.isArray(array) // true 添加：push()、unshift()push()方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度，该方法会改变原数组。 1234567let array = [1, 3]array.push(2)array.push('a', 'b')array.push(true, &#123;&#125;)console.log(array) // [1, 3, 2, \"a\", \"b\", true, &#123;&#125;] unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度，该方法会改变原数组。 unshift()可以接受多个参数，这些参数都会添加到目标数组头部。1234567let array = [1, 2, 3]array.unshift('a')array.unshift('b', 'c')console.log(array) // [\"b\", \"c\", \"a\", 1, 2, 3] 删除：pop()、shift()pop()方法用于删除数组的最后一个元素，并返回该元素，该方法会改变原数组。 如果对空数组使用pop方法，不会报错，而是返回undefined 123456let array = [1, 3, 3, 4]console.log(array.pop()) // 4console.log(array) // [1, 3, 3][].pop() // undefined shift()方法用于删除数组的第一个元素，并返回该元素，该方法会改变原数组。 1234let array = [1, 3, 3, 4]array.shift()console.log(array) // [3, 3, 4] push和pop两个方法结合使用，就构成了“后进后出”的栈结构（stack）。 push和shift结合使用，构成了“先进先出”的队列结构（queue）。 join()join方法以指定参数作为分隔符，将所有数组成员连接成一个字符串返回。如果没有提供参数，默认逗号分隔。 如果数组成员是undefined或null或空位，会被转成空字符串。 12345let array = [1, 2, 3, 4, ,, null, undefined]console.log(array.join()) // 1,2,3,4,,,,console.log(array.join(' ')) // 1 2 3 4 console.log(array.join('-')) // 1-2-3-4---- 通过call方法，join也可以用于字符串或者类似数组的对象。1234Array.prototype.join.call('hello', '-') // h-e-l-l-olet obj = &#123;0: 'a', 1: 'b', 2: 'c', length: 3&#125;Array.prototype.join.call(obj, '-') // a-b-c 合并：concat()concat方法用于多个数组的合并，它将新数组的成员，添加到原数组成员的后面，然后返回一个新数组，原数组不变。 1234567891011['hello'].concat(['world'])// [\"hello\", \"world\"]['hello'].concat(['world'], ['!'])// [\"hello\", \"world\", \"!\"][].concat(&#123;a: 1&#125;, &#123;b: 2&#125;)// [&#123; a: 1 &#125;, &#123; b: 2 &#125;][2].concat(&#123;a: 1&#125;)// [2, &#123;a: 1&#125;] concat还可以接受其他类型的值作为参数，添加到目标数组尾部。12[1, 2, 3].concat(4, 5, 6)// [1, 2, 3, 4, 5, 6] 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。 1234567var obj = &#123; a: 1 &#125;;var oldArray = [obj];var newArray = oldArray.concat();obj.a = 2;newArray[0].a // 2 reverse()reverse()方法用于颠倒排列数组元素，返回改变后的数组。 1234let array = [1, 2, 3, 4]array.reverse()array // [4, 3, 2, 1] splice()splice()方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回的是被删除的元素。 1arr.splice(start, count, addElement1, addElement2, ...); splice的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面有更多的参数，表示这些是要被插入数组的元素。 如果起始位置是负数，表示从倒数位置开始删除。 12345678910let arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g']arr.splice(1, 2) // [\"b\", \"c\"]arr // ['a', 'd', 'e', 'f', 'g']arr.splice(0, 1, 1, 2, 3, 4)arr // [1, 2, 3, 4, \"d\", \"e\", \"f\", \"g\"]arr.splice(-6, 4)arr // [1, 2, \"f\", \"g\"] sort()对数组成员进行排序，默认按照字典顺序排序。排序后，原数组将被改变。 如果要自定义排序方式，可以传入一个函数作为参数。 123456789let array = [1, 4, 3, 'a', 6, 2, 1, 10, 98, 7]array.sort()array // [1, 1, 10, 2, 3, 4, 6, 7, 98, \"a\"]// 降序let array1 = [1, 4, 3, 6, 2, 1, 10, 98, 7]array1.sort((a, b) =&gt; b - a)array1 // [98, 10, 7, 6, 4, 3, 2, 1, 1] map()将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。 123456let array = [1, 3, 5]let new_array = array.map(function(n) &#123; return n + 2&#125;)console.log(new_array) // [3, 5, 7]console.log(array) // [1, 3, 5] 调用参数函数时，map向函数传入三个参数：当前成员、当前位置、数组本身。123456let array = [1, 3, 5]let new_array = array.map(function(n, index, arr) &#123; console.log(n, index, arr) return n * index&#125;)console.log(new_array) 此外，map方法还可以接受第二个参数，用来绑定回调函数内部的this变量123456var arr = ['a', 'b', 'c'];[1, 2].map(function (e) &#123; return this[e];&#125;, arr)// ['b', 'c'] filter()用于过滤数组成员，满足条件的成员组成一个新数组返回。 1234[1, 2, 3, 4, 5].filter(function (elem) &#123; return (elem &gt; 3);&#125;)// [4, 5] filter方法和map一样，可以接受第二个参数，用来绑定参数函数内部的this，参数函数可接收三个参数。1234567var obj = &#123; MAX: 3 &#125;;var myFilter = function (item) &#123; if (item &gt; this.MAX) return true;&#125;;var arr = [2, 8, 3, 4, 1, 3, 2, 9];arr.filter(myFilter, obj) // [8, 4, 9] some()、every()这两个方法接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置、整个数组，然后返回一个布尔值，表示判断数组成员是否符合某个条件。 some()方法只要一个成员的返回值为true，则整个some方法的返回值就是true，否则返回false。 1234let array = [1, 3, 5, 7]array.some(function(el, index, arr) &#123; return el &gt; 5&#125;) // true every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。1234let array = [1, 3, 5, 7]array.some(function(el, index, arr) &#123; return el &gt; 1&#125;) // false 对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。 reduce()、reduceRight()reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。 reduce是从左到右处理，reduceRight是从右到左处理。 1array.reduce(func, defaultValue) reduce和reduceRight接收两个参数，第一个是函数，第二个是累积变量初始值。 第一个参数函数接受下面四个参数： 累积变量，默认为数组的第一个成员（必须） 当前变量，默认为数组的第二个成员（必须） 当前位置，从0开始（可选） 原数组（可选） 累积变量初始值是个可选参数。 1234[1, 2, 3, 4, 5].reduce(function (a, b) &#123; return a + b;&#125;, 10);// 25 indexOf()、lastIndexOf()indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。该方法可接受第二个参数，用来指定搜索开始的位置。 12['a', 'b', 'd'].indexOf('b') // 1['a', 'b', 'd'].indexOf('b', 2) // -1 lastIndexOf方法返回给定元素的最后一次出现的位置，如果没有出现返回-1。 123var a = [2, 5, 9, 2];a.lastIndexOf(2) // 3a.lastIndexOf(7) // -1 这两个方法不能用来搜索NaN的位置，因为方法内部使用严格相等运算符===进行比较，而NaN是唯一一个不等于自身的值。 下面我们来看下ES6新增的数组方法： Array.from()用来将下面两类对象转为真正的数组。 类似数组的对象（array-like object） 可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map） Array.from()会将数组的空位转为undefined 12345678910111213141516// 类似数组的对象let arrayLike = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;// ES5 写法let newArr1 = [].slice.call(arrayLike) // [\"a\", \"b\", \"c\"]// ES6 写法let newArr2 = Array.from(arrayLike) // [\"a\", \"b\", \"c\"]// 可遍历的对象Array.from('hello') // [\"h\", \"e\", \"l\", \"l\", \"o\"]let set = new Set(['a', 'b', 'c'])Array.from(set) // ['a', 'b', 'c'] Array.of()用于将一组值转换为数组。如果没有参数则返回一个空数组。 1Array.of(1, 2, 3, 4) // [1, 2, 3, 4] 数组实例的 copyWithin()在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。 copyWithin()会连空位一起拷贝。 1Array.prototype.copyWithin(target, start = 0, end = this.length) target：必需，从该位置开始替换数据，如果为负值，表示倒数。 start：可选，从该位置开始读取数据，默认为0。如果为负值，表示从尾部开始计算。 end：可选，到该位置停止读取数据，默认为数组长度，如果为负值，表示从末尾开始计算。 123[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5] 数组实例的 find()和findeIndex()find：找出第一个符合条件的数组成员。参数是一个回调函数。如果没有符合条件的成员，返回undefined 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 findIndex的用法和find方法类似，返回第一个符合条件的数组成员的位置，如果没有符合条件的成员，返回-1。123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 数组实例的 fill()fill方法使用给定值，填充一个数组。 如果数组中已有元素，会被全部抹去。 fill方法还可以接受第二个和第三个参数，用来指定填充的起始和结束位置。 fill()会将空位视为正常的数组位置。 12345[1, 2, 3].fill(4) // [4, 4, 4]new Array(3).fill(4) // [4, 4, 4][1, 2, 3, 4, 5].fill(10, 1, 3) // [1, 10, 10, 4, 5] 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 123456789let arr = new Array(3).fill(&#123;name: \"Mike\"&#125;);arr[0].name = \"Ben\";arr// [&#123;name: \"Ben\"&#125;, &#123;name: \"Ben\"&#125;, &#123;name: \"Ben\"&#125;]let arr = new Array(3).fill([]);arr[0].push(5);arr// [[5], [5], [5]] 数组实例的 entries()、keys()、values()这三个是ES6新增的三个用于遍历数组的方法。它们都返回一个遍历器对象，可用for…of循环进行遍历。 keys()是对键名的遍历，values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 可以用该方法判断数组中是否有NaN12[NaN].includes(NaN)// true 数组实例的 flat()、flatMap()flat()Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 flat()默认只会“拉平”一层，如果要“拉平”多层嵌套数组，可以将flat()方法的参数写成一个整数，表示要拉平的层数。 如果不管多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 如果原数组存在空位，flat方法会跳过空位。 12345678[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5][1, [2, [3]]].flat(Infinity)// [1, 2, 3] flatMap()flatMap方法对原数组的每个成员执行一个函数，然后对返回值组成的数组执行flat方法。该方法返回一个新的数组。 flatMap方法只能“拉平”一层数组。12345[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8][1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])// [[2], [4], [6], [8]] flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。123arr.flatMap(function callback(currentValue[, index[, array]]) &#123; // ...&#125;[, thisArg]) flatMap方法可以有第二个参数，用来绑定遍历函数中的this 参考资料： https://wangdoc.com/javascript/stdlib/array.html https://es6.ruanyifeng.com/#docs/array","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"},{"name":"数组方法","slug":"数组方法","permalink":"http://www.chenhanpeng.com/tags/数组方法/"}]},{"title":"JavaScript-函数节流","slug":"javascript/JavaScript节流","date":"2020-05-06T01:00:54.000Z","updated":"2021-04-21T01:17:31.278Z","comments":true,"path":"javascript-throttle/","link":"","permalink":"http://www.chenhanpeng.com/javascript-throttle/","excerpt":"","text":"在上一篇文章 JavaScript-函数防抖 中我们学习了什么是防抖，并且一步步实现了防抖函数，今天我们一起来学习节流(throttle)。 什么是节流函数节流(throttle)：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。简单的说，就是让一个函数无法在很短时间间隔内被连续调用，只有当上一次函数执行后过了规定的时间间隔，才能进行下一次函数的执行。 函数节流主要有两种实现方法：时间戳和定时器。 欢迎关注我的微信公众号：前端极客技术(FrontGeek) 节流的实现时间戳思路只要触发，就用Date方法获取当前时间 now，与上一次调用的时间 previous 作比较 如果时间差大于等于规定的时间间隔，就执行一次目标函数，执行以后，将存储上一次调用时间previous的值更新为当前时间now 如果时间差小于规定的时间间隔，则等待下一次触发重新进行第一步操作。 代码实现1234567891011121314// delay：规定的时间间隔function throttle(func, delay) &#123; var context, args var previous = 0 return function() &#123; context = this args = arguments var now = +new Date() if (now - previous &gt;= delay) &#123; func.apply(context, args) previous = now &#125; &#125;&#125; 我们依旧采用防抖那篇文章用到的鼠标移动的例子来验证节流，调用节流函数方式如下： 1container.onmousemove = throttle(mouseMove, 2000) 效果如下： 从上图中可以看到：当鼠标移入时，事件立即执行，每过2秒会执行一次，假设在第7秒时移出，停止触发，以后不会再执行事件。 定时器思路用定时器实现时间间隔。 当定时器不存在，说明可以执行函数，定义一个定时器来向任务队列注册目标函数。目标函数执行后设置保存定时器ID变量为空 当定时器已经被定义，说明已经在等待过程中，则等待下次触发事件时再进行查看。 代码实现1234567891011121314function throttle(func, delay) &#123; var timeout = null var context, args return function() &#123; context = this args = arguments if (!timeout) &#123; timeout = setTimeout(function() &#123; timeout = null func.apply(context, args) &#125;, delay) &#125; &#125;&#125; 代码执行效果如下： 从上面的动图我们可以看到：鼠标移入时，事件不会立即执行，之后每隔2秒执行一次，假设在第5秒时移出，事件停止触发，但在第6秒时依旧会执行一次事件。 两者区别： 时间戳实现：触发事件一发生先执行目标函数，然后再等待规定的时间间隔再次执行目标函数。如果在等待过程中停止触发，后续不会再执行目标函数。 定时器实现：触发事件一发生，先等待够规定的时间间隔再执行目标函数。即使在等待过程中停止触发，若定时器已经在任务队列里注册了定时器，也会执行最后一次。 强强联合：时间戳+定时器如果我们想要能够控制鼠标移入能够立即执行，停止触发的时候能够再执行一次，我们可以综合时间戳和定时器两种方法来实现“有头有尾”的效果。 在这里我们需要注意：控制好在上一周期的“尾”和下一周期的“头”之间时间间隔，我们引入变量remaining表示还需要等待的时间，来让尾部那一次的执行也符合时间间隔。 代码实现12345678910111213141516171819202122232425262728function throttle(func, delay) &#123; var timeout, context, args, result var previous = 0 var throttled = function() &#123; context = this args = arguments var now = +new Date() // 下次触发func剩余时间 var remaining = delay - (now - previous) // 如果没有剩余的时间了或者你改了系统时间 if (remaining &lt;= 0 || remaining &gt; delay) &#123; if (timeout) &#123; clearTimeout(timeout) timeout = null &#125; func.apply(context, args) previous = now &#125; else if (!timeout) &#123; timeout = setTimeout(function()&#123; previous = +new Date() timeout = null func.apply(context, args) &#125;, remaining) &#125; &#125; return throttled&#125; 代码执行效果如下： 优化在上面结合时间戳和定时器的解法的基础上，如果我们想实现是否启用第一次 / 尾部最后一次计时回调的执行，如何实现？ 我们可以设置个options作为第三个参数，然后根据传的值判断到底哪种效果，我们约定： leading：false表示禁用第一次执行 trailing：false表示禁用停止触发的回调 代码实现如下：1234567891011121314151617181920212223242526272829303132function throttle(func, delay, options) &#123; var timeout, context, args, result var previous = 0 if (!options) options = &#123;&#125; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime() timeout = null func.apply(context, args) if (!timeout) context = args = null &#125; var throttled = function() &#123; var now = new Date().getTime() if (!previous &amp;&amp; options.leading === false) previous = now var remaining = delay - (now - previous) context = this args = arguments if (remaining &lt;= 0 || remaining &gt; delay) &#123; if (timeout) &#123; clearTimeout(timeout) timeout = null &#125; previous = now func.apply(context, args) if (!timeout) context = args = null &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining) &#125; &#125; return throttled&#125; 我们想要第一次立即执行，并且禁用停止触发的回调，调用throttle方法如下：1container.onmousemove = throttle(mouseMove, 2000, &#123;leading: true, trailing: false&#125;) 效果如下图： 取消在防抖函数中，我们实现了cancel方法，在节流函数中，同理： 123456789101112131415function throttle(func, delay, options) &#123; ..... var throttled = function() &#123; .... &#125; throttled.cancel = function() &#123; clearTimeout(timeout) previous = 0 timeout = null &#125; return throttled&#125; 存在的问题至此，一个完整的节流函数已经实现好了，但是仍然存在一个问题：就是 leading：false 和 trailing: false 不能同时设置。 如果同时设置的话，比如当你将鼠标移出的时候，因为 trailing 设置为 false，停止触发的时候不会设置定时器，所以只要再过了设置的时间，再移入的话，就会立刻执行，就违反了 leading: false，bug 就出来了。如下图所示： 总结防抖和节流的作用都是防止函数多次调用。区别在于：假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的情况会每隔一段时间wait调用函数。 相比 debounce，throttle 要更加宽松一些，其目的在于：按频率执行调用。 参考来源：https://github.com/mqyqingfeng/Blog/issues/26","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"},{"name":"节流","slug":"节流","permalink":"http://www.chenhanpeng.com/tags/节流/"}]},{"title":"JavaScript-函数防抖","slug":"javascript/JavaScript防抖","date":"2020-04-29T01:27:20.000Z","updated":"2021-04-21T01:17:31.279Z","comments":true,"path":"javascript-debounce/","link":"","permalink":"http://www.chenhanpeng.com/javascript-debounce/","excerpt":"","text":"前言在前端开发过程中，我们会遇到一些频繁触发的事件，但我们需要控制回调的频率，比如下面几种场景： 游戏中的按键响应，比如格斗，比如射击，需要控制出拳和射击的速率。 自动完成，按照一定频率分析输入，提示自动完成。 鼠标移动和窗口滚动，鼠标稍微移动一下，窗口稍微滚动一下会带来大量的事件，因而需要控制回调的发生频率。 下面我们通过代码来看看mousemove事件是如何频繁触发的： index.html文件代码如下：12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;debounce防抖&lt;/title&gt; &lt;style&gt; #container&#123; width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #444; font-size: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt;&lt;/div&gt; &lt;script src=\"debounce.js\"&gt;&lt;/script&gt; &lt;script&gt; var count = 1; var container = document.getElementById(\"container\"); function mouseMove() &#123; console.log(this); container.innerHTML = count++; &#125;; container.onmousemove = mouseMove &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行该html文件，我们将鼠标在我们定义的矩形区域移动，只是简单的从下往上滑动，mouseMove函数就被触发了99次。 假设mouseMove函数时复杂的回调函数或者是ajax请求，如果我们没有对事件处理函数调用的频率进行限制，会加重浏览器的负担，导致用户体验极差。这时候我们可以采用debounce（防抖）或throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 今天我们主要讲讲防抖。 欢迎关注我的微信公众号：前端极客技术(FrontGeek) 防抖原理函数防抖(debounce)：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 初步实现根据上面防抖的描述，我们可以用setTimeout写第一版防抖函数的实现代码： 1234567function debounce(func, wait) &#123; var timeout return function () &#123; clearTimeout(timeout) timeout = setTimeout(func, wait) &#125;&#125; 在最开始的例子中使用debounce：1container.onmousemove = debounce(mouseMove, 1000) 这样子修改后，只有在我们移动完1s内不再触发，才会执行回调事件mouseMove。 this指向问题我们在mouseMove函数中执行 console.log(this)，会发现不使用debounce和使用debounce情况下，this的值是不一样的。 不使用debounce时this的值为1&lt;div id=&quot;container&quot;&gt;&lt;/div&gt; 而使用debounce函数时，this则会指向window对象。 所以我们需要将this指向正确的函数，这时候我们可以利用apply()方法实现。代码修改如下： 12345678910function debounce(func, wait) &#123; var timeout return function () &#123; var context = this clearTimeout(timeout) timeout = setTimeout(function() &#123; func.apply(context) &#125;, wait) &#125;&#125; 修改完成后，我们再触发事件，可以看到此时this的指向正确了。 event对象JavaScript在事件处理函数中会提供事件对象event，我们将mouseMove函数修改如下： 12345function mouseMove(e) &#123; console.log(this); console.log(e); container.innerHTML = count++;&#125;; 如果不使用debounce函数，控制台打印的e是MouseEvent对象，但当我们调用debounce函数，打印出来的却是undefined。 所以我们再次修改代码如下：123456789101112function debounce(func, wait) &#123; var timeout return function () &#123; var context = this var args = arguments clearTimeout(timeout) timeout = setTimeout(function() &#123; func.apply(context, args) &#125;, wait) &#125;&#125; 至此，我们修复了this指向和event对象问题，整个防抖函数已经算是比较完善了。 立即执行接下来我们再考虑一个新的需求：如果我们希望是在事件一触发就立刻执行函数，而不是等到事件停止触发后再执行；并且等到停止触发n秒后，才可以重新触发执行。 我们可以通过immediate参数来判断是否立刻执行，代码修改如下：12345678910111213141516171819202122232425function debounce(func, wait, immediate) &#123; var timeout return function () &#123; var context = this var args = arguments if (timeout) &#123; clearTimeout(timeout) &#125; if (immediate) &#123; // 已经执行过不再执行 var callNow = !timeout timeout = setTimeout(function() &#123; timeout = null &#125;, wait) if (callNow) &#123; func.apply(context, args) &#125; &#125; else &#123; timeout = setTimeout(function() &#123; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 1container.onmousemove = debounce(mouseMove, 1000, true) 返回值我们需要注意的一点是：mouseMove函数可能是有返回值的，所以我们也要返回函数的执行结果，但是immediate为false的时候，因为使用setTimeout，我们将func.apply(context, args)的返回值赋给变量，最后再return的时候，值会一直是undefined，所以我们只在immediate为true的时候返回函数的执行结果。 1234567891011121314151617181920212223242526function debounce(func, wait, immediate) &#123; var timeout, result return function () &#123; var context = this var args = arguments if (timeout) &#123; clearTimeout(timeout) &#125; if (immediate) &#123; // 已经执行过不再执行 var callNow = !timeout timeout = setTimeout(function() &#123; timeout = null &#125;, wait) if (callNow) &#123; result = func.apply(context, args) &#125; &#125; else &#123; timeout = setTimeout(function() &#123; func.apply(context, args) &#125;, wait) &#125; return result &#125;&#125; 取消假设防抖的时间间隔为10秒，immediate为true的情况下，只有等10秒后才能重新触发事件，这时候我希望有个按钮可以取消防抖，这样我再去触发时，又可以立即执行了。 下面我们来实现这个取消功能：123456789101112131415161718192021222324252627282930313233function debounce(func, wait, immediate) &#123; var timeout, result var debounced = function () &#123; var context = this var args = arguments // 每次新的尝试调用func，会使抛弃之前等待的func if (timeout) clearTimeout(timeout) // 如果允许新的调用尝试立即执行 if (immediate) &#123; // 如果之前尚没有调用尝试，那么此次调用可以立马执行，否则就需要等待 var callNow = !timeout // 刷新timeout timeout = setTimeout(function() &#123; timeout = null &#125;, wait) // 如果能被立即执行，立即执行 if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function() &#123; func.apply(context, args) &#125;, wait) &#125; return result &#125; debounced.cancel = function () &#123; clearTimeout(timeout) timeout = null &#125; return debounced&#125; 如何调用这个cancel函数？1234567var setMouseMove = debounce(mouseMove, 10000, true)container.onmousemove = setMouseMove// buttonClick为button的click事件function buttonClick() &#123; setMouseMove.cancel()&#125; 效果如下： 到这里，一个完整的debounce函数已经实现了。 总结debounce防抖函数，满足的是：高频下只响应一次。 在实际开发过程中，常见的应用场景有： 在输入框快速输入文字（高频），我们只想在其完全停止输入时再对输入文字做处理（一次） ajax，大多数场景下，每个异步请求在短时间内只能响应一次，比如下拉刷新、不停地上拉加载，但只发送一次ajax请求。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://www.chenhanpeng.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenhanpeng.com/tags/JavaScript/"},{"name":"防抖","slug":"防抖","permalink":"http://www.chenhanpeng.com/tags/防抖/"}]},{"title":"LeetCode题解|15.三数之和","slug":"leetcode/LeetCode题解-15-三数之和","date":"2020-03-31T14:14:03.000Z","updated":"2021-04-21T01:17:31.860Z","comments":true,"path":"leetcode-solution-3sum/","link":"","permalink":"http://www.chenhanpeng.com/leetcode-solution-3sum/","excerpt":"","text":"前面我们解决了LeetCode题解|1.两数之和，下面我们升级版题目：三数之和。 题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例：1234567给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路在这题中，主要的难点是如何进行去重。 暴力法通过三次遍历去找出所有的解，这种方法的时间复杂度为O(n^3)，并不推荐。 排序+双指针算法流程：1、针对几种特殊情况判断：数组长度n，如果数组为null或者数组长度小于3，返回[] 2、对数组进行升序排序 3、遍历排序后数组： - 若nums[i] &gt; 0：因为已经排序好，所以后面不可能会有三个数相加等于0，直接返回结果 - 对于重复元素：跳过，避免出现重复解 - 令左指针L = i + 1，右指针 R = n - 1，当L &lt; R时，执行循环。 - 当 nums[i]+nums[L]+nums[R]=0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解 - 若和大于 0，说明 nums[R] 太大，R 左移 - 若和小于 0，说明 nums[L] 太小，L 右移 复杂度分析时间复杂度：O(n^2)，数组排序 O(NlogN)，遍历数组 O(n)，双指针遍历 O(n)，总体 O(NlogN)+O(n)∗O(n)，O(n^2)空间复杂度：O(1) Javascript版本12345678910111213141516171819202122232425262728293031323334var threeSum = function(nums) &#123; let result = []; const len = nums.length; if (nums == null || len &lt; 3) &#123; return result; &#125; nums.sort((a, b) =&gt; a - b); for (let i = 0; i &lt; len; i++) &#123; if (nums[i] &gt; 0) break; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; let L = i + 1; let R = len - 1; while (L &lt; R) &#123; const sum = nums[i] + nums[L] + nums[R]; if (sum == 0) &#123; result.push([nums[i], nums[L], nums[R]]); while (L &lt; R &amp;&amp; nums[L] == nums[L + 1]) &#123; L++; &#125; while (L &lt;R &amp;&amp; nums[R] == nums[R - 1]) &#123; R--; &#125; L++; R--; &#125; else if (sum &lt; 0) &#123; L++; &#125; else &#123; R--; &#125; &#125; &#125; return result;&#125;; Python版本123456789101112131415161718192021222324252627282930class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: n=len(nums) res=[] if(not nums or n&lt;3): return [] nums.sort() res=[] for i in range(n): if(nums[i]&gt;0): return res if(i&gt;0 and nums[i]==nums[i-1]): continue L=i+1 R=n-1 while(L&lt;R): if(nums[i]+nums[L]+nums[R]==0): res.append([nums[i],nums[L],nums[R]]) while(L&lt;R and nums[L]==nums[L+1]): L=L+1 while(L&lt;R and nums[R]==nums[R-1]): R=R-1 L=L+1 R=R-1 elif(nums[i]+nums[L]+nums[R]&gt;0): R=R-1 else: L=L+1 return res","categories":[{"name":"算法","slug":"算法","permalink":"http://www.chenhanpeng.com/categories/算法/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://www.chenhanpeng.com/categories/算法/LeetCode/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/tags/面试/"},{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://www.chenhanpeng.com/tags/LeetCode题解/"}]},{"title":"LeetCode题解|1.两数之和","slug":"leetcode/LeetCode题解-1-两数之和","date":"2020-03-30T01:01:09.000Z","updated":"2021-04-21T01:17:31.833Z","comments":true,"path":"leetcode-solution-two-sum/","link":"","permalink":"http://www.chenhanpeng.com/leetcode-solution-two-sum/","excerpt":"","text":"题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路暴力法暴力法很简单，遍历数组nums中的每个元素x，并通过遍历剩余部分查找是否存在一个值与 target-x 相等。下面是暴力法的代码： python版本12345678910def twoSum(nums, target): lens = len(nums) for i, value in enumerate(nums): diff = target - value j = i + 1 while j &lt; len: if nums[j] == diff return [i, j] j += 1 return [] javascript版本1234567891011var twoSum = function(nums, target) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; var diff = target - nums[i] for (var j = i + 1; j &lt; nums.length; j++) &#123; if (diff === nums[j]) &#123; return [i, j] &#125; &#125; &#125; return []&#125;; 我们来看一下暴力法的复杂度： 时间复杂度：O(n^2) 空间复杂度：O(1) 暴力法实现起来很简单，但时间复杂度很高，容易出现超出时间限制的问题。 哈希表我们可以对运行时间复杂度进行优化，因此我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！ 但是我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 复杂度分析： 时间复杂度：O(n)，我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。 下面我们来看下Python和JavaScript两种语言的实现代码： Python版本在Python中我们可以通过字典来模拟哈希查询的过程。 Python代码实现：12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hasMap = &#123;&#125; for i, num in enumerate(nums): if (target - num) in hasMap: return [hasMap[target - num], i] hasMap[num] = i return [] JavaScript版本在JavaScript中，可以通过对象来模拟哈希查询的过程。 123456789var twoSum = function(nums, target) &#123; var dict = &#123;&#125; for (var i = 0; i &lt; nums.length; i++) &#123; if (dict.hasOwnProperty(target - nums[i])) &#123; return [dict[target - nums[i]], i] &#125; dict[nums[i]] = i &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.chenhanpeng.com/categories/算法/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://www.chenhanpeng.com/categories/算法/LeetCode/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/tags/面试/"},{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://www.chenhanpeng.com/tags/LeetCode题解/"}]},{"title":"2020年腾讯华为前端面经分享","slug":"interview/2020年腾讯华为前端面经分享","date":"2020-03-15T15:57:45.000Z","updated":"2020-08-10T02:19:13.721Z","comments":true,"path":"2020-Tencent-HUAWEI-interview-share/","link":"","permalink":"http://www.chenhanpeng.com/2020-Tencent-HUAWEI-interview-share/","excerpt":"","text":"前言本人是一个工作了两年半的前端菜鸟，之前自我感觉良好，计划着换一份新工作，于是投了腾讯和华为两家，因为疫情的原因，都是电话面试。在没认真准备面试的情况下，结果可想而知，被虐得体无完肤，一轮游。在这里把面试中问到的题目分享出来，供大家参考。 腾讯1、面试官一开始聊了会天，然后说简历写了参与了xxxx和XXX两个项目，那么你觉得哪个项目比较有挑战性，为什么？ 2、简历里写熟悉Vue.js，那么能说下vue.js双向绑定原理吗？ 3、再介绍一下vue.js router原理机制？ 4、实际项目中，在web性能优化方面有什么实践？ 5、在web安全方面，有什么实际的经验？ 华为1、自我介绍 2、介绍一下Vue.js 3、刚才你提到MVVM，那就说介绍一下MVC、MVVM、MVVC 3、组件之间的通信 4、vue.js的响应式原理 5、介绍一下vuex 6、v-if和v-show有什么区别 7、对es6熟吗？（因为回答说不太熟，所以面试官没再问相关内容） 8、原型链 原型作用域 9、说一下什么是闭包，有什么用处？ 10、创建对象的方式，优缺点 11、平时遇到跨域都用什么解决方案？ 12、cookie、localStorage、sessionStorage有什么区别 13、CSS：display的值有哪些 14、float原理 基于盒模型解释一下 15、输入URL到页面渲染完成的过程 16、如何提升页面加载速度 17、webpack打包原理过程 18、webpack用哪些插件 19、有小程序开发经验，那么在小程序开发过程中主要负责的工作 20、简单介绍一下你们的开发部署流程，平时的迭代周期？ 21、平时都用什么开发工具、代码管理工具、 22、在整个开发部署过程中负责哪些工作 23、XX项目的用户量、部署几个节点 结尾不出意外，两场面试都没通过。在这里给要找工作的朋友两点建议（大佬请无视）： 确定要跳槽了，最好提前准备，刷刷题目，看看面经，整理项目中碰到的问题和解决方法 不要一开始就投自己心仪的公司，最好找一两家其他公司热热身 最后，欢迎关注我的公众号：前端极客技术","categories":[{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/categories/面试/"}],"tags":[{"name":"面经分享","slug":"面经分享","permalink":"http://www.chenhanpeng.com/tags/面经分享/"},{"name":"腾讯、华为面试","slug":"腾讯、华为面试","permalink":"http://www.chenhanpeng.com/tags/腾讯、华为面试/"}]},{"title":"Flutter | 6-路由管理","slug":"flutter/6_路由管理","date":"2020-01-28T16:22:10.000Z","updated":"2021-04-21T01:17:29.883Z","comments":true,"path":"flutter-route-manager/","link":"","permalink":"http://www.chenhanpeng.com/flutter-route-manager/","excerpt":"","text":"路由（Route）：在移动开发中通常指页面（page）,这跟web开发中单页面应用的Route概念意义是相同的，Route在Android中通常指一个Activity，在iOS中指一个ViewController。 路由管理：就是管理页面之间如何跳转，通常也可被称为导航管理。Flutter中的路由管理和原生开发类似，无论是Android还是iOS，导航管理都会维护一个路由栈，路由入栈（push）操作对应打开一个新页面，路由出栈（pop）操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。 1、简单示例我们在计数器的基础上，创建一个新的路由，命名为“NewRoute”，并在_MyHomePageState.build方法中添加一个跳转到该路由的按钮，具体代码如下： 123456789101112131415import 'package:flutter/material.dart';class NewRoute extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('new route'), ), body: Center( child: Text('这是一个新的route'), ), ); &#125;&#125; 123456789101112131415161718192021222324252627282930313233class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; ... @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ ... FlatButton( child: Text('open new route'), textColor: Colors.red, color: Colors.blue, onPressed: () &#123; Navigator.push(context, MaterialPageRoute(builder: (context) &#123; return NewRoute(); &#125;) ); &#125;, ) ], ), ), ); &#125;&#125; 运行应用结果，点击跳转按钮，如下图所示： 2、MaterialPageRouteMaterialPageRoute继承自PageRoute类，PageRoute类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。MaterialPageRoute是Material组件库提供的组件，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画： 对于Android，当打开新页面时，新的页面会从屏幕底部滑动到屏幕顶部；当关闭页面时，当前页面会从屏幕顶部滑动到屏幕底部后消失，同时上一个页面会显示到屏幕上。 对于iOS，当打开新页面时，新页面会从屏幕右侧边缘一致滑动到屏幕左边，直到新页面全部显示到屏幕上，而上一个页面则会从当前屏幕滑动到屏幕左侧消失；当关闭页面时，正好与打开新页面相反，当前页面会从屏幕右侧滑出，同时上一个页面从左侧滑入。 接下来我们来了解一下MaterialPageRoute 构造函数的各个参数的意义：123456MaterialPageRoute(&#123; WidgetBuilder builder, RouteSettings settings, bool maintainState = true, bool fullscreenDialog = false, &#125;) builder 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。 settings 包含路由的配置信息，如路由名称、是否初始路由（首页）。 maintainState：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为false。 fullscreenDialog表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果fullscreenDialog为true，新页面将会从屏幕底部滑入（而不是水平方向）。 如果想自定义路由切换动画，可以自己继承PageRoute来实现，我们将在后面介绍动画时，实现一个自定义的路由组件。 3、NavigatorNavigator是一个路由管理的组件，它提供了打开和退出路由页方法。Navigator通过一个栈来管理活动路由集合。通常当前屏幕显示的页面就是栈顶的路由。Navigator提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法： Future push(BuildContext context, Route route)将给定的路由入栈，返回值是一个Future对象，用以接收新路由出栈时的返回数据。 bool pop(BuildContext context, [result])将栈顶路由出栈，result为页面关闭时返回给上一个页面的数据。 Navigator 还有很多其他方法，比如： Navigator.replace 、 Navigator.popUntil等等。 Navigator类中第一个参数为context的静态方法都对应一个Navigator的实例方法， 比如Navigator.push(BuildContext context, Route route)等价于Navigator.of(context).push(Route route) ，下面命名路由相关的方法也是一样的。 4、路由传值很多时候，在路由跳转时我们需要传递一些参数，比如要打开一个物品详情页，我们需要带一个物品id过去，这样详情页才知道要显示那个物品信息。下面我们通过简单的例子来演示新旧路由如何传参。 创建一个 Detail 路由，它接受一个id参数，并将这个id显示到页面上，另外在 Detail中我们添加一个返回按钮，在返回上一个路由的同时会带上一个返回参数，代码如下：1234567891011121314151617181920212223242526272829303132import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';class Detail extends StatelessWidget &#123; Detail(&#123; Key key, @required this.id &#125;) : super(key: key); final id; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('详情页'), ), body: Center( child: Column( children: &lt;Widget&gt;[ Text('参数id: $id'), FlatButton( child: Text('返回'), onPressed: () &#123; Navigator.pop(context, 'ID: $id'); &#125;, ) ], ), ), ); &#125;&#125; 12345678910111213FlatButton( child: Text('跳转到详情页'), textColor: Colors.red[300], color: Colors.blue[100], onPressed: () async &#123; var result = await Navigator.push(context, MaterialPageRoute(builder: (context) &#123; return Detail(id: 123); &#125;) ); print('路由返回值：$result'); &#125;,) 需要说明： 1、提示文案“参数id: $id”中的id是通过Detail的id参数传递给新路由页的。我们可以通过等待Navigator.push(…)返回的Future来获取新路由的返回数据。 2、在Detail中有两种方式可以返回到上一页；第一种方式时直接点击导航栏返回箭头，第二种方式是点击页面中的“返回”按钮。这两种返回方式的区别是前者不会返回数据给上一个路由，而后者会。下面是分别点击页面中的返回按钮和导航栏返回箭头后，RouterTestRoute页中print方法在控制台输出的内容：12I/flutter (22361): 路由返回值：ID: 123I/flutter (22361): 路由返回值：null 上面介绍的是非命名路由的传值方式，命名路由的传值方式会有所不同，我们会在下面介绍命名路由时介绍。 5、命名路由所谓命名路由（Named Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由，这为路由管理带来了一种直观、简单的方式。 路由表要使用命名路由，必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名字对应哪个路由组件。其实注册路由表就是给路由起名字，路由表的定义如下：1Map&lt;String, WidgetBuilder&gt; routes; 路由表是一个Map，key为路由的名字，是个字符串；value是个builder回调函数，用于生成相应的路由widget。我们在通过路由名字打开新路由时，应用会根据路由名字在路由表中查找到相应的WidgetBuilder回调函数，然后调用该回调函数生成路由widget并返回。 注册路由表路由表的注册方式很简单，回到前面用到的例子，找到MaterialApp，添加routes属性，代码如下：1234567891011121314151617181920class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), // home: MyHomePage(title: 'Flutter Demo Home Page'), initialRoute:\"/\", //名为\"/\"的路由作为应用的home(首页) //注册路由表 routes:&#123; \"new_route\":(context) =&gt; NewRoute(), \"detail\":(context) =&gt; Detail(id: 1111,), \"/\":(context) =&gt; MyHomePage(title: 'Flutter Demo Home Page'), //注册首页路由 &#125; ); &#125;&#125; 通过路由名打开新路由页要通过路由名称来打开新路由，可以使用 Navigator 的 pushNamed 方法：1Future pushNamed(BuildContext context, String routeName,&#123;Object arguments&#125;) Navigator 除了pushNamed 方法，还有 pushReplacementNamed等其他管理命名路由的方法。 下面我们修改前面两个按钮的onPressed回调函数，通过路由名打开页面：1234567891011121314151617FlatButton( child: Text('open new route'), textColor: Colors.red, color: Colors.blue, onPressed: () &#123; Navigator.pushReplacementNamed(context, \"new_route\"); &#125;,),FlatButton( child: Text('跳转到详情页'), textColor: Colors.red[300], color: Colors.blue[100], onPressed: () async &#123; var result = await Navigator.pushNamed(context, \"detail\"); print('路由返回值：$result'); &#125;,) 命名路由参数传递在Flutter最初的版本中，命名路由是不能传递参数的，后来才支持了参数；下面展示命名路由如何传递并获取路由参数： 我们先注册一个路由：123routes:&#123; \"new_page\":(context) =&gt; NewPage(), &#125; , 在路由页通过RouteSetting对象获取路由参数：123456789class NewPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; //获取路由参数 var args=ModalRoute.of(context).settings.arguments; //...省略无关代码 &#125;&#125; 在打开路由时传递参数1Navigator.of(context).pushNamed(\"new_page\", arguments: \"hello world\"); 6、路由生成钩子假设我们要开发一个电商APP，当用户没有登录时可以看店铺、商品等信息，但交易记录、购物车、用户个人信息等页面需要登录后才能看。为了实现上述功能，我们需要在打开每一个路由页前判断用户登录状态！如果每次打开路由前我们都需要去判断一下将会非常麻烦，那有什么更好的办法吗？答案是有！ MaterialApp有一个onGenerateRoute属性，它在打开命名路由时可能会被调用，之所以说可能，是因为当调用Navigator.pushNamed(...)打开命名路由时，如果指定的路由名在路由表中已注册，则会调用路由表中的builder函数来生成路由组件；如果路由表中没有注册，才会调用onGenerateRoute来生成路由。onGenerateRoute回调签名如下：1Route&lt;dynamic&gt; Function(RouteSettings settings) 有了onGenerateRoute回调，要实现上面控制页面权限的功能就非常容易：我们放弃使用路由表，取而代之的是提供一个onGenerateRoute回调，然后在该回调中进行统一的权限控制，如：1234567891011MaterialApp( ... //省略无关代码 onGenerateRoute:(RouteSettings settings)&#123; return MaterialPageRoute(builder: (context)&#123; String routeName = settings.name; // 如果访问的路由页需要登录，但当前未登录，则直接返回登录页路由， // 引导用户登录；其它情况则正常打开路由。 &#125; ); &#125;); 注意，onGenerateRoute只会对命名路由生效。 总结命名路由只是一种可选的路由管理方式，在实际开发中，还有其他方式供开发者自行选择。 另外，还有一些关于路由管理的内容我们没有介绍，比如路由MaterialApp中还有navigatorObservers和onUnknownRoute两个回调属性，前者可以监听所有路由跳转动作，后者在打开一个不存在的命名路由时会被调用，由于这些功能并不常用，而且也比较简单，我们便不再花费篇幅来介绍了，读者可以自行查看API文档。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"Flutter","slug":"前端/Flutter","permalink":"http://www.chenhanpeng.com/categories/前端/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.chenhanpeng.com/tags/Flutter/"},{"name":"路由","slug":"路由","permalink":"http://www.chenhanpeng.com/tags/路由/"}]},{"title":"Python从小白到攻城狮(21)——使用Pillow库进行图像处理","slug":"python_series/python_21_使用Pillow库进行图像处理","date":"2020-01-19T16:00:00.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-pillow-deal-images/","link":"","permalink":"http://www.chenhanpeng.com/python-pillow-deal-images/","excerpt":"","text":"用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python的第三方模块来完成这些操作。 本篇文章我们一起来学习如何用Python对图像进行处理。 计算机图像相关知识在介绍Python操作图像之前，我们要先来了解一下计算机图像的相关知识。 颜色在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个RGB值或者RGBA值，其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度。 常见的几个颜色的RGBA值如下： 名称 RGBA值 名称 RGBA值 White (255, 255, 255, 255) Red (255, 0, 0, 255) Green (0, 255, 0, 255) Blue (0, 0, 255, 255) Gray (128, 128, 128, 255) Yellow (255, 255, 0, 255) Black (0, 0, 0, 255) Purple (128, 0, 128, 255) 像素对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方格都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素(pixel)。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。 用Pillow操作图像Pillow是由著名的Python图像处理库PIL发展出来的一个分支，如今已经发展成为比PIL本身更具活力的图像处理库。pillow可以说已经取代了PIL。通过Pillow可以实现图像压缩和图像处理等各种操作。 安装Pillow可以使用下面的命令安装Pillow。1pip install pillow 图片的读写操作读取图像Pillow中最为重要的是Image类，读取和处理图像都要通过这个类来完成。要想以文件的方式读取图片，可以使用Image模块的open()方法：12345678from PIL import Image# 打开图片文件image = Image.open('./test.jpg')# 查看图片属性print(image.format, image.size, image.mode)# 显示加载的图像image.show() 如果图片文件打开失败，会提示IOError错误。 如果读取图片操作成功，我们可以查看图片的属性。 format这个属性代表图片文件的扩展名，如果图片文件打开失败，则其值为None。 size属性代表图片的大小，以像素为单位，使用包含两个元素的元组来返回。 mode属性代表图片的band属性，一般情况（黑白）下为“L”，当图片是彩色的时候是“RGB”，如果图片经过压缩，则是“CMYK”。 修改图片的格式Python的图像处理库支持绝大多数的图片格式. 直接使用来自 Image 模块的 open() 方法就能从硬盘读取图片文件. 不需要你来区分不同的图片格式, 这个库会自动匹配对应的解码器来打开图片文件. 直接使用来自 Image 模块的 save() 方法来保存图片文件. 当你保存图片文件的时候, 文件名显得尤为重要. 除非你指定扩展名, 默认情况下是自动沿袭本地存储格式的.第二个参数支持 save() 方法来指定图片的扩展名. 如果使用了非标准的扩展名, 则必须加上第二个参数.1image1 = Image.open('./test1.jpg').save('test1.png') 生成缩略图123size = 128, 128image.thumbnail(size)image.show() 值得注意的是, 库默认情况下是不会解码光栅图片数据除非是必须的. 当你打开一个文件的时候, 文件的头部将被用来识别文件扩展名和大小等等属性, 但是剩下的数据不会马上被处理. 这也暗示了打开一个图片其实是一个很快的操作, 只关乎到文件大小和压缩方式。 裁剪、粘贴和合成图片Image类包含了可以让你操作图片的方法，当你想从图片截取一部分的时候，直接使用crop()方法。 裁剪图像123image = Image.open('./test.jpg')rect = 80, 20, 310, 360image.crop(rect).show() 这个图像区域由含有4个元素的元组组成, 这四个元素分别代表 (左, 上, 右, 下). Python Imaging Library 使用(0, 0)来表示在左上角的情况. 另外值得注意的是, 这些坐标的单位是像素(px), 所以上面的例子实际上表示了 230x340 像素. 这个图像区域现在可以在某些情况下进行处理. 黏贴图像123456image1 = Image.open('./test.jpg')image2 = Image.open('./test1.jpg')rect = 0, 00, 200, 200image2_head = image2.crop(rect)image1.paste(image2_head, (172, 40))image1.show() 效果如下图： 几何变换PIL.Image.Image类包含了resize()和rotate() 方法来操作图像。前者需要传入一个表达新大小的元组，后者则需要传入旋转的角度。 缩放123image2 = Image.open('./test1.jpg')width, height = image2.sizeimage2_head.resize((int(width / 1.5), int(height / 1.5)) 旋转和翻转123image = Image.open('./test.jpg')image.rotate(180).show()image.transpose(Image.FLIP_LEFT_RIGHT).show() 使用rotate()也能完成transpose(ROTATE)操作，把expand参数设置为True来同时修改图片的尺寸。 修改图片方向的一般方法是使用transform()方法。 色彩转换Python Imaging Library 允许你使用 convert() 方法, 以像素为单位修改图像. 模式转换1im = Image.open(\"lena.ppm\").convert(\"L\") 这个库支持 “L” 模式和 “RGB” 模式的互相转换. 要想转换到其它的模式, 可能需要使用一个中介模式, 比如 “RGB”. 滤镜效果ImageFilter 模块内置一个预定义的图像效果增强的滤镜, 可用 filter() 方法来实现效果增强。 ImageFilter类中预定义了多种滤镜方法，如 BLUR（模糊滤镜）、CONTOUR（轮廓滤镜）、DETAIL（细节滤镜）、EDGE_ENHANCE（边界增强滤镜）、EDGE_ENHANCE_MORE（边界增强滤镜，程度更深）、EMBOSS（浮雕滤镜）等等。 1234from PIL import Image, ImageFilterimage = Image.open('./test1.jpg')image.filter(ImageFilter.CONTOUR).show() 使用轮廓滤镜效果如下图所示： 操作像素123456image = Image.open('./res/guido.jpg')for x in range(80, 310): for y in range(20, 360): image.putpixel((x, y), (128, 128, 128))image.show() 完整的示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"Pillow库","slug":"Pillow库","permalink":"http://www.chenhanpeng.com/tags/Pillow库/"},{"name":"图像处理","slug":"图像处理","permalink":"http://www.chenhanpeng.com/tags/图像处理/"}]},{"title":"Python从小白到攻城狮(20)——使用SMTP和POP模块实现收发电子邮件","slug":"python_series/python_20_使用SMTP和POP模块实现收发电子邮件","date":"2020-01-16T16:00:00.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-smtp-and-pop-email/","link":"","permalink":"http://www.chenhanpeng.com/python-smtp-and-pop-email/","excerpt":"","text":"Email的历史比Web还要久远，直到现在，Email也是互联网上应用非常广泛的服务。 几乎所有的编程语言都支持发送和接收电子邮件，接下来我们一起用Python来实现电子邮件的收发。 SMTP发送电子邮件SMTP是发送邮件的协议，python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。 Python对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtplib负责发送邮件。 发送纯文本邮件首先，我们来构造一个纯文本邮件： 邮件正文：构造MIMEText对象时，第一个参数就是邮件正文，第二个参数是MIME的subtype，传入&#39;plain&#39;表示纯文本，最终的MIME就是&#39;text/plain&#39;，最后一定要用utf-8编码保证多语言兼容性。 由于邮件主题、如何显示发件人、收件人等信息并不是通过SMTP协议发给MTA，而是包含在发给MTA的文本中的，所以，我们必须把From、To和Subject添加到MIMEText中。 我们编写了一个函数format_addr()来格式化一个邮件地址。注意不能简单地传入name &lt;addr@example.com&gt;，因为如果包含中文，需要通过Header对象进行编码。 msg[&#39;To&#39;]接收的是字符串而不是list，如果有多个邮件地址，用,分隔即可。 我们用set_debuglevel(1)就可以打印出和SMTP服务器交互的所有信息。SMTP协议就是简单的文本命令和响应。login()方法用来登录SMTP服务器，sendmail()方法就是发邮件，由于可以一次发给多个人，所以传入一个list，邮件正文是一个str，as_string()把MIMEText对象变成str。 然后，通过SMTP发出去，完整代码如下： 12345678910111213141516171819202122232425262728293031323334from email.mime.text import MIMETextfrom email import encodersfrom email.header import Headerfrom email.utils import parseaddr, formataddrimport smtplib# 格式化邮件地址，并用Header对象进行编码（防止包含中文）def format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, 'utf-8').encode(), addr))# 输入Email地址和口令from_address = '*********@qq.com'from_account_password = '****************' # 第三方登录邮箱的授权码，QQ邮箱为16位授权码# 输入收件人地址to_address = '******@163.com'message = MIMEText('This email is sended by Python', 'plain', 'utf-8')# 设置发件人信息message['From'] = format_addr('Python开发 &lt;%s&gt;' % from_address)# 设置收件人信息message['To'] = format_addr('学员 &lt;%s&gt;' % to_address)# 设置邮件主题message['Subject'] = Header('学习使用Python发送邮件', 'utf-8').encode()# 输入SMTP服务器地址smtp_server = 'smtp.qq.com'# SMTP协议默认端口为25server = smtplib.SMTP(smtp_server, 25)server.set_debuglevel(1)server.login(from_address, from_account_password)server.sendmail(from_address, [to_address], message.as_string())server.quit() 发送成功的话，我们在收件人邮箱中收到刚刚发送的邮件，如下图所示： 你看到的收件人的名字很可能不是我们传入的学员，因为很多邮件服务商在显示邮件时，会把收件人名字自动替换为用户注册的名字，但是其他收件人名字的显示不受影响。 发送HTML邮件如果我们要发送HTML邮件，而不是普通的纯文本邮件，只需在构造MIMEText对象时，把HTML字符串传进去，再把第二个参数由plain变为 html就可以了。 HTML字符串如下：12345html = '&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;' + '&lt;p&gt;更多文章请移步：&lt;a href=\"http://www.chenhanpeng.com\"&gt;代码视界&lt;/a&gt;&lt;/p&gt;' + '&lt;/body&gt;&lt;/html&gt;'message = MIMEText(html, 'html', 'utf-8') 发送成功后，收到的HTML邮件如下所示： 发送附件如果Email中要加上附件怎么办？带附件的邮件可以看做包含若干部分的邮件：文本和各个附件本身，所以，可以构造一个MIMEMultipart对象代表邮件本身，然后往里面加上一个MIMEText作为邮件正文，再继续往里面加上表示附件的MIMEBase对象即可：123456789101112131415161718192021222324message = MIMEMultipart()# 设置发件人信息message['From'] = format_addr('Python开发 &lt;%s&gt;' % from_address)# 设置收件人信息message['To'] = format_addr('学员 &lt;%s&gt;' % to_address)# 设置邮件主题message['Subject'] = Header('发送带附件邮件', 'utf-8').encode()message.attach(MIMEText('这是一封带附件的email', 'plain', 'utf-8'))f = open('./20-1.png', 'rb')# 设置附件的MIME和文件名mime = MIMEBase('image', 'png', filename='20.png')# 加上必要的头信息mime.add_header('Content-Disposition', 'attachment', filename='20.png')mime.add_header('Content-ID', '&lt;0&gt;')mime.add_header('X-Attachment-Id', '0')# 把附件的内容读进来:mime.set_payload(f.read())# 用Base64编码:encoders.encode_base64(mime)# 添加到MIMEMultipart:message.attach(mime)f.close() 发送成功后，收到的带附件的邮件如下所示： 在 HTML 文本中添加图片如果要把图片嵌入到邮件正文中，我们该怎么做？直接在HTML中链接图片地址？这种处理方案是行不通的，因为大部分邮件服务商都会自动屏蔽带有外链的图片，因为不知道这些链接是否指向恶意网站。 要把图片嵌入到邮件正文中，我们只需按照发送附件的方式，先把邮件作为附件添加进去，然后，在HTML中通过引用src=&quot;cid:image1就可以把附件作为图片嵌入了。如果有多个图片，给它们依次编号，然后引用不同的cid:x即可。 把上面代码加入MIMEMultipart的MIMEText从plain改为html，然后在适当的位置引用图片：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python# -*- coding: UTF-8 -*- import smtplibfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.header import Header# 输入Email地址和口令from_address = '1036445344@qq.com'from_account_password = '****************' # 第三方登录邮箱的授权码，QQ邮箱为16位授权码# 输入收件人地址to_address = 'hanpengchen07@163.com'msgRoot = MIMEMultipart('related')msgRoot['From'] = Header(\"Python开发\", 'utf-8')msgRoot['To'] = Header(\"测试\", 'utf-8')subject = 'Python SMTP 邮件测试'msgRoot['Subject'] = Header(subject, 'utf-8') msgAlternative = MIMEMultipart('alternative')msgRoot.attach(msgAlternative)mail_msg = \"\"\"&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;&lt;p&gt;&lt;a href=\"http://www.chenhanpeng.com\"&gt;代码视界&lt;/a&gt;&lt;/p&gt;&lt;p&gt;图片演示：&lt;/p&gt;&lt;p&gt;&lt;img src=\"cid:image1\"&gt;&lt;/p&gt;\"\"\"msgAlternative.attach(MIMEText(mail_msg, 'html', 'utf-8')) # 指定图片为当前目录fp = open('./20-1.png', 'rb')msgImage = MIMEImage(fp.read())fp.close() # 定义图片 ID，在 HTML 文本中引用msgImage.add_header('Content-ID', '&lt;image1&gt;')msgRoot.attach(msgImage)# 输入SMTP服务器地址smtp_server = 'smtp.qq.com'# SMTP协议默认端口为25server = smtplib.SMTP(smtp_server, 25)server.login(from_address, from_account_password)server.sendmail(from_address, [to_address], msgRoot.as_string())print('邮件发送成功')server.quit() 再次发送，就可以看到图片直接嵌入到邮件正文的效果： 同时支持HTML和Plain格式如果我们发送HTML邮件，收件人通过浏览器或者Outlook之类的软件是可以正常浏览邮件内容的，但是，如果收件人使用的设备太古老，查看不了HTML邮件怎么办？ 办法是在发送HTML的同时再附加一个纯文本，如果收件人无法查看HTML格式的邮件，就可以自动降级查看纯文本邮件。 利用MIMEMultipart就可以组合一个HTML和Plain，要注意指定subtype是alternative：1234567891011message = MIMEMultipart('alternative')# 设置发件人信息message['From'] = format_addr('Python开发 &lt;%s&gt;' % from_address)# 设置收件人信息message['To'] = format_addr('学员 &lt;%s&gt;' % to_address)# 设置邮件主题message['Subject'] = Header('同时支持HTML和Plain格式', 'utf-8').encode()message.attach(MIMEText('hello Python', 'plain', 'utf-8'))message.attach(MIMEText('&lt;html&gt;&lt;body&gt;&lt;h1&gt;hello Python&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;', 'html', 'utf-8'))# 正常发送msg对象... 加密SMTP使用标准的25端口连接SMTP服务器时，使用的是明文传输，发送邮件的整个过程可能会被窃听。要更安全地发送邮件，可以加密SMTP会话，实际上就是先创建SSL安全连接，然后再使用SMTP协议发送邮件。 某些邮件服务商，例如Gmail，提供的SMTP服务必须要加密传输。我们来看看如何通过Gmail提供的安全SMTP发送邮件。 必须知道，Gmail的SMTP端口是587，因此，修改代码如下：123456smtp_server = 'smtp.gmail.com'smtp_port = 587server = smtplib.SMTP(smtp_server, smtp_port)server.starttls()# 剩下的代码和前面的一模一样:server.set_debuglevel(1) 只需要在创建SMTP对象后，立刻调用starttls()方法，就创建了安全连接。后面的代码和前面的发送邮件代码完全一样。 POP3收取邮件上面我们讲了如何使用SMTP发送邮件，那么如何用Python实现邮件的收取呢？ 收取邮件就是编写一个MUA作为客户端，从MDA把邮件获取到用户的电脑或者手机上。收取邮件最常用的协议是POP协议，目前版本号是3，俗称POP3。 Python内置了一个poplib模块，实现了POP3协议，可以直接用来收邮件。 注意到POP3协议收取的不是一个已经可以阅读的邮件本身，而是邮件的原始文本，这和SMTP协议很像，SMTP发送的也是经过编码后的一大段文本。 要把POP3收取的文本变成可以阅读的邮件，还需要用email模块提供的各种类来解析原始文本，变成可阅读的邮件对象。 所以，收取邮件分两步： 第一步：用poplib把邮件的原始文本下载到本地； 第二部：用email模块把原始邮件解析为Message对象，然后用适当的形式把邮件内容展示为用户。 通过POP3下载邮件POP3协议本身很简单，我们来获取最新的一封邮件内容，示例代码如下：12345678910111213141516171819202122# 链接POP3服务器server = poplib.POP3(pop3_server)# 身份认证server.user(email)server.pass_(pw)# stat()返回邮件数量和占用空间print('Message: %s. Size: %s' % server.stat())# list()返回所有邮件的编号:resp, mails, octets = server.list()# 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]# print(mails)# 获取最新一封邮件, 注意索引号从1开始:index = len(mails)resp, lines, octets = server.retr(index)# lines存储了邮件的原始文本的每一行,# 可以获得整个邮件的原始文本:msg_content = b'\\r\\n'.join(lines).decode('utf-8') 用POP3获取邮件其实很简单，要获取所有邮件，只需要循环使用retr()把每一封邮件内容拿到即可。真正麻烦的是把邮件的原始内容解析为可以阅读的邮件对象。 解析邮件我们只需要用一行代码就可以把刚才获取到的邮件内容解析为Message对象：1msg = Parser().parsestr(msg_content) 但是这个Message对象本身可能是一个MIMEMultipart对象，即包含嵌套的其他MIMEBase对象，嵌套可能还不止一层。 所以我们要递归地打印出Message对象的层次结构：1234567891011121314151617181920212223242526272829# 递归打印出Message对象的层次结构def print_info(msg, indent=0): if indent == 0: for header in ['From', 'To', 'Subject']: value = msg.get(header, '') if value: if header == 'Subject': value = decode_str(value) else: hdr, addr = parseaddr(value) name = decode_str(hdr) value = u'%s &lt;%s&gt;' % (name, addr) print('%s%s: %s' % (' ' * indent, header, value)) if (msg.is_multipart()): parts = msg.get_payload() for n, part in enumerate(parts): print('%spart %s' % (' ' * indent, n)) print('%s--------------------' % (' ' * indent)) print_info(part, indent + 1) else: content_type = msg.get_content_type() if content_type == 'text/plain' or content_type == 'text/html': content = msg.get_payload(decode=True) charset = guess_charset(msg) if charset: content = content.decode(charset) print('%sText: %s' % (' ' * indent, content + '...')) else: print('%sAttachment: %s' % (' ' * indent, content_type)) 邮件的Subject或者Email中包含的名字都是经过编码后的str，要正常显示，就必须decode：12345def decode_str(s): value, charset = decode_header(s)[0] if charset: value = value.decode(charset) return value decode_header()返回一个list，因为像Cc、Bcc这样的字段可能包含多个邮件地址，所以解析出来的会有多个元素。上面的代码我们偷了个懒，只取了第一个元素。 文本邮件的内容也是str，还需要检测编码，否则，非UTF-8编码的邮件都无法正常显示：12345678def guess_charset(msg): charset = msg.get_charset() if charset is None: content_type = msg.get('Content-Type', '').lower() pos = content_type.find('charset=') if pos &gt;= 0: charset = content_type[pos + 8:].strip() return charset 运行程序，结果如下：1234567891011Message: 739. Size: 144832488From: chenhp &lt;hanpengchen07@163.com&gt;To: &lt;1036445344@qq.com&gt;Subject: 测试邮件part 0-------------------- Text: Hello Python！测试邮件...part 1-------------------- Text: &lt;div style=&quot;line-height:1.7;color:#000000;font-size:14px;font-family:Arial&quot;&gt;&lt;div&gt;Hello Python！&lt;/div&gt;&lt;div&gt;测试邮件&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;span title=&quot;neteasefooter&quot;&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/span&gt;... 完整的示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"电子邮件","slug":"电子邮件","permalink":"http://www.chenhanpeng.com/tags/电子邮件/"},{"name":"SMTP/POP3","slug":"SMTP-POP3","permalink":"http://www.chenhanpeng.com/tags/SMTP-POP3/"}]},{"title":"Python从小白到攻城狮(19)——网络编程入门","slug":"python_series/python_19_网络编程入门","date":"2020-01-16T08:34:28.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-network-programming-tcp-and-udp/","link":"","permalink":"http://www.chenhanpeng.com/python-network-programming-tcp-and-udp/","excerpt":"","text":"网络编程入门计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。 TCP/IP 模型实现网络通信的基础是网络通信协议，这些协议通常是由互联网工程任务组（IETF）制定的。所谓协议，就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等等。网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层。 IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个局域网（LAN）中的内部IP地址，通过网络地址转换（NAT）服务我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。 TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情： 数据不传丢不传错（利用握手、校验和重传机制可以实现）。 流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。 拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。 网络应用模式1、C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现S（服务器）的访问。 2、去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。 基于HTTP协议的网络资源访问HTTP（超文本传输协议）HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，通过HTTP或者HTTPS（超文本传输安全协议）请求的资源由URI（统一资源标识符）来标识。简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。 JSON格式JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON最初只是JavaScript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。 XML的例子：12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;message&gt; &lt;name&gt;ZhangSan&lt;/name&gt; &lt;address&gt;China&lt;/address&gt;&lt;/message&gt; JSON的例子：1234&#123; &quot;name&quot;: &quot;ZhangSan&quot;, &quot;address&quot;: &quot;China&quot;&#125; requests库requests是一个基于HTTP协议来使用网络的第三库，官方网站有这样的一句话介绍它：“Requests是唯一的一个非转基因的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及重新造轮子。 下面我们通过requests库实现一个访问网络数据接口获取厦门当天的天气数据。 123456789import requestsdef main(): resp = requests.get('http://api.help.bj.cn/apis/weather/?id=101230201') data = resp.json() print(data)if __name__ == '__main__': main() 基于传输层协议的套接字编程套接字对于很多不了解网络编程的人来说非常陌生，通俗点讲：套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。 在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。 TCP套接字TCP套接字：使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。 下面的代码实现了一个提供时间日期的服务器。1234567891011121314151617181920212223242526272829303132from socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimedef main(): # 1.创建套接字对象并指定使用哪种传输服务 # family=AF_INET - IPv4地址 # family=AF_INET6 - IPv6地址 # type=SOCK_STREAM - TCP套接字 # type=SOCK_DGRAM - UDP套接字 # type=SOCK_RAW - 原始套接字 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(端口用于区分不同的服务) # 同一时间在同一个端口上只能绑定一个服务否则报错 server.bind(('127.0.0.1', 6789)) # 3.开启监听 - 监听客户端连接到服务器 # 参数512可以理解为连接队列的大小 server.listen(512) print('服务器启动开始监听...') while True: # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行 # accept方法返回一个元组其中的第一个元素是客户端对象 # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成) client, addr = server.accept() print(str(addr) + '连接到了服务器.') # 5.发送数据 client.send(str(datetime.now()).encode('utf-8')) # 6.断开连接 client.close()if __name__ == '__main__': main() 通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。12345678910111213from socket import socketdef main(): # 1.创建套接字对象默认使用IPv4和TCP协议 client = socket() # 2.连接到服务器(需要指定IP地址和端口) client.connect(('127.0.0.1', 6789)) # 3.从服务器接收数据 print(client.recv(1024).decode('utf-8')) client.close()if __name__ == '__main__': main() 需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。 服务器端代码：12345678910111213141516171819202122232425262728293031323334353637383940414243from socket import socket, SOCK_STREAM, AF_INETfrom base64 import b64encodefrom json import dumpsfrom threading import Threaddef main(): # 自定义线程类 class FileTransferHandler(Thread): def __init__(self, cclient): super().__init__() self.cclient = cclient def run(self): my_dict = &#123;&#125; my_dict['filename'] = 'guido.jpg' # JSON是纯文本不能携带二进制数据 # 所以图片的二进制数据要处理成base64编码 my_dict['filedata'] = data # 通过dumps函数将字典处理成JSON字符串 json_str = dumps(my_dict) # 发送JSON字符串 self.cclient.send(json_str.encode('utf-8')) self.cclient.close() # 1.创建套接字对象并指定使用哪种传输服务 server = socket() # 2.绑定IP地址和端口(区分不同的服务) server.bind(('127.0.0.1', 5566)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: # 将二进制数据处理成base64再解码成字符串 data = b64encode(f.read()).decode('utf-8') while True: client, addr = server.accept() # 启动一个线程来处理客户端的请求 FileTransferHandler(client).start()if __name__ == '__main__': main() 客户端代码：1234567891011121314151617181920212223242526272829from socket import socketfrom json import loadsfrom base64 import b64decodedef main(): client = socket() client.connect(('127.0.0.1', 5566)) # 定义一个保存二进制数据的对象 in_data = bytes() # 由于不知道服务器发送的数据有多大每次接收1024字节 data = client.recv(1024) while data: # 将收到的数据拼接起来 in_data += data data = client.recv(1024) # 将收到的二进制数据解码成JSON字符串并转换成字典 # loads函数的作用就是将JSON字符串转成字典对象 my_dict = loads(in_data.decode('utf-8')) filename = my_dict['filename'] filedata = my_dict['filedata'].encode('utf-8') with open('./' + filename, 'wb') as f: # 将base64格式的数据解码成二进制数据并写入文件 f.write(b64decode(filedata)) print('图片已保存.')if __name__ == '__main__': main() 在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从000000到111111的64种状态。 UDP套接字传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。 TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（比如传输网络音视频数据），UDP可能是更好的选择。 UDP是面向无连接的协议。 使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。 我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口： 服务器代码：123456789101112131415# -*- coding: utf-8 -*-import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口s.bind(('127.0.0.1', 9999))print('bind udp on port:9999')while True: # 接收数据 data, addr = s.recvfrom(1024) print('received from %s:%s' % addr) reply = 'Hello, %s' % data.decode('utf-8') s.sendto(reply.encode('utf-8'), addr) 创建Socket时，SOCK_DGRAM指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用listen()方法，而是直接接收来自任何客户端的数据： recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。 注意这里省掉了多线程，因为这个例子很简单。 客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据： 客户端代码：1234567891011121314#!/usr/bin/env python3# -*- coding: utf-8 -*-import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据: s.sendto(data, ('127.0.0.1', 9999)) # 接收数据: print(s.recv(1024).decode('utf-8'))s.close() 从服务器接收数据仍然调用recv()方法。 完整的示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"网络编程","slug":"网络编程","permalink":"http://www.chenhanpeng.com/tags/网络编程/"},{"name":"TCP/UDP","slug":"TCP-UDP","permalink":"http://www.chenhanpeng.com/tags/TCP-UDP/"}]},{"title":"Flutter | 5-资源管理","slug":"flutter/5_资源管理","date":"2020-01-15T01:13:44.000Z","updated":"2021-04-21T01:17:29.856Z","comments":true,"path":"flutter-assets-manager/","link":"","permalink":"http://www.chenhanpeng.com/flutter-assets-manager/","excerpt":"","text":"一个应用程序主要有两部分组成：代码和资源。代码关注逻辑功能，而如图片、字符串、字体、配置文件等资源则关注视觉功能。 资源外部化，即把代码和资源分离，是现代UI框架的主流设计理念。因为这样不仅有利于单独维护资源，还可以对特定设备提供更准确的兼容性支持，使得我们的应用程序可以自动根据实际运行环境来组织视觉功能，适应不同的屏幕大小和密度。 Flutter APP安装包中会包含代码和asset（资源）两部分。Assets是会打包到程序安装包中的，可在运行时访问。常见类型的asset包括静态数据（例如JSON文件）、配置文件、图标和图片（JPEG，WebP，GIF，动画WebP/GIF，PNG，BMP和WBMP）等。 指定assets和包管理一样，Flutter也使用pubspec.yaml文件来管理应用程序所需的资源，举个例子：1234flutter: assets: - assets/my_icon.png - assets/background.png assets指定应包含在应用程序中的文件，每个asset都通过相对于pubspec.yaml文件所在的文件系统路径来标识自身的路径。asset的声明顺序是无关紧要的，asset的实际目录可以是任意文件夹（在本文中是assets文件）。 在构建期间，Flutter将asset放置到称为 asset bundle 的特殊存档中，应用程序可以在运行时读取它们（但不能修改）。 Asset变体（variant）构建过程支持“asset变体”的概念：不同版本的asset可能会显示在不同的上下文中。 在pubspec.yaml的assets部分中指定asset路径时，构建过程中，会在相邻子目录中查找具有相同名称的任何文件。这些文件随后会与指定的asset一起被包含在asset bundle中。 例如，如果应用程序目录中有以下文件: …/pubspec.yaml …/graphics/my_icon.png …/graphics/background.png …/graphics/dark/background.png …etc. 然后pubspec.yaml文件中只需包含:123flutter: assets: - graphics/background.png 那么这两个graphics/background.png和graphics/dark/background.png 都将包含在您的asset bundle中。前者被认为是main asset （主资源），后者被认为是一种变体（variant）。 在选择匹配当前设备分辨率的图片时，Flutter会使用到asset变体（见下文），将来，Flutter可能会将这种机制扩展到本地化、阅读提示等方面。 加载assets应用可以通过 AssetBundle 对象访问其asset。有两种主要方法允许从Asset bundle中加载字符串或图片（二进制）文件。 加载文本assets 通过rootBundle对象加载：每个Flutter应用程序都有一个rootBundle对象，通过它可以轻松访问主资源包，直接使用package:flutter/services.dart中全局静态的rootBundle对象来加载asset即可。 通过 DefaultAssetBundle 加载：建议使用 DefaultAssetBundle 来获取当前BuildContext的AssetBundle。 这种方法不是使用应用程序构建的默认asset bundle，而是使父级widget在运行时动态替换的不同的AssetBundle，这对于本地化或测试场景很有用。通常，可以使用 DefaultAssetBundle.of() 在应用运行时来间接加载asset（例如JSON文件），而在widget上下文之外，或其它AssetBundle句柄不可用时，可以使用rootBundle直接加载这些asset，例如： 123456import 'dart:async' show Future;import 'package:flutter/services.dart' show rootBundle;Future&lt;String&gt; loadAsset() async &#123; return await rootBundle.loadString('assets/config.json');&#125; 加载图片类似于原生开发，Flutter也可以为当前设备加载适合其分辨率的图像。 声明分辨率相关的图片 assetsAssetImage 可以将asset的请求逻辑映射到最接近当前设备像素比例（dpi）的asset。为了使这种映射起作用，必须根据特定的目录结构来保存asset： …/image.png …/Mx/image.png …/Nx/image.png …etc. 其中M和N是数字标识符，对应于其中包含的图像的分辨率，也就是说，它们指定不同设备像素比例的图片。 主资源默认对应于1.0倍的分辨率图片。看一个例子： …/my_icon.png …/2.0x/my_icon.png …/3.0x/my_icon.png在设备像素比率为1.8的设备上，.../2.0x/my_icon.png 将被选择。对于2.7的设备像素比率，.../3.0x/my_icon.png将被选择。 如果未在Image widget上指定渲染图像的宽度和高度，那么Image widget将占用与主资源相同的屏幕空间大小。 也就是说，如果.../my_icon.png是72px乘72px，那么.../3.0x/my_icon.png应该是216px乘216px; 但如果未指定宽度和高度，它们都将渲染为72像素×72像素（以逻辑像素为单位）。 pubspec.yaml中asset部分中的每一项都应与实际文件相对应，但主资源项除外。当主资源缺少某个资源时，会按分辨率从低到高的顺序去选择 ，也就是说1x中没有的话会在2x中找，2x中还没有的话就在3x中找。 加载图片要加载图片，可以使用AssetImage类，例如：我们可以从上面的asset声明中加载背景图片：123456789Widget build(BuildContext context) &#123; return new DecoratedBox( decoration: new BoxDecoration( image: new DecorationImage( image: new AssetImage('graphics/background.png'), ), ), );&#125; 注意，AssetImage 并非是一个widget，它实际是一个ImageProvider，有些时候你可能期望直接得到一个显示图片的widget，那么你可以使用 Image.aseet()方法，如：123Widget build(BuildContext context) &#123; return Image.asset('graphics/background.png');&#125; 使用默认的 asset bundle 加载资源时，内部会自动处理分辨率等，这些处理对开发者来说是无感知的。 (如果使用一些更低级别的类，如 ImageStream或 ImageCache 时你会注意到有与缩放相关的参数) 依赖包中的资源图片要加载依赖包中的图像，必须给AssetImage提供package参数。 例如，假设您的应用程序依赖于一个名为“my_icons”的包，它具有如下目录结构： …/pubspec.yaml …/icons/heart.png …/icons/1.5x/heart.png …/icons/2.0x/heart.png …etc.然后加载图像，使用:1new AssetImage(&apos;icons/heart.png&apos;, package: &apos;my_icons&apos;) 或1new Image.asset(&apos;icons/heart.png&apos;, package: &apos;my_icons&apos;) 注意：包在使用本身的资源时也应该加上package参数来获取。 打包包中的 assets如果在pubspec.yaml文件中声明了期望的资源，它将会打包到相应的package中。特别是，包本身使用的资源必须在pubspec.yaml中指定。 包也可以选择在其lib/文件夹中包含未在其pubspec.yaml文件中声明的资源。在这种情况下，对于要打包的图片，应用程序必须在pubspec.yaml中指定包含哪些图像。 例如，一个名为“fancy_backgrounds”的包，可能包含以下文件： …/lib/backgrounds/background1.png …/lib/backgrounds/background2.png …/lib/backgrounds/background3.png要包含第一张图像，必须在pubspec.yaml的assets部分中声明它：123flutter: assets: - packages/fancy_backgrounds/backgrounds/background1.png lib/是隐含的，所以它不应该包含在资产路径中。 加载字体字体则是另外一类较为常用的资源。手机操作系统一般只有默认的几种字体，在大部分情况下可以满足我们的正常需求。但是，在一些特殊的情况下，我们可能需要使用自定义字体来提升视觉体验。 在Flutter中，使用自定义字体同样需要在pubspec.yaml文件中提前声明。需要注意的是，字体实际上是字符图形的映射。所以，除了正常字体文件外，如果你的应用需要支持粗体和斜体，同样也需要有对应的粗体和斜体字体文件。 在将RobotoCondensed字体摆放至assets目录下的fonts子目录后，下面的代码演示了如何将支持斜体与粗体的RobotoCondensed字体加到我们的应用中： 12345678fonts: - family: RobotoCondensed #字体名字 fonts: - asset: assets/fonts/RobotoCondensed-Regular.ttf #普通字体 - asset: assets/fonts/RobotoCondensed-Italic.ttf style: italic #斜体 - asset: assets/fonts/RobotoCondensed-Bold.ttf weight: 700 #粗体 这些声明其实都对应着TextStyle中的样式属性，如字体名family对应着 fontFamily属性、斜体italic与正常normal对应着style属性、字体粗细weight对应着fontWeight属性等。在使用时，我们只需要在TextStyle中指定对应的字体即可： 1234567891011Text(&quot;This is RobotoCondensed&quot;, style: TextStyle( fontFamily: &apos;RobotoCondensed&apos;,//普通字体));Text(&quot;This is RobotoCondensed&quot;, style: TextStyle( fontFamily: &apos;RobotoCondensed&apos;, fontWeight: FontWeight.w700, //粗体));Text(&quot;This is RobotoCondensed italic&quot;, style: TextStyle( fontFamily: &apos;RobotoCondensed&apos;, fontStyle: FontStyle.italic, //斜体)); 特定平台assets上面的资源都是flutter应用中的，这些资源只有在flutter框架运行之后才能使用，如果要给我们的应用设置APP图标或者添加启动图，那我们必须使用特定平台的assets。 设置APP图标更新Flutter应用程序启动图标的方式与在本机Android或iOS应用程序中更新启动图标的方式相同。 Android在Flutter项目的根目录中，导航到.../android/app/src/main/res目录，里面包含了各种资源文件夹（如 mipmap-hdpi 已包含占位符图像“ic_launcher.png”，见下图)。只需按照Android开发人员指南中的说明，将其替换为所需的资源，并遵守每种屏幕密度（dpi）的建议图标大小标准。 注意：如果您重命名.png文件，则必须在您 AndroidManifest.xml的 &lt;application&gt;标签的android:icon属性中更新名称。 iOS在Flutter项目的根目录中，导航到.../ios/Runner。该目录中Assets.xcassets/AppIcon.appiconset已经包含占位符图片（见下图）， 只需将它们替换为适当大小的图片，保留原始文件名称。 更新启动页在Flutter框架加载时，Flutter会使用本地平台机制绘制启动页。此启动页将持续到Flutter渲染应用程序的第一帧时。 注意：这意味着如果您不在应用程序的main()方法中调用runApp函数（或者更具体的说，如果您不调用window.render去响应window.onDrawFrame）的话，启动屏幕将永远持续显示。 Android要将启动屏幕（splash screen）添加到您的Flutter应用程序， 请导航至.../android/app/src/main。在res/drawable/launch_background.xml，通过自定义drawable来实现自定义启动界面（你也可以直接换一张图片）。 iOS要将图片添加到启动屏幕（splash screen）的中心，请导航至.../ios/Runner。在Assets.xcassets/LaunchImage.imageset， 拖入图片，并命名为LaunchImage.png、`LaunchImage@2x.png、LaunchImage@3x.png。 如果你使用不同的文件名，那您还必须更新同一目录中的Contents.json`文件，图片的具体尺寸可以查看苹果官方的标准。 您也可以通过打开Xcode完全自定义storyboard。在Project Navigator中导航到Runner/Runner然后通过打开Assets.xcassets拖入图片，或者通过在LaunchScreen.storyboard中使用Interface Builder进行自定义，如下图所示。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"Flutter","slug":"前端/Flutter","permalink":"http://www.chenhanpeng.com/categories/前端/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.chenhanpeng.com/tags/Flutter/"},{"name":"资源管理","slug":"资源管理","permalink":"http://www.chenhanpeng.com/tags/资源管理/"}]},{"title":"Flutter | 4-包管理","slug":"flutter/4_包管理","date":"2020-01-09T01:21:24.000Z","updated":"2021-04-21T01:17:29.771Z","comments":true,"path":"flutter-packages-manager/","link":"","permalink":"http://www.chenhanpeng.com/flutter-packages-manager/","excerpt":"","text":"包(Package)在软件开发中，有一些公共的库或者SDK可能会被很多项目用到，因此，将这些代码单独抽到一个独立模块，然后哪个项目需要使用时直接集成这个模块，便可以大大提高开发效率。很多编程语言或开发工具都支持这种“模块共享”机制，比如Java语言中这种独立模块会被打成一个jar包，Android中的aar包，web开发中的npm包等等。为了表述方便，我们将这种可共享的独立模块统一称为“包”(Package)。 一个APP在实际开发中往往会依赖很多包，而这些包通常都有交叉依赖关系、版本依赖等，如果由开发者手动来管理应用中的依赖包将会非常麻烦。因此，各种开发生态或编程语言官方通常都会提供一些包管理工具，比如在Android提供了Gradle来管理依赖，iOS用Cocoapods或Carthage来管理依赖，Node中通过npm等。而在Flutter开发中也有自己的包管理工具。本节我们主要介绍一下flutter如何使用配置文件pubspec.yaml（位于项目根目录）来管理第三方依赖包。 YAML是一种直观、可读性高并且容易被人类阅读的文件格式，它和xml或Json相比，它语法简单并非常容易解析，所以YAML常用于配置文件，Flutter也是用yaml文件作为其配置文件。Flutter项目默认的配置文件是pubspec.yaml，我们看一个简单的示例： 12345678910111213141516171819name: first_flutter_applicationdescription: A new Flutter project.version: 1.0.0+1environment: sdk: &quot;&gt;=2.1.0 &lt;3.0.0&quot;dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.2dev_dependencies: flutter_test: sdk: flutterflutter: uses-material-design: true 我们对上面的各个字段做个说明： name：应用或包名称 description：应用或包的描述、简介 version：应用或包的版本号 dependencies：应用或包依赖的其他包或插件 dev_dependencies：开发环境依赖的工具包（不是Flutter应用本身依赖的包） flutter：flutter相关的配置选项 如果我们的Flutter应用本身依赖某个包，我们需要将所依赖的包添加到dependencies 下，接下来我们通过一个例子来演示一下如何添加、下载并使用第三方包。 Pub仓库Pub(https://pub.dev/) 是Google官方的Dart Packages仓库，类似于node的npm仓库，android的jcenter。 我们可以在Pub上面查找我们需要的包和插件，也可以向Pub发布我们的包和插件。 示例假设我们需要实现一个轮播图的功能，在Pub仓库中有个“flutter_swiper”包已经实现该功能。我们首先在pub上找到flutter_swiper这个包（如下图所示），确定其最新的版本号和是否支持Flutter。 可以看到其最新版本是1.1.6，并且支持flutter。 1、下面我们将其添加到依赖列表中：12345dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.2 flutter_swiper: ^1.1.6 2、下载包。用VS Code编辑器查看pubspec.yaml时，编辑器右上角有个下载包的按钮，如下图所示。 VS Code在pubspec.yaml依赖列表有修改的时候，会自动执行下载包命令，我们可以在输出窗口看到如下信息：123[3_first_flutter_application] flutter packages getRunning &quot;flutter pub get&quot; in 3_first_flutter_application... 14.6sexit code 0 我们也可以在控制台，定位到当前工程目录，然后手动运行flutter packages get 命令来下载依赖包。另外，需要注意dependencies和dev_dependencies的区别，前者的依赖包将作为APP的源码的一部分参与编译，生成最终的安装包。而后者的依赖包只是作为开发阶段的一些工具包，主要是用于帮助我们提高开发、测试效率，比如flutter的自动化测试包等。 3、在前面创建的第一个Flutter应用的代码基础上，使用 flutter_swiper 实现轮播图功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import 'package:flutter/material.dart';import 'package:flutter_swiper/flutter_swiper.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ SizedBox( height: 200, width: 400, child: Swiper( itemBuilder: (BuildContext context, int index) &#123; return new Image.network(\"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3228282522,4112292848&amp;fm=26&amp;gp=0.jpg\", fit: BoxFit.fill); &#125;, itemCount: 3, pagination: new SwiperPagination(), control: new SwiperControl(), ), ) ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ); &#125;&#125; 4、运行效果图如下： 其他依赖方式上文所述的依赖方式是依赖Pub仓库的，但我们还可以依赖本地包和git仓库。 依赖本地包如果我们正在本地开发一个包，包名为 hampton_pkg，我们可以通过下面的方式依赖：123dependencies: hampton_pkg: path: ../../code/hampton_pkg 包的路径可以是相对的，也可以是绝对的。 依赖Git我们还可以依赖Git仓库中的包。如果软件包位于仓库的根目录下，可以通过下面的方式引入依赖：1234dependencies: hampton_pkg: git: url: git://github.com/xxx/hampton_pkg.git 上面假定包位于Git存储库的根目录中。如果不是这种情况，可以使用path参数指定相对位置，例如：12345dependencies: hampton_pkg: git: url: git://github.com/flutter/packages.git path: packages/hampton_pkg 上面介绍的这些依赖方式是Flutter开发中常用的，但还有一些其它依赖方式，完整的内容大家可以自行查看：https://www.dartlang.org/tools/pub/dependencies 。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"Flutter","slug":"前端/Flutter","permalink":"http://www.chenhanpeng.com/categories/前端/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.chenhanpeng.com/tags/Flutter/"},{"name":"包管理","slug":"包管理","permalink":"http://www.chenhanpeng.com/tags/包管理/"},{"name":"第三方组件库","slug":"第三方组件库","permalink":"http://www.chenhanpeng.com/tags/第三方组件库/"}]},{"title":"Flutter | 3-创建第一个Flutter应用","slug":"flutter/3_创建第一个Flutter应用","date":"2020-01-03T13:53:21.000Z","updated":"2021-04-21T01:17:29.650Z","comments":true,"path":"create-first-flutter-app/","link":"","permalink":"http://www.chenhanpeng.com/create-first-flutter-app/","excerpt":"","text":"用Android Studio和VS Code创建的Flutter应用模板默认是一个简单的计数器示例。今天我们通过创建的计数器示例来了解Flutter应用程序的结构。 1、创建Flutter应用模板通过命令行flutter create &lt;output directory&gt;创建一个名为 first_flutter_application的Flutter工程。 运行创建好的工程，计数器例子效果如下图： 在这个例子中，点击右下角“+”悬浮按钮，屏幕中间的数字则会+1。 这个示例的主要Dart代码在 lib/main.dart 文件中，源码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. ); &#125;&#125; 代码说明1、导入包1import 'package:flutter/material.dart'; 上面这行代码作用是导入Material UI组件库。Material是一种标准的移动端和web端的视觉设计语言，Flutter默认提供了一套丰富的Material风格的UI组件。 2、应用入口1void main() =&gt; runApp(MyApp()); 和java类似，main函数在Flutter中也是应用程序的入口。main函数中调用了 runApp 方法，它的功能是启动Flutter应用。runApp 它接受一个 Widget 参数，在计数器这个示例中，它是一个 MyApp 对象，MyApp() 是Flutter应用的根组件。 main函数使用了 ( =&gt; )符号，这是Dart中单行函数或方法的简写。 3、应用结构12345678910111213class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); &#125;&#125; MyApp类代表Flutter应用，它继承了 StatelessWidget 类，这也就意味着应用本身也是一个widget。 在Flutter中，大多数东西都是widget（后同“组件”或“部件”），包括对齐(alignment)、填充(padding)和布局(layout)等，它们都是以widget的形式提供。 Flutter在构建页面时，会调用组件的build方法，widget的主要工作是提供一个build()方法来描述如何构建UI界面（通常是通过组合、拼装其它基础widget）。 MaterialApp 是Material库中提供的Flutter APP框架，通过它可以设置应用的名称、主题、语言、首页及路由列表等。MaterialApp也是一个widget。 home 为Flutter应用的首页，它也是一个widget。 2、首页StatefulWidget类123456789101112class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; ...&#125; MyHomePage 是Flutter应用的首页，它继承自 StatefulWidget 类，表示它是一个有状态的组件（Stateful widget）。关于StatefulWidget 和 StatelessWidget 在后面我们会详细介绍，这里我们先简单两个这两者有下面两点不同： StatefulWidget 可以拥有状态，这些状态在widget生命周期中是可以改变的，而StatelessWidget是不可以变的。 StatefulWidget 至少由两个类组成：StatefulWidget类和 State类。 StatefulWidget类本身是不变的，但是State类中持有的状态在widget生命周期中可能会发生变化。 在上面的代码中，_MyHomePageState类是MyHomePage类对应的状态类。 State类接下来，我们看下_MyHomePageState中都包含哪些东西： 1、该组件的状态。由于我们只需要维护一个点击次数计数器，所以定义一个 _counter 状态：1int _counter = 0; _counter 为保存屏幕右下角悬浮按钮点击次数的状态。 2、设置状态的自增函数12345void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;)&#125; 当按钮点击时，会调用此函数，该函数的作用是先自增_counter，然后调用setState 方法。setState方法的作用是通知Flutter框架，有状态发生了改变，Flutter框架收到通知后，会执行build方法来根据新的状态重新构建界面， Flutter 对此方法做了优化，使重新执行变的很快，所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget。 3、构建UI界面 构建UI界面的逻辑在build方法中，当MyHomePage第一次创建时，_MyHomePageState类会被创建，当初始化完成后，Flutter框架会调用Widget的build方法来构建widget树，最终将widget树渲染到设备屏幕上。所以，我们看看_MyHomePageState的build方法中都干了什么事：1234567891011121314151617181920212223242526Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), body: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ new Text( 'You have pushed the button this many times:', ), new Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: new Icon(Icons.add), ), );&#125; Scaffold 是 Material 库中提供的页面脚手架，它提供了默认的导航栏、标题和包含主屏幕widget树（后同“组件树”或“部件树”）的body属性，组件树可以很复杂。本书后面示例中，路由默认都是通过Scaffold创建。 body的组件树中包含了一个Center 组件，Center 可以将其子组件树对齐到屏幕中心。此例中， Center 子组件是一个Column 组件，Column的作用是将其所有子组件沿屏幕垂直方向依次排列； 此例中Column子组件是两个 Text，第一个Text 显示固定文本 “You have pushed the button this many times:”，第二个Text 显示_counter状态的数值。 floatingActionButton是页面右下角的带“+”的悬浮按钮，它的onPressed属性接受一个回调函数，代表它被点击后的处理器，本例中直接将_incrementCounter方法作为其处理函数。 现在，我们将整个计数器执行流程串起来：当右下角的floatingActionButton按钮被点击之后，会调用_incrementCounter方法。在_incrementCounter方法中，首先会自增_counter计数器（状态），然后setState会通知Flutter框架状态发生变化，接着，Flutter框架会调用build方法以新的状态重新构建UI，最终显示在设备屏幕上。 为什么将build方法放在State中，而不放在StatefulWidget中？从示例中我们发现：和MyApp 类不同， MyHomePage类中并没有build方法，取而代之的是，build方法被挪到了_MyHomePageState方法中，至于为什么这么做？这主要是为了提高开发的灵活性。如果将build()方法放在StatefulWidget中则会有两个问题： 状态访问不便 试想一下，如果我们的StatefulWidget有很多状态，而每次状态改变都要调用build方法，由于状态是保存在State中的，如果build方法在StatefulWidget中，那么build方法和状态分别在两个类中，那么构建时读取状态将会很不方便！试想一下，如果真的将build方法放在StatefulWidget中的话，由于构建用户界面过程需要依赖State，所以build方法将必须加一个State参数，大概是下面这样：1234Widget build(BuildContext context, State state)&#123; //state.counter ...&#125; 这样的话就只能将State的所有状态声明为公开的状态，这样才能在State类外部访问状态！但是，将状态设置为公开后，状态将不再具有私密性，这就会导致对状态的修改将会变的不可控。但如果将build()方法放在State中的话，构建过程不仅可以直接访问状态，而且也无需公开私有状态，这会非常方便。 继承StatefulWidget不便例如，Flutter中有一个动画widget的基类AnimatedWidget，它继承自StatefulWidget类。AnimatedWidget中引入了一个抽象方法build(BuildContext context)，继承自AnimatedWidget的动画widget都要实现这个build方法。现在设想一下，如果StatefulWidget 类中已经有了一个build方法，正如上面所述，此时build方法需要接收一个state对象，这就意味着AnimatedWidget必须将自己的State对象(记为_animatedWidgetState)提供给其子类，因为子类需要在其build方法中调用父类的build方法，代码可能如下：123456789class MyAnimationWidget extends AnimatedWidget&#123; @override Widget build(BuildContext context, State state)&#123; //由于子类要用到AnimatedWidget的状态对象_animatedWidgetState， //所以AnimatedWidget必须通过某种方式将其状态对象_animatedWidgetState //暴露给其子类 super.build(context, _animatedWidgetState) &#125;&#125; 这样很显然是不合理的，因为 1、AnimatedWidget的状态对象是AnimatedWidget内部实现细节，不应该暴露给外部。 2、如果要将父类状态暴露给子类，那么必须得有一种传递机制，而做这一套传递机制是无意义的，因为父子类之间状态的传递和子类本身逻辑是无关的。 综上所述，可以发现，对于StatefulWidget，将build方法放在State中，可以给开发带来很大的灵活性。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"Flutter","slug":"前端/Flutter","permalink":"http://www.chenhanpeng.com/categories/前端/Flutter/"}],"tags":[{"name":"第一个Fultter应用","slug":"第一个Fultter应用","permalink":"http://www.chenhanpeng.com/tags/第一个Fultter应用/"}]},{"title":"Flutter | 2-Dart语言简介","slug":"flutter/2_Dart语言简介","date":"2019-12-23T15:30:34.000Z","updated":"2021-04-21T01:17:29.557Z","comments":true,"path":"dart-introduction/","link":"","permalink":"http://www.chenhanpeng.com/dart-introduction/","excerpt":"","text":"Dart在静态语法方面和Java非常相似，如类型定义、函数声明、泛型等，而在动态特性方面又和JavaScript很想，如函数式特性、异步支持等。除了融合Java和JavaScript语言的长处外，Dart也具有一些其他具有表现力的语法，如可选命名参数、..(联级运算符)和 ?. （条件成员访问运算符）以及 ?? （判空赋值运算符）。 Flutter是采用Dart语言进行开发的，所以我们来学习一下Dart在Flutter开发中常用的语法特性。 下面例子可以在DartPad上面进行运行校验：https://dartpad.cn/ 变量声明1. var类似于JavaScript中var，它可以接收任何类型的变量，但和JavaScript最大的不同在于：Dart中var变量一单赋值，类型便会确定，不能在改变其类型。12345void main() &#123; var t; t = \"hello world!\"; t = 1;&#125; 上面的代码在JavaScript是没有问题的，前端开发者需要注意一下，之所以有此差异是因为Dart本身是一个强类型语言，任何变量都是有确定类型的，在Dart中，当用var声明一个变量后，Dart在编译时会根据第一次赋值数据的类型来推断其类型，编译结束后其类型就已经被确定，而JavaScript是纯粹的弱类型脚本语言，var只是变量的声明方式而已。 2. dynamic和ObjectObject是Dart所有对象的根基类，也就是说所有类型都是Object子类（包括Function和Null），所以任何类型的数据都可以赋值给Object声明的对象。dynamic和var一样都是关键词，声明的变量可以赋值任何对象。而dynamic和Object相同之处在于：他们声明的变量可以在后期改变赋值类型。123456789101112131415void main() &#123; dynamic user; Object system; user = 'zhangsan'; system = 'dart'; print(user); print(system); user = &#123; 'name': 'zhangsan', 'age': 20 &#125;; system = 1; print(user); print(system);&#125; dynamic与Object不同的是,dynamic声明的对象编译器会提供所有可能的组合, 而Object声明的对象只能使用Object的属性与方法, 否则编译器会报错。如:12345678void main() &#123; dynamic user; Object system; user = 'zhangsan'; system = 'dart'; print(user.length); print(system.length);&#125; 变量user不会报错, 变量system编译器会报错 dynamic的这个特性与Objective-C中的id作用很像. dynamic的这个特点使得我们在使用它时需要格外注意,这很容易引入一个运行时错误. 3. final 和 const如果你从未打算更改一个变量，那么使用final或const，不是var，也不是一个类型。一个final变量只能被设置一次，两者区别在于：const变量是一个编译时常量，final变量在第一次使用时被初始化。被final或者const修饰的变量，变量类型可以省略。1234void main() &#123; final str = 'hello world!'; const str1 = 'hello world';&#125; 函数Dart是一种真正的面向对象的语言，所以即使是函数也是对象，并且有一个类型Function。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征。 1、函数声明123bool isNoble(int atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125; Dart函数声明如果没有显式声明返回值类型是会默认当做dynamic处理，注意，函数返回值没有类型推断：123456789101112typedef bool CALLBACK();//不指定返回类型，此时默认为dynamic，不是boolisNoble(int atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125;void test(CALLBACK cb)&#123; print(cb()); &#125;//报错，isNoble不是bool类型test(isNoble); 2、对于只包含一个表达式的函数，可以使用简写语法1bool isNoble (int atomicNumber) =&gt; _nobleGases[atomicNumber] != null; 3、函数作为变量1234var say = (str) &#123; print(str)&#125;;say('hello world!'); 4、函数作为参数传递1234void execute(var callback) &#123; callback();&#125;execute(() =&gt; print('hello world')); 5、可选的位置参数包装一组函数参数，用[]标记为可选的位置参数，并放在参数列表的最后面：1234567String say(String from, String msg, [String device]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; return result;&#125; 下面是一个不带可选参数调用这个函数的例子：1say(&apos;iphoneX&apos;, &apos;system error&apos;); 下面是用第三个参数调用这个函数的例子：1say(&apos;iphoneX&apos;, &apos;system error&apos;, &apos;signal&apos;); 6、可选的命名参数定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数。例如：1234//设置[bold]和[hidden]标志void enableFlags(&#123;bool bold, bool hidden&#125;) &#123; // ... &#125; 调用函数时，可以使用指定命名参数。例如：paramName: value1enableFlags(bold: true, hidden: false); 可选命名参数在Flutter中使用非常多。 注意，不能同时使用可选的位置参数和可选的命名参数 异步支持Dart类库有非常多返回Future或者Stream对象的函数。这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像IO操作。而不是等到这个操作完成。 async和 await关键词支持了异步编程，允许您写出和同步代码很像的异步代码。 FutureFuture与JavaScript中的Promise非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。一个Future只会对应一个结果，要么成功，要么失败。 由于本身功能较多，这里我们只介绍其常用的API及特性。还有，请记住，Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用。 Future.then下面我们利用Future.delayed 创建一个延时任务来模拟请求远程接口返回。12345Future.delayed(new Duration(seconds: 3), ()&#123; return 'hello world';&#125;).then((data) &#123; print(data);&#125;); Future.catchError如果异步任务发生错误，我们可以在catchError中捕获错误，我们将上面示例改为：1234567Future.delayed(new Duration(seconds: 3), ()&#123; throw AssertionError(\"Error\");&#125;).then((data) &#123; print(data);&#125;).catchError((e) &#123; print(e);&#125;); 在上面的示例中，我们在异步任务中抛出了一个异常，then的回调函数将不会被执行，取而代之的是 catchError回调函数将被调用；但是，并不是只有 catchError回调才能捕获错误，then方法还有一个可选参数onError，我们也可以它来捕获异常：1234567Future.delayed(new Duration(seconds: 3), ()&#123; throw AssertionError(&quot;Error&quot;);&#125;).then((data) &#123; print(data);&#125;, onError: (e) &#123; print(e);&#125;); Future.whenComplete有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在then或catch中关闭一下对话框，第二种就是使用Future的whenComplete回调，我们将上面示例改一下：123456789Future.delayed(new Duration(seconds: 3), ()&#123; throw AssertionError(&quot;Error&quot;);&#125;).then((data) &#123; print(data);&#125;).catchError((e) &#123; print(e);&#125;).whenComplete(()&#123; // 无论成功或失败都会走到这里&#125;); Future.wait有些时候，我们需要等待多个异步任务都执行结束后才进行一些操作，比如我们有一个界面，需要先分别从两个网络接口获取数据，获取成功后，我们需要将两个接口数据进行特定的处理后再显示到UI界面上，应该怎么做？答案是Future.wait，它接受一个Future数组参数，只有数组中所有Future都执行成功后，才会触发then的成功回调，只要有一个Future执行失败，就会触发错误回调。下面，我们通过模拟Future.delayed 来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下：1234567891011121314Future.wait([ // 2秒后返回结果 Future.delayed(new Duration(seconds: 2), () &#123; return &quot;hello&quot;; &#125;), // 4秒后返回结果 Future.delayed(new Duration(seconds: 4), () &#123; return &quot; world&quot;; &#125;)]).then((results)&#123; print(results[0]+results[1]);&#125;).catchError((e)&#123; print(e);&#125;); 执行上面代码，4秒后你会在控制台中看到“hello world”。 Async/await如果代码中有大量异步逻辑，并且出现大量异步任务依赖其他异步任务的结果时，必然会出现Future.then回调中套回调情况。举个例子，比如有个场景是用户需要先登录，登录成功后获得用户Id，然后根据用户ID去请求个人信息，成功获取信息后将其缓存在本地文件系统中。代码示例如下：12345678910111213//先分别定义各个异步任务Future&lt;String&gt; login(String userName, String pwd)&#123; ... //用户登录&#125;;Future&lt;String&gt; getUserInfo(String id)&#123; ... //获取用户信息 &#125;;Future saveUserInfo(String userInfo)&#123; ... // 保存用户信息 &#125;; 接下来执行整个流程：12345678910login(\"alice\",\"******\").then((id)&#123; //登录成功后通过，id获取用户信息 getUserInfo(id).then((userInfo)&#123; //获取用户信息后保存 saveUserInfo(userInfo).then(()&#123; //保存用户信息，接下来执行其它操作 ... &#125;); &#125;);&#125;) 可以感受一下，如果业务逻辑中有大量异步依赖的情况，将会出现上面这种在回调里面套回调的情况，过多的嵌套会导致的代码可读性下降以及出错率提高，并且非常难维护，这个问题被形象的称为回调地狱（Callback Hell）。回调地狱问题在之前JavaScript中非常突出，也是JavaScript被吐槽最多的点，但随着ECMAScript6和ECMAScript7标准发布后，这个问题得到了非常好的解决，而解决回调地狱的两大神器正是ECMAScript6引入了Promise，以及ECMAScript7中引入的async/await。 而在Dart中几乎是完全平移了JavaScript中的这两者：Future相当于Promise，而async/await连名字都没改。接下来我们看看通过Future和async/await如何消除上面示例中的嵌套问题。 使用Future消除Callback Hell12345678910login(\"alice\",\"******\").then((id)&#123; return getUserInfo(id);&#125;).then((userInfo)&#123; return saveUserInfo(userInfo);&#125;).then((e)&#123; //执行接下来的操作 &#125;).catchError((e)&#123; //错误处理 print(e);&#125;); 正如上文所述， Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用” ，如果在then中返回的是一个Future的话，该future会执行，执行结束后会触发后面的then回调，这样依次向下，就避免了层层嵌套。 使用async/await消除callback hell通过Future回调中再返回Future的方式虽然能避免层层嵌套，但是还是有一层回调，有没有一种方式能够让我们可以像写同步代码那样来执行异步任务而不使用回调的方式？答案是肯定的，这就要使用async/await了，下面我们先直接看代码，然后再解释，代码如下：1234567891011task() async &#123; try&#123; String id = await login(&quot;alice&quot;,&quot;******&quot;); String userInfo = await getUserInfo(id); await saveUserInfo(userInfo); //执行接下来的操作 &#125; catch(e)&#123; //错误处理 print(e); &#125; &#125; async用来表示函数是异步的，定义的函数会返回一个Future对象，可以使用then方法添加回调函数。 await 后面是一个Future，表示等待该异步任务完成，异步完成后才会往下走；await必须出现在 async 函数内部。 可以看到，我们通过async/await将一个异步流用同步的代码表示出来了。 其实，无论是在JavaScript还是Dart中，async/await都只是一个语法糖，编译器或解释器最终都会将其转化为一个Promise（Future）的调用链。 StreamStream也是用于接收异步事件数据，和Future不同的是，它可以接收多个异步操作的结果（成功或失败）。也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：1234567891011121314151617181920Stream.fromFutures([ // 1秒后返回结果 Future.delayed(new Duration(seconds: 1), () &#123; return &quot;hello 1&quot;; &#125;), // 抛出一个异常 Future.delayed(new Duration(seconds: 2),()&#123; throw AssertionError(&quot;Error&quot;); &#125;), // 3秒后返回结果 Future.delayed(new Duration(seconds: 3), () &#123; return &quot;hello 3&quot;; &#125;)]).listen((data)&#123; print(data);&#125;, onError: (e)&#123; print(e.message);&#125;,onDone: ()&#123;&#125;); 执行上面代码依次输出：123hello 1Errorhello 3","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"Flutter","slug":"前端/Flutter","permalink":"http://www.chenhanpeng.com/categories/前端/Flutter/"}],"tags":[{"name":"Dart语法","slug":"Dart语法","permalink":"http://www.chenhanpeng.com/tags/Dart语法/"}]},{"title":"Flutter | 1-了解Flutter","slug":"flutter/1_了解Flutter","date":"2019-12-23T15:08:34.000Z","updated":"2021-04-21T01:17:29.491Z","comments":true,"path":"start-learn-flutter/","link":"","permalink":"http://www.chenhanpeng.com/start-learn-flutter/","excerpt":"","text":"1、FlutterFlutter是Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过Dart语言开发APP，一套代码可以同时运行在ios、android、web。Flutter提供了丰富的组件、接口，开发者可以很快为Flutter添加native扩展。同时Flutter还使用Native引擎渲染视图，这为用户提供良好的体验。 跨平台自绘引擎Flutter和其他大多数构建移动应用程序的框架不同，Flutter既不使用WebView，也不使用操作系统的原生控件。相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证Android和iOS上UI的一致性，而且可以避免对原生控件依赖而带来的限制及高昂的维护成本。 FLutter使用Skia作为2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎。 目前Flutter默认支持iOS、Android、Fuchsia三个移动平台。但Flutter也可支持web开发和PC开发。这里我们主要学习其基于iOS和Android平台的开发。 高性能Flutter高性能主要靠两点来保证，首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。 采用Dart语言开发当前，程序主要有两种运行方式：静态编译与动态编译。静态编译的程序在执行前全部被翻译成机器码，通常将这种类型称为AOT（Ahead of time）即“提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（just-in-time）即“即时编译”。 AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表非常多，比如JavaScript、Python等等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。 Dart和JavaScript对比的优势： 开发效率高Dart运行时和编译器支持Flutter的两个关键特性的组合：基于JIT的快速开发周期：Flutter在开发阶段采用JIT模式，避免了每次改动都需要进行编译，极大节省开发时间。基于AOT的发布包：Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能。而JavaScript则不具有这个能力。 高性能Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。 快速内存分配 Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。 类型安全 由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。 2、Flutter框架结构我们先看一下Flutter官方提供的Flutter框架图，如下图所示： Flutter Framework这是一个纯Dart实现的SDK，它实现了一套基础库。 底下两层（Foundation和Animation、Painting、Gestures）在Google的一些视频中被合并为一个Dart UI层，对应的是Flutter中的dart:ui包，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。 Rendering层：这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI 框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制（调用底层dart:ui）。 Widgets层是Flutter提供的一套基础组件库，在基础组件库之上，Flutter还提供了Material和Cupertino两种视觉风格的组件库。我们Flutter开发大多数场景就是和这两层打交道。 Flutter Engine这是一个纯C++实现的SDK，其中包括了Skia引擎、Dart运行时、文字排版引擎等等。在代码调用dart:ui库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。 关于Flutter的安装请参考Flutter中文网的安装教程：https://flutterchina.club/get-started/install/","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"Flutter","slug":"前端/Flutter","permalink":"http://www.chenhanpeng.com/categories/前端/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.chenhanpeng.com/tags/Flutter/"}]},{"title":"Python从小白到攻城狮(18)——进程和线程","slug":"python_series/python_18_进程和线程","date":"2019-12-08T14:39:51.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-18-process-and-thread/","link":"","permalink":"http://www.chenhanpeng.com/python-18-process-and-thread/","excerpt":"","text":"在当下，无论用哪一门编程语言进行开发，实现让程序同时执行多个任务，也就是常说的“并发编程”，是程序员的必备技能之一。为此，我们需要先讨论两个概念：进程和线程。 概念进程进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理地分配资源。 进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，InterProcess Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 线程一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验。 多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。 Python中的多进程Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池(pool)、用于进程间通信的队列(Queue)和管道(Pipe)等。 下面，我们用下载文件的例子来说明使用多进程和不使用多进程的差别： 123456789101112131415161718from random import randintfrom time import time, sleepdef download_task(filename): print('开始下载%s ' % filename) download_time = randint(5, 10) sleep(download_time) print('%s 下载完成， 共耗时 %d 秒' % (filename, download_time))def main(): start = time() download_task('Python从入门到住院.pdf') download_task('Peking Hot.avi') end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 12345开始下载Python从入门到住院.pdfPython从入门到住院.pdf 下载完成， 共耗时 9 秒开始下载Peking Hot.aviPeking Hot.avi 下载完成， 共耗时 5 秒总共耗费了14.02秒. 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，显然这不合理且效率低。我们该用多进程的方式将两个下载任务放到不同的进程中，代码如下： 12345678910111213141516171819202122232425from random import randintfrom time import time, sleepfrom os import getpidfrom multiprocessing import Processdef download_task(filename): print('开始下载，进程：[%d]' % getpid()) print('开始下载 %s' % filename) download_time = randint(5, 10) sleep(download_time) print('%s 下载完成，耗时 %d 秒' % (filename, download_time))def main(): start = time() p1 = Process(target=download_task, args=('Python从入门到住院.pdf', )) p1.start() p2 = Process(target=download_task, args=('Peking Hot.avi', )) p2.start() p1.join() p2.join() end = time() print('总共耗时 %.2f 秒' % (end - start))if __name__ == '__main__': main() 执行结果：12345678进程和线程/download-with-multiprocessing.py开始下载，进程：[22364]开始下载 Peking Hot.avi开始下载，进程：[20448]开始下载 Python从入门到住院.pdfPeking Hot.avi 下载完成，耗时 6 秒Python从入门到住院.pdf 下载完成，耗时 9 秒总共耗时 9.30 秒 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。 123456789101112131415161718from multiprocessing import Processfrom time import time, sleepcounter = 0def task(string): global counter while counter &lt; 10: print(string, end=' ', flush=True) counter += 1 sleep(0.01)def main(): Process(target=task, args=('ping', )).start() Process(target=task, args=('pong', )).start()if __name__ == '__main__': main() 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的，有兴趣的读者可以自己尝试一下。 Python中的多线程在Python早期的版本中就引入了thread模块来实现多线程编程，thread 模块已被废弃，所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发推荐使用threading模块，该模块对于多线程编程提供了更好的面向对象的封装。 我们用多线程的方式来实现刚才下载文件的例子： 1234567891011121314151617181920212223from random import randintfrom threading import Threadfrom time import time, sleepdef download(filename): print('开始下载 %s' % filename) download_time = randint(5, 10) sleep(download_time) print('%s 下载完成，耗时 %d 秒' % (filename, download_time))def main(): start = time() t1 = Thread(target=download, args=('Python从入门到住院.pdf', )) t1.start() t2 = Thread(target=download, args=('Peking Hot.avi', )) t2.start() t1.join() t2.join() end = time() print('下载完成，共耗时 %.df秒' % (end - start))if __name__ == '__main__': main() 运行结果如下：12345开始下载 Python从入门到住院.pdf开始下载 Peking Hot.aviPeking Hot.avi 下载完成，耗时 5 秒Python从入门到住院.pdf 下载完成，耗时 10 秒下载完成，共耗时 10f秒 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。1234567891011121314151617181920212223242526272829from random import randintfrom threading import Threadfrom time import time, sleepclass DownloadTask(Thread): def __init__(self, filename): super().__init__() self._filename = filename def run(self): print('开始下载%s...' % self._filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (self._filename, time_to_download))def main(): start = time() t1 = DownloadTask('Python从入门到住院.pdf') t1.start() t2 = DownloadTask('Peking Hot.avi') t2.start() t1.join() t2.join() end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142from time import sleepfrom threading import Threadclass Account(object): def __init__(self): super().__init__() self._balance = 0 def deposit(self, money): balance_tmp = self._balance + money sleep(0.01) self._balance = balance_tmp @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] # 创建100个存款的线程向同一个账户中存钱 for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() # 等所有存款的线程都执行完毕 for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__': main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from time import sleepfrom threading import Thread, Lockclass Account(object): def __init__(self): super().__init__() self._balance = 0 self._lock = Lock() def deposit(self, money): # 先获取锁才能执行后续代码 self._lock.acquire() try: balance_tmp = self._balance + money sleep(0.01) self._balance = balance_tmp finally: # 释放锁 self._lock.release() @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for t in threads: t.join() print('账户余额为： ￥%d元' % account.balance)if __name__ == '__main__': main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。 多进程还是多线程无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。 但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。 是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。 除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。 单线程+异步I/O现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。 在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"Python教程","slug":"Python教程","permalink":"http://www.chenhanpeng.com/tags/Python教程/"},{"name":"进程","slug":"进程","permalink":"http://www.chenhanpeng.com/tags/进程/"},{"name":"线程","slug":"线程","permalink":"http://www.chenhanpeng.com/tags/线程/"}]},{"title":"Python从小白到攻城狮(17)——os 文件目录方法","slug":"python_series/python_17_os_文件目录方法","date":"2019-11-13T08:32:15.000Z","updated":"2021-01-12T07:04:17.407Z","comments":true,"path":"python-17-os/","link":"","permalink":"http://www.chenhanpeng.com/python-17-os/","excerpt":"","text":"os模块常用方法Python内置的os模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下： 模式 描述 os.access(path, mode) 检验权限模式 os.chdir(path) 改变当前工作目录 os.chflags(path, flags) 设置路径的标记为数字标记 os.chmod(path, mode) 更改权限 os.chown(path, uid, gid) 更改文件所有者 os.chroot(path) 改变当前进程的根目录 os.close(fd) 关闭文件描述符fd os.closerange(fd_low, fd_high) 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 os.dup(fd) 复制文件描述符id os.dup2(fd, fd2) 将一个文件描述符fd复制到另一个fd2 os.fchdir(fd) 通过文件描述符改变当前工作目录 os.fchmod(fd, mode) 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 os.fchown(fd, uid, gid) 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 os.fdatasync(fd) 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 os.fdopen(fd[, mode[, bufsize]]) 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 os.fpathconf(fd, name) 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 os.fstat(fd) 返回文件描述符fd的状态，像stat()。 os.fstatvfs(fd) 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。 os.fsync(fd) 强制将文件描述符为fd的文件写入硬盘。 os.ftruncate(fd, length) 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 os.getcwd() 返回当前工作目录 os.getcwdu() 返回一个当前工作目录的Unicode对象 os.isatty(fd) 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 os.lchflags(path, flags) 设置路径的标记为数字标记，类似 chflags()，但是没有软链接 os.lchmod(path, mode) 修改连接文件权限 os.lchown(path, uid, gid) 更改文件所有者，类似 chown，但是不追踪链接。 os.link(src, dst) 创建硬链接，名为参数 dst，指向参数 src os.listdir(path) 返回path指定的文件夹包含的文件或文件夹的名字的列表。 os.lseek(fd, pos, how) 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 os.lstat(path) 像stat(),但是没有软链接 os.major(device) 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 os.makedev(major, minor) 以major和minor设备号组成一个原始设备号 os.makedirs(path[, mode]) 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 os.minor(device) 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 os.mkdir(path[, mode]) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 os.mkfifo(path[, mode]) 创建命名管道，mode 为数字，默认为 0666 (八进制) os.mknod(filename[, mode=0600, device]) 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。 os.open(file, flags[, mode]) 打开一个文件，并且设置需要的打开选项，mode参数是可选的 os.openpty() 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 os.pathconf(path, name) 返回相关文件的系统配置信息。 os.pipe() 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 os.popen(command[, mode[, bufsize]]) 从一个 command 打开一个管道 os.read(fd, n) 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 os.readlink(path) 返回软链接所指向的文件 os.remove(path) 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 os.removedirs(path) 递归删除目录。 os.rename(src, dst) 重命名文件或目录，从 src 到 dst os.renames(old, new) 递归地对目录进行更名，也可以对文件进行更名。 os.rmdir(path) 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 os.stat(path) 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 os.stat_float_times([newvalue]) 决定stat_result是否以float对象显示时间戳 os.statvfs(path) 获取指定路径的文件系统统计信息 os.symlink(src, dst) 创建一个软链接 os.tcgetpgrp(fd) 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 os.tcsetpgrp(fd, pg) 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 os.ttyname(fd) 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 os.unlink(path) 删除文件路径 os.utime(path, times) 返回指定的path文件的访问和修改的时间。 os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) 输出在文件夹中的文件名通过在树中游走，向上或者向下。 os.write(fd, str) 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 os.path 模块 获取文件的属性信息。 os.path模块常用方法操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。查看、创建和删除目录可以这么调用： 查看当前目录的绝对路径 1print(os.path.abspath('./')) 在某个目录下创建一个新目录 12new_dir = os.path.join('./', 'newdir')os.mkdir(new_dir) 删除一个目录os.rmdir(new_dir) 把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，os.path.join()返回这样的字符串： 1234path1 = os.path.abspath('./')path2 = 'demo.py'path = os.path.join(path1, path2)print(path) # E:/workspace/python-learning/demo.py 同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名： 1print(os.path.split('E:/workspace/python-learning/demo.py')) # ('E:/workspace/python-learning', 'demo.py') os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便： 1print(os.path.splitext('E:/workspace/python-learning/demo.py')) # ('E:/workspace/python-learning/demo', '.py') 这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"Python教程","slug":"Python教程","permalink":"http://www.chenhanpeng.com/tags/Python教程/"},{"name":"os 文件目录方法","slug":"os-文件目录方法","permalink":"http://www.chenhanpeng.com/tags/os-文件目录方法/"}]},{"title":"Python从小白到攻城狮(16)——正则表达式","slug":"python_series/python_16_正则表达式","date":"2019-11-06T00:54:37.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-16-regular-expression/","link":"","permalink":"http://www.chenhanpeng.com/python-16-regular-expression/","excerpt":"","text":"基础正则表达式(Regular Expression)是一个特殊的字符序列，它能帮助我们方便地检查一个字符串是否与某种模式匹配。 正则表达式的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。 因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符串来描述字符。 在正则表达式中，如果直接给出字符，就是精确匹配。用\\d可以匹配一个数字，\\w可以匹配一个字母或数字。.可以匹配任意字符。 在正则表达式中，要匹配边长的字符，可以用*表示任意个字符（包括0个），+表示至少一个字符，?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符。 我们一起来看个例子：1\\d&#123;3&#125;\\s+\\d&#123;3,8&#125; 我们来从左到右解读一下： \\d{3}表示匹配3个数字，例如’010’； \\s可以匹配一个空格（也包括Tab等空白符），所以\\s+表示至少有一个空格，例如匹配’ ‘，’ ‘等； \\d{3,8}表示3-8个数字，例如’1234567’。 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。 如果要匹配 010-12345 这样的号码呢？由于 - 是特殊字符，在正则表达式中，要用 \\ 转义，所以，上面的正则是\\d{3}\\-\\d{3,8}。 进阶要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’Py3000’等等； [a-zA-Z_][0-9a-zA-Z_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量； [a-zA-Z_][0-9a-zA-Z_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(P|p)ython可以匹配’Python’或者’python’。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 re模块Python从1.5版本开始增加了re模块，该模块提供了Perl风格的正则表达式模式。 re模块使Python语言拥有全部的正则表达式功能。 compile函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串作为它们的第一个参数。 re.match函数re.match 尝试从字符串的起始位置匹配一个模式。匹配成功方法返回一个匹配的对象，否则返回none。 函数语法：1re.match(pattern, string, flags=0) 函数参数说明： pattern：匹配的正则表达式 string：要匹配的字符串 flags：标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 我们可以使用group(num) 或groups()匹配对象函数来获取匹配表达式。 group(num)：匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下将返回一个包含那些组所对应值的元组。 groups()：返回一个包含所有小组字符串的元组，从1到所含的小组号。 实例：12345678910111213import reprint(re.match('www', 'www.chenhanpeng.com').span()) # 在起始位置匹配print(re.match('com', 'www.chenhanpeng.com')) # 不在起始位置匹配line = \"Cats are smarter than dogs\"# .* 表示任意匹配除换行符（\\n、\\r）之外的任何单个或多个字符matchObject = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)if matchObject: print('matchObject.group() :', matchObject.group()) print('matchObject.group(1) :', matchObject.group(1)) print('matchObject.group(2) :', matchObject.group(2))else: print('no match') re.search方法re.search()扫描整个字符串并返回第一个成功的匹配对象，否则返回None。语法：1re.search(pattern, string, flags=0) 我们可以使用group(num)或groups()匹配对象函数来获取匹配表达式。 实例：1234567891011121314import reprint(re.search(&apos;www&apos;, &apos;www.chenhanpeng.com&apos;).span())print(re.search(&apos;www&apos;, &apos;www.chenhanpeng.com&apos;).span())line = &quot;Cats are smarter than dogs&quot;; searchObj = re.search( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I) if searchObj: print (&quot;searchObj.group() : &quot;, searchObj.group()) print (&quot;searchObj.group(1) : &quot;, searchObj.group(1)) print (&quot;searchObj.group(2) : &quot;, searchObj.group(2))else: print (&quot;Nothing found!!&quot;) re.match和re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。123456789101112131415import re line = &quot;Cats are smarter than dogs&quot;; matchObj = re.match( r&apos;dogs&apos;, line, re.M|re.I)if matchObj: print (&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())else: print (&quot;No match!!&quot;) matchObj = re.search( r&apos;dogs&apos;, line, re.M|re.I)if matchObj: print (&quot;search --&gt; matchObj.group() : &quot;, matchObj.group())else: print (&quot;No match!!&quot;) 实例执行结果如下：12No match!!search --&gt; matchObj.group() : dogs 检索和替换re模块提供了re.sub用于替换字符串中的匹配项。 语法：1re.sub(pattern, repl, string, count=0, flags=0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 flags : 编译时用的匹配模式，数字形式。前三个为必选参数，后两个为可选参数。 实例：12345678910import rephone = &apos;010-23123453 # 这是一个电话号码&apos;# 删除注释num = re.sub(r&apos;#.*$&apos;, &apos;&apos;, phone)print(num)num1 = re.sub(r&apos;\\D&apos;, &apos;&apos;, phone)print(num1) 实例运行结果：12010-2312345301023123453 repl参数是一个函数 re.compile函数compile函数用于编译正则表达式，生成一个正则表达式（Pattern）对象，供match()和search()方法使用。 语法如下：1re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和’ # ‘后面的注释 re.findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表；如果没有找到，返回空列表。 注意：match和search是匹配一次，而findall是匹配所有。 语法格式如下：1re.findall(string[, pos[, endpos]]) 参数： string：待匹配的字符串 pos：可选参数，指定字符串的起始位置，默认为0 endpos：可选参数，指定字符串的结束位置，默认字符串的长度。 实例：查找字符串中的所有数字。12345678import restr = 'hello 12356 world! 0'pattern = re.compile(r'\\d+')result1 = pattern.findall(str)result2 = pattern.findall(str, 0, 8)print(result1)print(result2) 代码执行结果如下：12[&apos;12356&apos;, &apos;0&apos;][&apos;12&apos;] re.finditer和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 语法：1re.finditer(pattern, string, flags=0) 实例如下：12345import re it = re.finditer(r\"\\d+\",\"12a32bc43jf3\") for match in it: print (match.group() ) 执行结果如下：12341232433 re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： 语法：1re.split(pattern, string[, maxsplit=0, flags=0]) 参数： pattern：匹配的正则表达式 string：待匹配的字符串 maxsplit：分隔次数，maxsplit=1 表示分隔一次，默认为0，不限制次数。 实例：123456import reprint(re.split(&apos;\\W+&apos;, &apos;runoob, runoob, runoob.&apos;))print(re.split(&apos;(\\W+)&apos;, &apos; runoob, runoob, runoob.&apos;))print(re.split(&apos;\\W+&apos;, &apos; runoob, runoob, runoob.&apos;, 1)) print(re.split(&apos;a*&apos;, &apos;hello world&apos;)) # 对于一个找不到匹配的字符串而言，split 不会对其作出分割 正则表达式对象re.RegexObjectre.compile()返回RegexObject对象。 re.MatchObjectgroup()返回被RE匹配的字符串。 start()：返回匹配开始的位置 end()：返回匹配结束的位置 span()：返回一个元组包含匹配（开始，结束）的位置 正则表达式修饰符-可选标志正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位OR(|)来指定。如：re.I | re.M 被设置为I和M标志。 修饰符有下面几个： re.I ： 使匹配对大小写不敏感 re.L ： 做本地化识别（locale-aware）匹配 re.M ： 多行匹配，影响 ^ 和 $ re.S ： 使 . 匹配包括换行在内的所有字符 re.U ： 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X ： 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式模式模式字符串使用特殊的语法来表示一个正则表达式： 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。 多数字母和数字前加一个反斜杠时会拥有不同的含义。 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。 反斜杠本身需要使用反斜杠转义。 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 \\t )匹配相应的特殊字符。 下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 匹配n个前面表达式。例如，”o{2}”不能匹配”Bob”中的”o”，但是能匹配”food”中的两个o。 re{ n,} 精确匹配n个前面表达式。例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a &#124; b 匹配a或b (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配数字字母下划线 \\W 匹配非数字字母下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]。 \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]。 \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等。 匹配一个换行符。匹配一个制表符, 等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"Python教程","slug":"Python教程","permalink":"http://www.chenhanpeng.com/tags/Python教程/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.chenhanpeng.com/tags/正则表达式/"}]},{"title":"Python从小白到攻城狮(15)——命名空间和作用域","slug":"python_series/python_15_命名空间和作用域","date":"2019-11-01T00:43:24.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-15-namespace-and-scope/","link":"","permalink":"http://www.chenhanpeng.com/python-15-namespace-and-scope/","excerpt":"","text":"命名空间定义命名空间(Namespace)：从名称到对象的映射，大部分的命名空间都是通过Python字典来实现的。 命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重复名，但不同的命名空间是可以重名而没有任何影响。 一般有三种命名空间： 内置名称(built-in names)：Python语言内置的名称，比如函数名abs、char和异常名称BaseException、Exception等等。 全局名称(global names)：模块定义的名称，记录了模块的变量，包括函数、类、其他导入的模块、模块级的变量和常量。 局部名称(local names)：函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是） 命名空间的查找顺序 假设我们要使用变量count，那么查找顺序为：局部的命名空间 -&gt; 全局的命名空间 -&gt; 内置的命名空间如果找不到count，程序将放弃查找并返回一个 NameError 异常： 命名空间的生命周期命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。 因此，我们无法从外部命名空间访问内部命名空间的对象。我们通过下面的例子来更直观地了解这一点：12345678# var1为全局名称var1 = 5def test_function(): # var2为局部名称 var2 = 10 def inner_test_function(): # var3为内嵌的局部名称 var3 = 15 作用域定义作用域是一个Python程序可以直接访问命名空间的正文区域。 在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。 Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是： L（Local）：最内层，包含局部变量，比如一个函数/方法内部。 E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。 G（Global）：当前脚本的最外层，比如当前模块的全局变量。 B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。 规则顺序： L –&gt; E –&gt; G –&gt;B 在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。 内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量:12&gt;&gt;&gt; import builtins&gt;&gt;&gt; dir(builtins) Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：123456&gt;&gt;&gt; if True:... msg = 'I am from Runoob'... &gt;&gt;&gt; msg'I am from Runoob'&gt;&gt;&gt; 实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。 如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：12345678&gt;&gt;&gt; def test():... msg_inner = 'I am from Runoob'... &gt;&gt;&gt; msg_innerTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'msg_inner' is not defined&gt;&gt;&gt; 从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：1234567891011total = 0 # 这是一个全局变量# 可写函数说明def sum( arg1, arg2 ): #返回2个参数的和.\" total = arg1 + arg2 # total在这里是局部变量. print (\"函数内是局部变量 : \", total) return total #调用sum函数sum( 10, 20 )print (\"函数外是全局变量 : \", total) 输出结果如下：12函数内是局部变量 : 30函数外是全局变量 : 0 global和nonlocal关键字当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。 以下实例修改全局变量 num：12345678num = 1def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num)fun1()print(num) 输出结果如下：1231123123 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：123456789def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num)outer() 以上实例输出结果：12100100 另外有一种特殊情况，假设下面这段代码被运行：12345a = 10def test(): a = a + 1 print(a)test() 以上程序执行，报错信息如下：123456Traceback (most recent call last): File &quot;test.py&quot;, line 7, in &lt;module&gt; test() File &quot;test.py&quot;, line 5, in test a = a + 1UnboundLocalError: local variable &apos;a&apos; referenced before assignment 错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。 修改 a 为全局变量，通过函数参数传递，可以正常执行输出结果，实例如下： 12345a = 10def test(a): a = a + 1 print(a)test(a) 执行输出结果为：11 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"命名空间","slug":"命名空间","permalink":"http://www.chenhanpeng.com/tags/命名空间/"},{"name":"作用域","slug":"作用域","permalink":"http://www.chenhanpeng.com/tags/作用域/"}]},{"title":"Python从小白到攻城狮(14)——面向对象","slug":"python_series/python_14_面向对象","date":"2019-10-16T22:44:41.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-14-object-oriented-programming/","link":"","permalink":"http://www.chenhanpeng.com/python-14-object-oriented-programming/","excerpt":"","text":"面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 Python从设计之初就是一门面向对象的编程语言，因此，在Python中创建一个类和对象很容易。本节我们将详细介绍Python的面向对象编程。 接下来我们看一下面向对象的一些基本特征。 面向对象技术简介 类(class)：用来描述具有相同的属性和方法的对象的集合。它定义了改集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖(override)，也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。 继承：即一个派生类(derived class)继承基类(base class)的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 对象可以包含任意数量和类型的数据。 类定义在Python中，通过class关键字来定义类。class后面紧接着是类名，类名通常是大写开头的单词。 语法格式如下：123456class ClassName: &lt;statement1&gt; . . . &lt;statementN&gt; 类实例化后，可以使用其属性，实际上，创建一个类后，可以通过类名访问其属性。 类对象类对象支持两种操作：属性引用和实例化。 属性引用使用和Python中所有的属性引用一样的标准语法：obj.name 类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义如下：1234567891011class MyClass: i = 123 def f(self): return 'hello world'# 实例化类x = MyClass()# 访问类的属性和方法print(\"MyClass类的属性 i 为：\", x.i)print(\"MyClass类的方法 f 输出：\", x.f()) 上面的代码创建了一个新的类实例，并将该对象赋给局部变量x，x为空的对象。 运行代码得到下面结果：12MyClass类的属性 i 为： 123MyClass类的方法 f 输出： hello world 类有一个名为__init__()的特殊方法（构造方法），该方法在类实例化时会自动调用，如下所示：12def __init__(self): self.data = [] 类定义了init()方法，类的实例化操作会自动调用init()方法。如下实例化类MyClass，对应的init()方法就会被调用：1x = MyClass() 当然，init()方法可以有参数，参数通过init()传递到类的实例化操作上，例如：123456class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpartx = Complex(1, -1)print(x.r, x.i) self代表类的实例，而非类类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，按照惯例它的名称是self1234567class Test: def prt(self): print(self) print(self.__class__) t = Test()t.prt() 以上实例执行结果为：12&lt;__main__.Test instance at 0x100771878&gt;__main__.Test 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:1234567class Test: def prt(runoob): print(runoob) print(runoob.__class__) t = Test()t.prt() 以上实例执行结果为：12&lt;__main__.Test instance at 0x100771878&gt;__main__.Test 类的方法在类的内部，使用def关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数self，且self为第一个参数，self代表的是类的实例。123456789101112131415161718#类定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) # 实例化类p = people('runoob',10,30)p.speak() 继承在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。 继承最大的好处是子类获得了父类的全部功能。 Python同样支持类的继承。 派生类的定义如下：12class DerivedClassName(BaseClassName1): statement BaseClassName（基类）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用。例如：12class DerivedClassName(modname.BaseClassName): ... 12345678910111213141516171819202122232425262728#类定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) #单继承示例class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade)) s = student('ken',10,60,3)s.speak() 多继承python同样有限的支持多继承形式。多继承的类定义如下： 需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索，即方法在子类中未找到时，从左到右查找基类中是否包含方法。12class DerivedClass(Base1, Base2, Base3): statement 123456789101112131415161718192021222324252627282930313233343536373839404142434445#类定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) #单继承示例class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备class speaker(): topic = '' name = '' def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"%(self.name,self.topic)) #多重继承class sample(speaker,student): a ='' def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(\"Tim\",25,80,4,\"Python\")test.speak() #方法名同，默认调用的是在括号中排前地父类的方法 方法重写如果父类方法的功能不能满足需求，可以在子类中重写父类的方法。 示例如下：1234567891011class Parent: # 定义父类 def myMethod(self): print ('调用父类方法') class Child(Parent): # 定义子类 def myMethod(self): print ('调用子类方法') c = Child() # 子类实例c.myMethod() # 子类调用重写方法super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法 super() 函数是用于调用父类(超类)的一个方法。 执行以上程序输出结果为：12调用子类方法调用父类方法 类属性和方法类的私有属性__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs1234567891011121314class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = JustCounter()counter.count()counter.count()print (counter.publicCount)print (counter.__secretCount) # 报错，实例不能访问私有变量 类的方法在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。 self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self。 类的私有方法__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。1234567891011121314151617181920class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print('name : ', self.name) print('url : ', self.__url) def __foo(self): # 私有方法 print('这是私有方法') def foo(self): # 公共方法 print('这是公共方法') self.__foo() x = Site('菜鸟教程', 'www.runoob.com')x.who() # 正常输出x.foo() # 正常输出x.__foo() # 报错 类的专有方法： init : 构造函数，在生成对象时调用 del : 析构函数，释放对象时使用 repr : 打印，转换 setitem : 按照索引赋值 getitem: 按照索引获取值 len: 获得长度 cmp: 比较运算 call: 函数调用 add: 加运算 sub: 减运算 mul: 乘运算 truediv: 除运算 mod: 求余运算 pow: 乘方 运算符重载Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下：1234567891011121314class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print (v1 + v2) 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"面向对象","slug":"面向对象","permalink":"http://www.chenhanpeng.com/tags/面向对象/"},{"name":"类","slug":"类","permalink":"http://www.chenhanpeng.com/tags/类/"}]},{"title":"Python从小白到攻城狮(13)——迭代器和生成器","slug":"python_series/python_13_迭代器","date":"2019-10-09T16:36:00.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-13-iterator/","link":"","permalink":"http://www.chenhanpeng.com/python-13-iterator/","excerpt":"","text":"迭代器迭代是Python最强大的功能之一，是访问集合元素的一种方式。 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 字符串、列表和元组对象都可用于创建迭代器。 示例：1234list = [1, 2, 3, 4]it = iter(list)print(next(it))print(next(it)) 迭代器对象可以使用常规for语句进行遍历：1234list = [1, 2, 3, 4]it = iter(list)for x in it: print(x, end=\",\\n\") 也可以使用next()函数：12345678910import syslist = [1, 2, 3, 4]it = iter(list)while True: try: print(next(it)) except StopIteration: sys.exit() 创建一个迭代器把一个类作为一个迭代器使用需要在类中实现两个方法：__iter__() 和 __next__() iter()：返回一个特殊的迭代器对象，这个迭代器对象实现了next() 方法，并通过StopIteration异常标识迭代的完成。 next()：返回下一个迭代器对象。 通过下面的例子，看一下如何创建一个迭代器：123456789101112131415161718# 创建一个返回数字的迭代器，初始值为0，逐步递增10class numbers: def __iter__(self): self.a = 0 return self def __next__(self): x = self.a self.a += 10 return xmyclass = numbers()it = iter(myclass)print(next(it))print(next(it))print(next(it))print(next(it)) StopIterationStopIteration异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。 把上面创建迭代器的例子拿来修改，当值大于50时，停止迭代。12345678910111213141516171819# 创建一个返回数字的迭代器，初始值为0，逐步递增10class numbers: def __iter__(self): self.a = 0 return self def __next__(self): if self.a &gt; 50: raise StopIteration else: x = self.a self.a += 10 return xmyclass = numbers()it = iter(myclass)for x in it: print(x) 生成器生成器(generator)：使用了yield的函数。 和普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解：生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值，并在下一次执行next()方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 下面我们使用生成器实现斐波那契数列：123456789101112131415161718import sysdef fibonacci(n): a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a+b counter += 1f = fibonacci(10)while True: try: print(next(f), end=\" \") except StopIteration: sys.exit() 输出结果如下：10 1 1 2 3 5 8 13 21 34 55 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"迭代器","slug":"迭代器","permalink":"http://www.chenhanpeng.com/tags/迭代器/"},{"name":"生成器","slug":"生成器","permalink":"http://www.chenhanpeng.com/tags/生成器/"}]},{"title":"Python从小白到攻城狮(12)——错误和异常","slug":"python_series/python_12_错误和异常","date":"2019-09-27T02:12:37.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-12-error-and-exception/","link":"","permalink":"http://www.chenhanpeng.com/python-12-error-and-exception/","excerpt":"","text":"和其他语言一样，异常处理是Python中一种很常见，并且很重要的机制和代码规范。 Python有两种错误很容易辨认：语法错误和异常。 语法错误语法错误: 就是你写的代码不符合编程规范，无法被识别与执行。比如下面这个例子：12if name is not None print(name) if语句漏了冒号，不符合Python的语法规范，所以程序报错 invalid syntax1234 File &quot;invalid_syntax.py&quot;, line 2 if name is not None ^SyntaxError: invalid syntax 异常异常：程序的语法正确，也可以被执行，但在运行期检测到的错误被称为异常。 大多数的异常都不会被程序处理，都以错误信息的形式展现在这里：123456789101112&gt;&gt;&gt; 10 / 0Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ZeroDivisionError: division by zero&gt;&gt;&gt; 4 + num * 2Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'num' is not defined&gt;&gt;&gt; 1 + [1, 3]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: unsupported operand type(s) for +: 'int' and 'list' 异常以不同的类型出现，这些类型都作为信息的一部分打印出来，例子中的类型有：ZeroDivisionError，NameError，TypeError。 错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。 当然，Python中还有很多其他异常类型，比如KeyError是指字典中的键找不到；FileNotFoundError是指发送了读取文件的请求，但相应的文件不存在等等，我在此不一一赘述，你可以自行参考相应文档。 异常处理如果执行到程序中某处抛出了异常，程序就会被终止并退出。那有没有什么办法可以不终止程序，让其照样运行下去呢？答案当然是肯定的，这也就是我们所说的异常处理，通常使用try和except来解决。 try语句按照如下方式工作： 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。 处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:123456789try: s = input('please enter two numbers separated by comma: ') num1 = int(s.split(',')[0].strip()) num2 = int(s.split(',')[1].strip()) ...except (ValueError, IndexError) as err: print('Error: &#123;&#125;'.format(err)) print('continue') 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。1234567891011try: s = input('please enter two numbers separated by comma: ') num1 = int(s.split(',')[0].strip()) num2 = int(s.split(',')[1].strip()) ...except ValueError as err: print('Value Error: &#123;&#125;'.format(err))except IndexError as err: print('Index Error: &#123;&#125;'.format(err))print('continue') 不过很多时候，我们很难保证程序覆盖所有的异常类型，通常的做法是在最后一个except block，声明其处理的异常类型是Exception。Exception是其他所有非系统异常的基类，能够匹配任意非系统异常。代码如下：12345678910111213try: s = input('please enter two numbers separated by comma: ') num1 = int(s.split(',')[0].strip()) num2 = int(s.split(',')[1].strip()) ...except ValueError as err: print('Value Error: &#123;&#125;'.format(err))except IndexError as err: print('Index Error: &#123;&#125;'.format(err))except Exception as err: print('Other Error: &#123;&#125;'.format(err))print('continue') 最后一个except子句可以忽略异常的名称，它将被当做通配符使用，表示与任意异常相匹配（包括系统异常等）。12345678910111213try: s = input('please enter two numbers separated by comma: ') num1 = int(s.split(',')[0].strip()) num2 = int(s.split(',')[1].strip()) ...except ValueError as err: print('Value Error: &#123;&#125;'.format(err))except IndexError as err: print('Index Error: &#123;&#125;'.format(err))except: print('Other error')print('continue') 异常处理中，还有一个很常见的用法是finally，经常和try、except放在一起用。无论发生什么情况，finally block中的语句都会被执行，哪怕前面的try和except block中使用了return语句。 常见的应用场景如：读取文件：12345678910import systry: f = open('file.txt', 'r') .... # some data processingexcept OSError as err: print('OS error: &#123;&#125;'.format(err))except: print('Unexpected error:', sys.exc_info()[0])finally: f.close() try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有except子句之后。这个子句将在try子句没有发生任何异常的时候执行。例如： 12345678try: s = input('please enter two numbers separated by \",\":') num1 = int(s.split(',')[0].strip()) num2 = int(s.split(',')[1].strip())except ValueError as err: print('Value Error: &#123;&#125;'.format(err))else: print('in else') 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。 异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:12345678910def this_fails(): x = 1/0 try: this_fails()except ZeroDivisionError as err: print('Handling run-time error:', err)#######输出打印Handling run-time error: division by zero 抛出异常Python使用raise语句抛出一个指定的异常。例如：1234&gt;&gt;&gt; raise NameError('Error')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: Error raise唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类。 如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。 123456789101112try: raise NameError('HiThere')except NameError: print('An exception flew by!') raise###输出An exception flew by!Traceback (most recent call last): File \"deal_error.py\", line 23, in &lt;module&gt; raise NameError('HiThere')NameError: HiThere 用户自定义异常我们可以通过创建一个新的异常类来拥有自己的异常。异常类继承自Exception类，可以直接继承、或者间接继承，例如： 1234567891011class MyInputError(Exception): \"\"\"Exception raised when there're errors in input\"\"\" def __init__(self, value): # 自定义异常类的初始化 self.value = value def __str__(self): # 自定义异常类的String表达形式 return (\"&#123;&#125; is invalid input\".format(repr(self.value)))try: raise MyInputError(1)except MyInputError as error: print('error: &#123;&#125;'.format(error)) 执行上面代码块，得到下面的结果：1error: 1 is invalid input 实际工作中，如果内置的异常类型无法满足我们的需求，或者为了让异常更加详细、可读，想增加一些异常类型的其他功能，我们可以自定义所需异常类型。不多大多数情况下，Python内置的异常类型就足够我们是使用了。 总结 异常，通常是指程序运行的过程中遇到了错误，终止并退出。我们通常使用try except语句去处理异常，这样程序就不会被终止，仍能继续执行。 处理异常时，如果有必须执行的语句，比如文件打开后必须关闭等等，则可以放在finally block中。 异常处理，通常用在你不确定某段代码能否成功执行，也无法轻易判断的情况下，比如数据库的连接、读取等等。正常的flow-control逻辑，不要使用异常处理，直接用条件语句解决就可以了。 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"错误/异常","slug":"错误-异常","permalink":"http://www.chenhanpeng.com/tags/错误-异常/"}]},{"title":"Python从小白到攻城狮(11)——输入与输出","slug":"python_series/python_11_输入与输出","date":"2019-09-23T14:49:27.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-11-input-and-output/","link":"","permalink":"http://www.chenhanpeng.com/python-11-input-and-output/","excerpt":"","text":"在前面章节中，我们已经用过Python的输入和输出功能，本节将具体介绍Python的输入和输出。 输入输出 Python中最简单直接的输入来自键盘操作，我们先来看下面的例子：123456789name = input('your name is:')age = input('your age:')print('name: ' + name)print('age: ' + age)##########控制台输入与输出内容###########your name is:Jackyour age:20name: Jackage: 2 input()函数：暂停程序运行，同时等待键盘输入，知道回车键被按下，函数的参数即为提示语，输入的类型永远都是字符串类型。 print()函数：接受字符串、数字、字典、列表甚至一些自定义类的输出。 我们来看下面的例子： 12345678910a = input() # 输入1b = input() # 输入2print('a + b = &#123;&#125;'.format(a + b))print('type of a is &#123;&#125;, type of b is &#123;&#125;'.format(type(a), type(b)))print('a + b = &#123;&#125;'.format(int(a) + int(b)))#######输出########a + b = 12type of a is &lt;class 'str'&gt;, type of b is &lt;class 'str'&gt;a + b = 3 str强制转换为int用int()，转为浮点数用float()。在生产环境中使用强制转换，记得加上try except对错误或异常进行处理。 在Python中，int类型没有最大限制，float类型有精度限制。 文件输入输出open()open()将会返回一个file对象，基本语法格式如下：1open(filename, mode) filename：包含你要访问的文件名称的字符串值。mode：决定了打开文件的模式：只读，写入，追加等。这个参数非强制的，默认文件访问模式为只读(r)。所有可取值见下表： 以下示例将字符串写入到文件demo.txt中：12345# 打开一个文件f = open('./file_1.txt', 'w')f.write('Python是一门有用的编程语言。\\nHello world！')# 关闭打开的文件f.close() 查看file_1.txt文件，内容如下：12Python是一门有用的编程语言。Hello world！ 文件对象的方法假设已经创建了一个文件对象f f.read()调用f.read(size)方法，将读取文件的一定数目的数据，然后作为字符串或字节对象返回。 size是一个可选的数字类型的参数。当size被忽略或为负时，那么该文件的所有内容都将被读取并返回。 读取上一个例子创建的file_1.txt的内容：1234f = open('./file_1.txt', 'r')str = f.read()print(str)f.close() f.readline()f.readline()会从文件中读取单独的一行。换行符为”\\n”。f.readline()如果返回一个空字符串，说明已经读取到最后一行。 12345678f = open('./file_1.txt', 'r')str = f.readline()print(str)str1 = f.readline()print(str1)str2 = f.readline()print(str2)f.close() f.readlines()f.readlines()将返回该文件中包含的所有行。 如果设置可选参数sizehint，则读取指定长度的字节，并且这些字节按行分割。1234f = open('./file_1.txt', 'r')str = f.readlines()print(str) # ['Python是一门有用的编程语言。\\n', 'Hello world！']f.close() f.write()f.write(string)将string写入到文件中，然后返回写入的字符数。 如果要写入一些不是字符串的东西，那么需要先进行转换：12345f = open('./file_2.txt', 'w')value = ('Python从小白到攻城狮', 666)s = str(value)f.write(s)f.close() f.tell()f.tell()返回文件对象当前所处的位置，它是从文件开头开始算起的字节数。 f.seek()如果要改变文件当前的位置，可以使用f.seek(offset, from_what)函数。 from_what的值默认为0，如果是0表示开头，如果是1表示当前位置，2表示文件的结尾，例如： seek(x, 0)：从起始位置即文件首行首字符开始移动x个字符 seek(x, 1)：表示从当前位置往后移动x个字符 seek(-x, 2)：表示从文件的结尾往前移动x个字符1234567891011&gt;&gt;&gt; f = open('./file_2.txt', 'rb+')&gt;&gt;&gt; f.write(b'0123456789abcdef')16&gt;&gt;&gt; f.seek(5)5&gt;&gt;&gt; f.read(1)b'5'&gt;&gt;&gt; f.seek(-3, 2)26&gt;&gt;&gt; f.read(1)b'6' f.close()在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。 当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。 当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短。 JSON序列化 JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。其设计意图是把所有事情都用设计的字符串来表示，既方便在互联网上传递信息，也方便人阅读。在当今互联网中，JSON的应用非常广泛。 json.dumps()函数：接受Python的基本数据类型，然后将其序列化为string。 json.loads()函数：接受一个合法字符串，然后将其反序列化为Python的基本数据类型。 123456789101112131415import jsondata = &#123; 'name': 'Jack', 'age': 20, 'address': 'Fujian, China',&#125;data_str = json.dumps(data)print('after json dumps')print('type of data_str is &#123;&#125;, data_str = &#123;&#125;'.format(type(data_str), data_str))origin_data = json.loads(data_str)print('after json loads')print('type of origin_data is &#123;&#125;, origin_data = &#123;&#125;'.format(type(origin_data), origin_data)) 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"}]},{"title":"Python从小白到攻城狮(10)——高阶函数","slug":"python_series/python_10_高阶函数","date":"2019-09-22T13:28:53.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-10-higher-order-function/","link":"","permalink":"http://www.chenhanpeng.com/python-10-higher-order-function/","excerpt":"","text":"本节将主要介绍什么是高阶函数、高阶函数的用法以及Python的几个常见的内置高阶函数。 什么是高阶函数高阶函数(Higher-order function)：一个函数可以作为参数传给另一个函数，或者一个函数的返回值为另一个函数（若返回值为该函数本身，则为递归），满足其一则为高阶函数。 下面，我们通过例子来进一步学习高阶函数的用法。 参数为函数12345678910111213# 参数为函数def print_hello(): print('hello world')def print_function(func): func() print('in the print_function')print_function(print_hello)########输出结果######hello worldin the print_function 在上面的代码中，我们将print_hello()函数作为参数func传递给print_function()函数，直接调用print_hello()和调用func()结果一样。 返回值为函数1234567891011121314# 返回值为函数def print_hello(): print('hello world')def print_function(): print('in the print_func') return print_helloresult = print_function()result()#####输出#####in the print_funchello world 上面的例子中，print_hello()函数作为print_function()的返回值。 备注：函数名(print_hello、print_function)–&gt;其为该函数的内存地址；函数名+括号(print_hello())–&gt;调用该函数。 Python内置的高阶函数map()、filter()、reduce()、sorted()，这几个均为Python内置的高阶函数。通常结合匿名函数lambda一起使用。接下来我们看一下这三个函数的用法以及其内部原理。 map(function, iterable)函数：map函数接收的是两个参数：一个函数，一个Iterable。map对iterable中的每个元素，都运用function这个函数，最后返回一个新的Iterable，即迭代器对象，例如：&lt;map object at 0x00000214EEF40BA8&gt;。 比如：要对列表中的每个元素乘以2，用map可以实现如下：123l = [1, 2, 3, 4, 5]re = map(lambda x: x * 2, l)print(list(re)) # [2， 4， 6， 8， 10] filter(function, iterable)函数filter函数和map函数类似，也是接收一个函数和一个序列的高阶函数，主要功能是过滤。 filter()函数表示对iterable中的每个元素，都是用function判断，并返回True或False，最后将返回True的元素组成一个迭代器对象，其返回值也是迭代器对象，例如：&lt;filter object at 0x000002042D25EA90&gt;。 注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。 比如：我们要返回一个列表中的所有奇数：123l = [1, 2, 3, 4, 5]result = filter(lambda x: x % 2 == 1, l)print(list(result)) #[1, 3, 5] reduce(function, iterable)函数这里的function同样是一个函数对象，规定它有两个参数，表示对iterable中的每个元素及上一次调用的结果，运用function进行计算，所以最后返回的是一个单独的数值。 例子：计算某个列表元素的乘积。12345from functools import reducel2 = [1, 2, 3, 4, 5]result = reduce(lambda x, y: x * y, l2)print(result) # 1*2*3*4*5=120 python3中reduce函数被取消了，放入到了functools模块中，所以在语句前加上一条：from functools import reduce sorted()函数sorted() 函数对所有可迭代的对象进行排序操作。 sort 与 sorted 区别： sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。 list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。 sorted语法：sorted(iterable, key=None, reverse=False) 参数说明： iterable：可迭代对象 key：主要用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse：排序规则，reverse=True 降序，reverse=False 升序（默认）。 返回值返回重新排序的列表 示例1234567891011a = [1, 5, 3, 6, 9, 8]b = sorted(a)print(a) # [1, 5, 3, 6, 9, 8]print(b) # [1, 3, 5, 6, 8, 9]l = [('b', 2), ('a', 1), ('c', 3), ('d', 4)]l1 = sorted(l, key=lambda s:s[1])print(l1) # [('a', 1), ('b', 2), ('c', 3), ('d', 4)]l2 = sorted(l, key=lambda s:s[1], reverse=True) # 降序print(l2) # [('d', 4), ('c', 3), ('b', 2), ('a', 1)] 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"高阶函数","slug":"高阶函数","permalink":"http://www.chenhanpeng.com/tags/高阶函数/"}]},{"title":"Python从小白到攻城狮(9)——匿名函数","slug":"python_series/python_9_匿名函数","date":"2019-09-18T04:00:13.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-9-lambda/","link":"","permalink":"http://www.chenhanpeng.com/python-9-lambda/","excerpt":"","text":"在前面函数那节中，我们一起学习了Python的常规函数。但是在代码中，除了常规函数，我们也会见到一些“非常规”函数，它们往往很简短，就一行，并且有个很酷炫的名字——lambda，这就是匿名函数。 什么是匿名函数所谓匿名，即不再使用def语句这样标准的形式定义一个函数。 lambda只是一个表达式，函数体比def简单得多。 lambda的主题是一个表达式，而不是一个代码块，仅仅能在lambda表达式中封装有限的逻辑进去。 lambda函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只有一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 语法lambda函数的语法只包含一个语句，如下：1lambda argument1, argument2,... argumentN : expression 从上面的语法我们可以看到，匿名函数的关键字是lambda，之后是一系列的参数，用冒号隔开，最后则是由这些参数组成的表达式。 我们通过几个例子来看下它的用法：12345square = lambda x: x**2print(square(5))sum = lambda x, y: x + yprint(sum(2, 3)) 可以看到，匿名函数lambda和常规函数一样，返回的都是一个函数对象(function object)，它们的用法也极其相似，不过有下面几点区别： 匿名函数和常规函数区别第一，lambda是一个表达式(expression)，而不是一个语句(statement)。 所谓的表达式，就是用一系列“公式”去表达一个东西，比如 x+y 、 x**2等等。 所谓的语句，则一定是完成了某些功能，比如赋值语句 x = 2完成了赋值，print语句print(x) 完成了打印等等。 因此，lambda可以用在一些常规函数def不能用的地方，比如，lambda可以用在列表内部，而常规函数却不能：12l = [(lambda x: x*x)(x) for in range(10)]print(l) 再比如，lambda可以被用作某些函数的参数，而常规函数def也不能：123l = [(1, 20), (3, 10), (5, 25), (2, 0)]l.sort(key=lambda x: x[1]) # 按照列表中元组的第二个元素排序print(l) 常规函数def必须通过其函数名被调用，因此必须首先被定义。但是作为一个表达式的lambda，返回的函数对象就不需要名字了。 第二，lambda的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块。这其实是出于设计的考虑。Python之所以发明lambda，就是为了让它和常规函数各司其职：lambda专注于简单的任务，而常规函数则负责更复杂的多行逻辑。 用匿名函数改造下面的代码：1234567def is_odd(n): return n % 2 == 1L = list(filter(is_odd, range(1, 10)))# lambda改造new_l = list(filter(lambda x: x % 2 == 1, range(1, 10))) 总结这一节，我们一起学习了Python中的匿名函数lambda，它的主要用途是减少代码的复杂度。需要注意的是lambda是一个表达式，并不是一个语句；它只能写成一行的表达形式，语法上并不支持多行。匿名函数通常的使用场景是：程序中需要使用一个函数完成一个简单的功能，并且该函数只调用一次。 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"}]},{"title":"Python从小白到攻城狮(8)——模块","slug":"python_series/python_8_模块","date":"2019-09-05T15:00:13.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-8-module/","link":"","permalink":"http://www.chenhanpeng.com/python-8-module/","excerpt":"","text":"随着程序代码越写越多，一个文件中的代码越来越长，也越来越难以维护。为了编写可维护的代码，我们把很多函数分组，放到不同的文件中，这样每个文件包含的代码相对较少。 在Python中，一个.py文件就称为一个模块(Module)，里面定义了一些函数、类和变量，也可能包含可执行的代码。 模块让你能够有逻辑地组织你的 Python 代码段。把相关的代码分配到一个模块里能让你的代码更好用，更易懂。 模块 从上面我们知道了模块就是一个.py文件，接下来我们来看下如何定义和引用一个模块。 如何定义一个模块下面是简单的模块hello.py:12def print_hello(): print('hello world!') import 语句定义好模块后，我们可以使用import语句来引入模块，语法如下：1import module1[, module2[,... moduleN]] 当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。 调用的时候使用函数名.方法名来进行调用。 我们新建一个test_hello.py文件来调用hello.py模块的方法。123import hellohello.print_hello() 不管你执行多少次import，一个模块只会被导入一次。这样可以防止导入模块被一遍又一遍地执行。 from…import语句Python的from语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下1from module import name1[, name2[, ... nameN]] 例如，我们要导入hello.py模块中的print_hello方法，使用如下语句：1from hello import print_hello 这个声明不会把整个 hello 模块导入到当前的命名空间中，它只会将 hello 里的 print_hello 单个引入到执行这个声明的模块的全局符号表。 from…import* 语句把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：1from modname import * 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。 Python中的包 包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的Python的应用环境。 简单来说，包就是文件夹，但该文件夹下必须存在init.py文件，该文件的内容可以为空。init.py用于标识当前文件夹是一个包。 示例：我们创建一个test包，目录结构如下：123test -- __init__.py -- test_cal.py test_cal.py模块的代码如下：12345def add(x, y): return x + ydef square(x): return x * x 包的使用Python包的使用和模块的使用类似，可以通过import语句和from…import语句导入。 新建一个do.py来导入和使用test包，我们先用import语句导入：12import test.test_calprint(test.test_cal.add(10, 20)) 如果包含多层子包，那么调用方法前面还有写一长串的包名，特别不方便，我们可以用from…import语句来简化：12from test.test_cal import squareprint(square(10)) 文中示例代码： python-learning 未完待续，持续更新中…… 参考：https://www.runoob.com/python/python-modules.html","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"模块","slug":"模块","permalink":"http://www.chenhanpeng.com/tags/模块/"}],"author":"陈汉鹏"},{"title":"Python从小白到攻城狮(7)——函数","slug":"python_series/python_7_函数","date":"2019-09-05T07:55:35.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-7-function/","link":"","permalink":"http://www.chenhanpeng.com/python-7-function/","excerpt":"","text":"什么是函数 函数是组织好的，可复用的，用来实现单一，或相关联功能的代码段。 函数能提高应用的模块性和代码的复用率。在编程中，常将一些常用的功能写成函数放在函数库中供公共选用。利用好函数，可以减少我们重复编码的工作。 在前面学习中，我们用过许多Python的内置函数，比如print()、sort()等。 如何定义一个函数 根据下面的几个规则，我们可以定义一个函数： 函数代码块以def关键词开头，后接函数标识符名称和圆括号()。 任何传入参数和自变量必须放在圆括号中。圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串——用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回None。也可以不返回。 语法123def function_name(parameters): 函数体 return [表达式] 默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。 简单的示例 1234567891011# 定义一个简单的函数def print_str(): print('hello world!')print_str()# 定义一个带参数的函数def print_string(str): print(str)print_string('Hello World!!!!') 返回多个值 Python的函数支持返回多个值，我们通过下面的例子来了解其用法：12345678# 返回多个值def test(x, y): x1 = x + 2 y1 = y + 3 return x1, y1x, y = test(10, 20)print(x, y) 函数的参数 调用函数时可使用的正式参数类型有以下4种：必备参数、关键字参数、默认参数、不定长参数。 必备参数必备参数要以正确的顺序传入函数，调用时的数量必须和声明时的一样。 下面例子中的print_necessary_params()函数，调用时必须传入一个参数，不然会出现语法错误。12345678910def print_necessary_params(str1): print(str1)print_necessary_params()######控制台输出Traceback (most recent call last): File \"function.py\", line 28, in &lt;module&gt; print_necessary_params()TypeError: print_necessary_params() missing 1 required positional argument: 'str1' 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。12345def print_keyword_params(id, price): print('id:', id) print('price', price)print_keyword_params(price=20, id=125345) 默认参数调用函数时，默认参数的值如果没有传入，则被认为是默认值。12345def print_default_param(price = 50): print(price)print_default_param()print_default_param(20) 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：1234def functionname([formal_args,] *var_args_tuple ): \"函数_文档字符串\" function_suite return [expression] 加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：1234567def print_info(arg1, *params): print('arg1:', arg1) for var in params: print(var)print_info('test')print_info(10, 20, 30, 40) 递归函数 有时候我们需要反复调用某个函数得到一个最后的值，这个时候使用递归函数是最好的解决方案。 编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。递归函数不能定义为内联函数。 举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出： fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n 所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。 于是，fact(n)用递归的方式写出来就是：1234567def fact(n): if n==1: return 1 return n * fact(n - 1)print(fact(5))print(fact(10)) 总结本节介绍了Python函数的定义，不同类型的参数的使用以及递归函数的用法。 文中示例代码： python-learning 未完待续，持续更新中…… 参考：https://www.runoob.com/python/python-functions.htmlhttps://www.liaoxuefeng.com/wiki/1016959663602400/1017268131039072http://www.ityouknow.com/python/2019/08/08/python-005.html","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"函数","slug":"函数","permalink":"http://www.chenhanpeng.com/tags/函数/"}]},{"title":"Python从小白到攻城狮(6)——条件与循环","slug":"python_series/python_6_条件与循环","date":"2019-08-27T06:12:08.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-6-condition-and-loop/","link":"","permalink":"http://www.chenhanpeng.com/python-6-condition-and-loop/","excerpt":"","text":"在前面几篇文章中，我们学习了列表、元组、字典、集合和字符串等一系列Python的基本数据类型和数据结构。但仅靠这些数据结构类型是无法支持整个程序运行的，在编程中，流程控制是程序运行的基础，它决定了程序按照什么方式去执行。 接下来给大家介绍Python流程控制相关语法。 条件语句 Python的条件语句和其他语言一样，都是用if语句实现。 if语句表示如果发生什么样的条件，执行什么样的逻辑。 语法如下：123456789if condition_1: statement_1elif condition_2: statement_2...elif condition_i: statement_ielse: statement_n 示例：1234567id = 1if id == 0: print('red')elif id == 1: print('blue')else: print('yellow') 由于Python不支持switch语句，因此，当存在多个条件判断时，我们需要用else if来实现，这在Python中的表达是 elif。在条件语句中，可能会有零到多个elif部分，else是可选的。关键字 ‘elif’ 是 ‘else if’ 的缩写，这个可以有效地避免过深的缩进。 整个条件语句是顺序执行的，如果遇到一个条件满足，比如condition_i满足时，再执行完statement_i后，便会退出整个条件语句，而不会继续向下执行。 需要注意的是： 在条件语句末尾必须加上冒号(:)，这是Python特定的语法规范。 if语句可以单独使用，但elif、else都必须和if成对使用。 循环语句循环，本质上就是遍历集合中的元素。和其他语言一样，python中的循环一般通过for循环和while循环实现。 for循环语法格式如下：123456'''for 后面跟变量名，in后面跟序列（主要指列表、元组、字符串、文件等等）for 循环每次从序列中取一个值放到变量中'''for item in &lt;iterable&gt;: statements(s) 示例：1234567s = 'hello world'for char in s: print(char)list = [1, 2, 3, 4, 5]for item in list: print(item) 我们也可以通过索引来遍历元素。通常通过range()函数拿到索引，再去遍历访问元素。 12# 生成一个等差级数链表range (start， end， scan): 参数含义： start：计数从start开始，默认从0开始。比如range(3)等价于range(0, 3) end：计数到end结束，但不包括end。比如range(0, 3)的结果是[0, 1, 2]，但不包含3 scan：每次跳跃的间距，默认为1。 示例如下： 1234# 通过range()函数获取索引，再去遍历l = ['zhangsan', 'lisi', 'wangwu', 'sunliu', 'zhouqi']for index in range(0, len(l)): print(l[index]) 如果我们同时需要索引和元素时，可以通过Python内置的enumerate()函数来遍历集合。123# enumerate()函数来遍历集合for index, item in enumerate(l): print('index: &#123;&#125;, value: &#123;&#125;'.format(index, item)) 这里单独强调一下字典。字典本身只有键是可迭代的，如果我们要遍历它的值或者键值对，需要通过其内置的函数values()或items()实现。其中，values()返回字典的值的集合，items()返回键值对的集合。 12345678910111213d = &#123;'name': 'jack', 'age': 20, 'gender': 'male'&#125;# 遍历字典的键for k in d: print(k)# 遍历字典的值for val in d.values(): print(val)# 遍历字典的键值对for k, v in d.items(): print('key: &#123;&#125;, value: &#123;&#125;'.format(k, v)) while循环while循环，表示当condition满足时，一直重复循环执行某段程序，直到condition不再满足，就跳出循环体。12while condition: 执行语句..... 很多时候，for循环和while循环可以相互转换，比如要遍历一个列表，用while循环同样可以完成。12345list = [1, 2, 3, 4, 5]index = 0while index &lt; len(list): print(list[index]) index += 1 也可以在 while 循环中添加判断逻辑123456count = 0while count &lt; 3: print('count 小于3') count += 1else: print('count 大于等于3') break用法break可以跳出for循环和while循环。如果从for或while循环跳出，相应的循环else代码块将不执行。示例：123456789101112for char in 'hello world': if char == 'l': break print(char)count = 0while count &lt; 10: if count &gt;= 5: break print(count) count += 1 continue用法continue语句用来跳过当前循环块中的剩余语句，然后进行下一轮循环。123456i = 1while i &lt; 10: i += 1 if i%2 &gt; 0: # 非双数时跳过输出 continue print(i) 条件与循环的复用前面我们介绍了条件与循环的基本操作，接下来我们来看看它们的进阶操作，让程序变得更简洁高效。 在阅读别人代码时，我们会发现，很多将条件和循环并做一行的写法，如：1expression1 if condition else expression2 for item in iterable 我们将上面的表达式分解成多行代码，等同于下方的嵌套结构：12345for item in iterable: if condition1: expression1 else: expression2 如果表达式中没有else语句，则需要写成：1expression1 for item in iterable if condition1 接下来我们用两个例子来熟悉一下这种写法。 1、我们要绘制y = 2*|x| + 5 的函数图像，给定集合x的数据点，需要计算出y的数据集合123x = [-2, -1, 0, 1, 2]y = [value * 2 + 5 if value &gt; 0 else -value * 2 + 5 for value in x]print(y) 2、将文件中逐行读取的一个完整语句，按逗号分割单词，去掉首位的空字符，并过滤掉长度小于等于5的单词，最后返回由单词组成的列表123text = ' Today , is, Sunday 'text_list = [s.strip() for s in text.split(',') if len(s) &gt; 5]print(text_list) 当然，这样的复用并不仅仅局限于一个循环。比如：给定两个列表x、y, 要求返回x、y中所有元素对组成的元组，相等的情况除外。那么，我们可以用下面的表达式表示出来：1[(xx, yy) for xx in x for yy in y if xx != yy] 写法等价于：12345l = []for xx in x: for yy in y: if xx != yy: l.append((xx, yy)) 熟练之后，你会发现这种写法非常方便。当然，如果遇到逻辑很复杂的复用，你可能会觉得写成一行难以理解、容易出错。那种情况下，用正常的形式表达，也不失为一种好的规范和选择。 下面的一个练习题，大家尝试分别用一行和多行条件循环语句来实现，参考代码点击文末示例代码链接获取。1234567891011给定下面两个列表attributes和values，要求针对values中每一组子列表value，输出其和attributes中的键对应后的字典，最后返回字典组成的列表。attributes = [&apos;name&apos;, &apos;dob&apos;, &apos;gender&apos;]values = [[&apos;jason&apos;, &apos;2000-01-01&apos;, &apos;male&apos;], [&apos;mike&apos;, &apos;1999-01-01&apos;, &apos;male&apos;],[&apos;nancy&apos;, &apos;2001-02-01&apos;, &apos;female&apos;]]# expected output:[&#123;&apos;name&apos;: &apos;jason&apos;, &apos;dob&apos;: &apos;2000-01-01&apos;, &apos;gender&apos;: &apos;male&apos;&#125;, &#123;&apos;name&apos;: &apos;mike&apos;, &apos;dob&apos;: &apos;1999-01-01&apos;, &apos;gender&apos;: &apos;male&apos;&#125;, &#123;&apos;name&apos;: &apos;nancy&apos;, &apos;dob&apos;: &apos;2001-02-01&apos;, &apos;gender&apos;: &apos;female&apos;&#125;] 总结 在条件语句中，if可以单独使用，但是elif和else必须和if同时搭配使用；而If条件语句的判断，除了boolean类型外，其他的最好显示出来。 在for循环中，如果需要同时访问索引和元素，你可以使用enumerate()函数来简化代码。 写条件与循环时，合理利用continue或者break来避免复杂的嵌套，是十分重要的。 要注意条件与循环的复用，简单功能往往可以用一行直接完成，极大地提高代码质量与效率。 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"条件与循环","slug":"条件与循环","permalink":"http://www.chenhanpeng.com/tags/条件与循环/"}]},{"title":"Python从小白到攻城狮(5)——深入浅出字符串","slug":"python_series/python_5_深入浅出字符串","date":"2019-08-25T14:54:02.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-5-string/","link":"","permalink":"http://www.chenhanpeng.com/python-5-string/","excerpt":"","text":"在《Python从小白到攻城狮（2）：数据类型和变量》中，我们简单介绍过字符串，今天这篇文章，我们将一起学习字符串的更多知识。 字符串基础 字符串(string)是Python中很常见的一种数据类型，在日志的打印、函数的注释、数据库的访问、变量的基本操作等等中都用到了字符串。 字符串是以单引号(&#39;) 、双引号(&quot;) 或者三引号(&#39;&#39;&#39; 或 &quot;&quot;&quot;)括起来的任意文本。 在python中单引号、双引号、三引号的字符串是一模一样的，没有区别。 我们来看一下字符串的几种写法：1234567name = 'zhang san'city = \"Fujian\"s1 = 'hello world's2 = \"hello world\"s3 = \"\"\"hello world\"\"\"print(s1 == s2 == s3) # 返回True说明s1 s2 s3完全一样 Python的字符串同时支持三种表达方式，主要是方便我们在字符串中，内嵌带引号的字符串。比如：12\"I'm a coder\"\"hello 'world'\" 三引号字符串，主要应用于多行字符串的情境，比如函数的注释等等。123456789def function_notes(value1, value2): \"\"\" args: value1: number value2: number return value1 + value2 \"\"\" return value1 + value2 Python也支持转义字符。 转义字符：用反斜杠开头的字符串，来表示一些特定意义的字符。常见的转义字符见下表： 1234567&gt;&gt;&gt; s = 'a\\nb\\tc\\''&gt;&gt;&gt; print(s)ab c'&gt;&gt;&gt; print(len(s))6 虽然字符串s打印的输出横跨了两行，但是整个字符串s仍然只有6个元素。 在转义字符中，最常见的是换行符\\n的使用。在文件读取时，如果我们一行一行读取，那么每行字符串的末尾，都会包含换行符\\n。在最后进行数据处理时，我们往往会去掉每一行的末尾的换行符。 字符串的常用操作 Python的字符串支持索引、切片和遍历等操作。 和其他数据结构一样，字符串的索引也是从0开始，index=0表示第一个元素（字符），[index:index+2]表示第index个元素到index+1个元素组成的子字符串。123text = 'welcom to china'print(text[0])print(text[1:4]) 遍历字符串同样很简单，相当于遍历字符串中的每个字符123text = 'welcom to china'for char in text: print(char) 特别要注意，Python的字符串是不可变的（immutable）。Python中字符串的改变，通常只能通过创建新的字符串来完成。比如：我们想把&#39;hello&#39;的第一个字符&#39;h&#39;，改为大写的&#39;H&#39;，可以采用下面的做法：12s = 'H' + s[1:]s = s.replace('h', 'H') 第一种方法，是直接用大写的&#39;H&#39;，通过加号&#39;+&#39;操作符，与原字符串切片操作的子字符串拼接而成新的字符串。 第二种方法，是直接扫描原字符串，把小写的&#39;h&#39;替换成大写的&#39;H&#39;，得到新的字符串。 字符串常用的函数还有下面几个： string.strip(str)：表示去掉首尾的str字符串 string.lstrip(str)：表示只去掉开头的str字符串 string.rstrip(str)：表示只去掉尾部的str字符串 string.find(sub, start, end)：表示从start到end查找字符串中子字符串sub的位置等等 string.split(separator)：表示把字符串按照separator分割成子字符串，并返回一个分割后子字符串组合的列表 下面我们通过一些练习来熟悉字符串的操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051str1 = \"hello World!\"# 利用len函数计算字符串长度print(len(str1)) # 12# 获取字符串首字母大写的拷贝print(str1.capitalize()) # Hello world!# 获取字符串变大写后的拷贝print(str1.upper()) # HELLO WORLD!# find函数查找子串的位置print(str1.find('llo')) # 2print(str1.find('hot')) # -1# # index查找子串，但找不到子串或报错# print(str1.index('llo'))# print(str1.index('hot'))# 判断字符串是否以指定的字符串开头print(str1.startswith('he')) # Trueprint(str1.startswith('ha')) # False# 判断字符串是否以指定的字符串结尾print(str1.endswith('d!')) # Trueprint(str1.endswith('ld')) # False# 将字符串以指定的宽度居中并在两侧填充指定的字符print(str1.center(50, '='))# 将字符串以指定的宽度靠右放置左侧填充指定的字符print(str1.rjust(50, '-'))str2 = '1234abcd'# 索引操作print(str2[3]) # 4# 字符串切片操作(从指定的位置开始索引)print(str2[2:5]) # 34aprint(str2[2:]) # 34abcdprint(str2[2::2]) # 3acprint(str2[::2]) # 13acprint(str2[::-1]) # dcba4321print(str2[-3:-1]) # bc# 检查字符串是否由数字构成print(str2.isdigit()) # False# 检查字符串是否以字母构成print(str2.isalpha()) # False# 检查字符串是否以数字和字母构成print(str2.isalnum()) # Truestr3 = ' my name is zhangsan '# 获得字符串修剪头尾空格后的拷贝print(str3.strip()) # my name is zhangsan 字符串的格式化 什么是字符串的格式化？通常，我们使用一个字符串作为模板，模板中会有格式符。这些格式符为后续真实值预留位置，以呈现出真实值应该呈现的样式。字符串的格式化，通常会用在程序的输出、logging等场景。 比如：我们有一个任务，给定一个用户的userid，要去数据库中查询该用户的一些信息，并返回。如果数据库中没有此人的信息，我们通常会记录下来，这样有利于往后的日志分析，或者是线上bug的调试等。123id = 123456nanme = &apos;zhangsan&apos;print(&apos;no data available for person with id: &#123;&#125;, name: &#123;&#125;&apos;.format(id, name)) 其中string.format()就是格式化函数，大括号{}就是所谓的格式符，用来为后面的真实值————变量id、name预留位置。 不过要注意，string.format()是最新的字符串格式函数与规范。自然，我们还有其他的表示方法，比如在Python之前版本中，字符串格式化通常用%来表示，那么上述的例子，就可以写成下面这样：1print('no data available for person with id: %s, name: %s' % (id, name)) 其中%s表示字符串型，%d表示整型等等，这些属于常识，你应该都了解。 当然，现在你写程序时，我还是推荐使用format函数，毕竟这是最新规范，也是官方文档推荐的规范。 也许有人会问，为什么非要使用格式化函数，上述例子用字符串的拼接不也能完成吗？没错，在很多情况下，字符串拼接确实能满足格式化函数的需求。但是使用格式化函数，更加清晰、易读，并且更加规范，不易出错。 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"字符串","slug":"字符串","permalink":"http://www.chenhanpeng.com/tags/字符串/"}]},{"title":"Python从小白到攻城狮(4)——字典和集合","slug":"python_series/python_4_字典和集合","date":"2019-08-21T12:09:49.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-4-dict-and-set/","link":"","permalink":"http://www.chenhanpeng.com/python-4-dict-and-set/","excerpt":"","text":"在前面的一篇文章 《Python从小白到攻城狮（3）：列表和元组》中，我们学习了列表和元组，了解了其基本操作和性能比较。今天这篇文章，我们来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在 Python 被广泛使用，并且性能进行了高度优化，其重要性不言而喻。 字典(dict) 什么是字典字典，dict全称dictionary，在其他语言中也称为map，是一系列无序元素的组合，其长度大小可变，元素可以任意地删减和改变。 字典的元素是一对键(key)和值(value)的配对，和列表/元组相比，字典的性能更优，尤其是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。 字典的创建字典的创建，通常有下面几种方式：1234567d1 = &#123;'name': 'jack', 'age': 20, 'gender': 'male'&#125;d2 = dict(&#123;'name': 'jack', 'age': 20, 'gender': 'male'&#125;)d3 = dict([('name', 'jack'), ('age', 20), ('gender', 'male')])d4 = dict(name='jack', age=20, gender='male')d1 == d2 == d3 == d4True # 返回True，说明创建的4个字典是一样的 元素访问刚才我们学习了如何创建字典，我们再来看元素访问的问题。字典访问可以直接索引键，如果不存在，就会抛出异常： 1234567d = &#123;'name': 'jack', 'age': 20, 'gender': 'male'&#125;d['name']'jack'd['location']Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 'location' 要避免出现key不存在的错误，我们可以通过in来判断key是否存在123456d = &#123;'name': 'jack', 'age': 20&#125;'name' in dTrue'location' in dFalse 也可以使用dict提供的get(key, default)函数来进行索引。如果键不存在，调用get()函数可以返回None, 或者返回自己指定的一个默认值。比如下面这个示例，返回了 12345d = &#123;'name': 'jack', 'age': 20, 'gender': 'male'&#125;d.get('name')'jack'd.get('location', 'null')'null' 注意：返回None的时候Python的交互环境不显示结果。 增、删、更新操作字典支持增加、删除、更新等操作。 123456789101112131415# 增加d = &#123;'name': 'jason', 'age': 20&#125;d['gender'] = 'male' # 增加元素对'gender': 'male'd['dob'] = '1999-02-01' # 增加元素对'dob': '1999-02-01'd&#123;'name': 'jason', 'age': 20, 'gender': 'male', 'dob': '1999-02-01'&#125;# 更新d['dob'] = '1998-01-01' # 更新键'dob'对应的值 # 删除d.pop('dob') # 删除键为'dob'的元素对'1998-01-01'd&#123;'name': 'jason', 'age': 20, 'gender': 'male'&#125; 排序对于字典，我们通常会根据键或值，进行升序或降序排序： 1234567d = &#123;'b': 1, 'a': 2, 'c': 10&#125;d_sorted_by_key = sorted(d.items(), key=lambda x: x[0]) # 根据字典键的升序排序d_sorted_by_value = sorted(d.items(), key=lambda x: x[1]) # 根据字典值的升序排序d_sorted_by_key[('a', 2), ('b', 1), ('c', 10)]d_sorted_by_value[('b', 1), ('a', 2), ('c', 10)] 当然，因为字典本身是无序的，所以这里返回了一个列表。列表中的每个元素，是由原字典的键和值组成的元组。 集合(set) 什么是集合集合和字典类似，也是一组key的集合，但是不存储value。由于key不能重复，所以集合是一系列无序的、唯一的元素组合。 集合的创建1234s1 = &#123;1, 2, 3&#125;s2 = set([1, 2, 3])s1 == s2True 操作集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样。所以，下面这样的操作是错误的，Python 会抛出异常： 12345s = &#123;1, 2, 3&#125;s[0]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'set' object does not support indexing 和字典一样，我们可以通过in来判断一个元素是否在集合中。 12345s = &#123;1, 2, 3&#125;1 in sTrue10 in sFalse 集合也同样支持增加、删除、更新等操作。s.add(x)：将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。 update()： 方法用于修改当前集合，可以添加新的元素或集合到当前集合中，如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。 s.remove( x )：将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。 s.discard(x)：移除集合中的元素，且如果元素不存在，不会发生错误。 123456789101112131415161718192021s = &#123;1, 2, 3&#125;s.add(4) # 增加元素 4 到集合s&#123;1, 2, 3, 4&#125;# update()方法s = &#123;1, 2, 3&#125;s1 = &#123;3, 4, 5&#125;s.update(s1)print(s)&#123;1, 2, 3, 4, 5&#125;s.remove(4) # 从集合中删除元素 4s&#123;1, 2, 3&#125;s.remove(6)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 6s.discard(6) 不过要注意，集合的 pop() 操作是删除集合中最后一个元素，可是集合本身是无序的，你无法知道会删除哪个元素，因此这个操作得谨慎使用。 排序而对于集合，其排序和前面讲过的列表、元组很类似，直接调用 sorted(set) 即可，结果会返回一个排好序的列表。 123s = &#123;3, 4, 2, 1&#125;sorted(s) # 对集合的元素进行升序排序[1, 2, 3, 4] 字典和集合性能 字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作。那接下来，就来看看，它们在具体场景下的性能表现，以及与列表等其他数据结构的对比。 比如电商企业的后台，存储了每件产品的ID、名称和价格。现在的需求是，给定某件商品的ID，我们要找出其价格。 如果我们用列表来存储这些数据结构，并进行查找，相应的代码如下： 12345678910111213141516def find_product_price(products, product_id): for id, price in products: if id == product_id: return price return None products = [ (143121312, 100), (432314553, 30), (32421912367, 150) ] print('The price of product 432314553 is &#123;&#125;'.format(find_product_price(products, 432314553))) # 输出The price of product 432314553 is 30 假设列表有 n 个元素，而查找的过程要遍历列表，那么时间复杂度就为 O(n)。即使我们先对列表进行排序，然后使用二分查找，也会需要 O(logn) 的时间复杂度，更何况，列表的排序还需要 O(nlogn) 的时间。 但如果我们用字典来存储这些数据，那么查找就会非常便捷高效，只需 O(1) 的时间复杂度就可以完成。原因也很简单，刚刚提到过的，字典的内部组成是一张哈希表，你可以直接通过键的哈希值，找到其对应的值。 123456789products = &#123; 143121312: 100, 432314553: 30, 32421912367: 150&#125;print('The price of product 432314553 is &#123;&#125;'.format(products[432314553])) # 输出The price of product 432314553 is 30 类似的，现在需求变成，要找出这些商品有多少种不同的价格。我们还用同样的方法来比较一下。 如果还是选择使用列表，对应的代码如下，其中，A 和 B 是两层循环。同样假设原始列表有 n 个元素，那么，在最差情况下，需要 O(n^2) 的时间复杂度。 123456789101112131415161718# list versiondef find_unique_price_using_list(products): unique_price_list = [] for _, price in products: # A if price not in unique_price_list: #B unique_price_list.append(price) return len(unique_price_list) products = [ (143121312, 100), (432314553, 30), (32421912367, 150), (937153201, 30)]print('number of unique price is: &#123;&#125;'.format(find_unique_price_using_list(products))) # 输出number of unique price is: 3 但如果我们选择使用集合这个数据结构，由于集合是高度优化的哈希表，里面元素不能重复，并且其添加和查找操作只需 O(1) 的复杂度，那么，总的时间复杂度就只有 O(n)。 1234567891011121314151617# set versiondef find_unique_price_using_set(products): unique_price_set = set() for _, price in products: unique_price_set.add(price) return len(unique_price_set) products = [ (143121312, 100), (432314553, 30), (32421912367, 150), (937153201, 30)]print('number of unique price is: &#123;&#125;'.format(find_unique_price_using_set(products))) # 输出number of unique price is: 3 可能你对这些时间复杂度没有直观的认识，我可以举一个实际工作场景中的例子，让你来感受一下。 下面的代码，初始化了含有 100,000 个元素的产品，并分别计算了使用列表和集合来统计产品价格数量的运行时间： 1234567891011121314151617181920import timeid = [x for x in range(0, 100000)]price = [x for x in range(200000, 300000)]products = list(zip(id, price)) # 计算列表版本的时间start_using_list = time.perf_counter()find_unique_price_using_list(products)end_using_list = time.perf_counter()print(\"time elapse using list: &#123;&#125;\".format(end_using_list - start_using_list))## 输出time elapse using list: 70.1450754 # 计算集合版本的时间start_using_set = time.perf_counter()find_unique_price_using_set(products)end_using_set = time.perf_counter()print(\"time elapse using set: &#123;&#125;\".format(end_using_set - start_using_set))# 输出time elapse using set: 0.019779799999994907 你可以看到，仅仅十万的数据量，两者的速度差异就如此之大。事实上，大型企业的后台数据往往有上亿乃至十亿数量级，如果使用了不合适的数据结构，就很容易造成服务器的崩溃，不但影响用户体验，并且会给公司带来巨大的财产损失。 字典和集合的工作原理 我们通过举例以及与列表的对比，看到了字典和集合操作的高效性。不过，字典和集合为什么能够如此高效，特别是查找、插入和删除操作？ 这当然和字典、集合内部的数据结构密不可分。不同于其他数据结构，字典和集合的内部结构都是一张哈希表。 对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。 而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。 我们来看，老版本 Python 的哈希表结构如下所示： 1234567891011--+-------------------------------+ | 哈希值 (hash) 键 (key) 值 (value)--+-------------------------------+0 | hash0 key0 value0--+-------------------------------+1 | hash1 key1 value1--+-------------------------------+2 | hash2 key2 value2--+-------------------------------+. | ...__+_______________________________+ 不难想象，随着哈希表的扩张，它会变得越来越稀疏。举个例子，比如我有这样一个字典： 1&#123;'name': 'mike', 'dob': '1999-01-01', 'gender': 'male'&#125; 那么它会存储为类似下面的形式： 123456789entries = [['--', '--', '--'][-230273521, 'dob', '1999-01-01'],['--', '--', '--'],['--', '--', '--'],[1231236123, 'name', 'mike'],['--', '--', '--'],[9371539127, 'gender', 'male']] 这样的设计结构显然非常浪费存储空间。为了提高存储空间的利用率，现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开，也就是下面这样新的结构： 123456789101112131415Indices----------------------------------------------------None | index | None | None | index | None | index ...---------------------------------------------------- Entries--------------------hash0 key0 value0---------------------hash1 key1 value1---------------------hash2 key2 value2--------------------- ...--------------------- 那么，刚刚的这个例子，在新的哈希表结构下的存储形式，就会变成下面这样： 123456indices = [None, 1, None, None, 0, None, 2]entries = [[1231236123, 'name', 'mike'],[-230273521, 'dob', '1999-01-01'],[9371539127, 'gender', 'male']] 我们可以很清晰地看到，空间利用率得到很大的提高。 清楚了具体的设计结构，我们接着来看这几个操作的工作原理。 插入操作每次向字典或集合插入一个元素时，Python 会首先计算键的哈希值（hash(key)），再和 mask = PyDicMinSize - 1 做与操作，计算这个元素应该插入哈希表的位置 index = hash(key) &amp; mask。如果哈希表中此位置是空的，那么这个元素就会被插入其中。 而如果此位置已被占用，Python 便会比较两个元素的哈希值和键是否相等。 若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。 若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），意思是两个元素的键不相等，但是哈希值相等。这种情况下，Python 便会继续寻找表中空余的位置，直到找到位置为止。 值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始，挨个往后寻找空位。当然，Python 内部对此进行了优化（这一点无需深入了解，你有兴趣可以查看源码，我就不再赘述），让这个步骤更加高效。 查找操作和前面的插入操作类似，Python 会根据哈希值，找到其应该处于的位置；然后，比较哈希表这个位置中元素的哈希值和键，与需要查找的元素是否相等。如果相等，则直接返回；如果不等，则继续查找，直到找到空位或者抛出异常为止。 删除操作对于删除操作，Python 会暂时对这个位置的元素，赋于一个特殊的值，等到重新调整哈希表的大小时，再将其删除。 不难理解，哈希冲突的发生，往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有 1/3 的剩余空间。随着元素的不停插入，当剩余空间小于 1/3 时，Python 会重新获取更大的内存空间，扩充哈希表。不过，这种情况下，表内所有的元素位置都会被重新排放。 虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。所以，平均情况下，这仍能保证插入、查找和删除的时间复杂度为 O(1)。 总结 字典和集合都是无序的数据结构，其内部的哈希表存储结构，保证了其查找、插入、删除操作的高效性。 所以，字典和集合通常运用在对元素的高效查找、去重等场景。 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"字典/集合","slug":"字典-集合","permalink":"http://www.chenhanpeng.com/tags/字典-集合/"}]},{"title":"Python从小白到攻城狮(3)——列表和元组","slug":"python_series/python_3_列表和元组","date":"2019-08-08T01:01:57.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-3-list-and-tuple/","link":"","permalink":"http://www.chenhanpeng.com/python-3-list-and-tuple/","excerpt":"","text":"Python内置了多种类型的数据结构，常用的有：列表、元组、集合和字典。 本文主要介绍列表和元组。 列表(list)和元组(tuple)定义列表和元组，都是一个可以放置任意数据类型的有序集合。 列表和元组的区别 列表是动态的，长度大小不固定，可以随意增加、删减或者改变元素（mutable）。 元组是静态的，长度大小固定，无法增加删减或改变（immutable）。 如果要对已有的元组做任何“改变”，只能重新开辟一块内存，创建新的元组。 123456789# 列表(list)list = [1, 2, 3, 4, 5]list.append(6) # 添加元素 5 到原列表的末尾print(list)# 元组tup = (1, 2, 3, 4)new_tup = tup + (5, ) # 创建新的元组 new_tup，并依次填充原元组的值print(new_tup) 列表和元组的基本操作和注意事项索引在python中，列表和元组都支持负数索引，-1表示最后一个元素，-2表示倒数第2个元素，以此类推 123456789# 列表list = [1, 2, 3, 4]list[0]list[-1]# 元组tup = (1, 2, 3, 4)tup[1]tup[-2] 切片操作列表和元组都支持切片操作1234567list = [1, 2, 3, 4]l[1:3] # 返回列表中索引从 1 到 2 的子列表[2, 3] tup = (1, 2, 3, 4)tup[1:3] # 返回元组中索引从 1 到 2 的子元组(2, 3) 随意嵌套123l = [[1, 2, 3], [4, 5]] # 列表的每一个元素也是一个列表 tup = ((1, 2, 3), (4, 5, 6)) # 元组的每一个元素也是一元组 列表和元组的相互转换两者可以通过 list() 和 tuple() 函数相互转换： 12345list((1, 2, 3))[1, 2, 3] tuple([1, 2, 3])(1, 2, 3) 常用的内置函数 count(item) 表示统计列表 / 元组中 item 出现的次数。 index(item) 表示返回列表 / 元组中 item 第一次出现的索引。 list.reverse() 和 list.sort() 分别表示原地倒转列表和排序（注意，元组没有内置的这两个函数)。 reversed() 和 sorted() 同样表示对列表 / 元组进行倒转和排序，但是会返回一个倒转后或者排好序的新的列表 / 元组。 123456789101112131415161718192021l = [3, 2, 3, 7, 8, 1]l.count(3) 2l.index(7)3l.reverse()l[1, 8, 7, 3, 2, 3]l.sort()l[1, 2, 3, 3, 7, 8] tup = (3, 2, 3, 7, 8, 1)tup.count(3)2tup.index(7)3list(reversed(tup))[1, 8, 7, 3, 2, 3]sorted(tup)[1, 2, 3, 3, 7, 8] 列表和元组存储方式的差异前面我们说过：列表和元组最重要的区别就是，列表是动态的、可变的，而元组是静态的、不可变的。这样的差异，势必会影响两者存储方式。我们先看下面的例子： 123456l = [1, 2, 3]l.__sizeof__()64tup = (1, 2, 3)tup.__sizeof__()48 上面的例子中，我们在列表和元组中放置了相同的元素，但是元组的存储空间，却比列表要少 16 字节。这是为什么呢？ 事实上，由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于 int 型，8 字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。 123456789101112131415161718l = []l.__sizeof__() // 空列表的存储空间为 40 字节40l.append(1)l.__sizeof__() 72 // 加入了元素 1 之后，列表为其分配了可以存储 4 个元素的空间 (72 - 40)/8 = 4l.append(2) l.__sizeof__()72 // 由于之前分配了空间，所以加入元素 2，列表空间不变l.append(3)l.__sizeof__() 72 // 同上l.append(4)l.__sizeof__() 72 // 同上l.append(5)l.__sizeof__() 104 // 加入元素 5 之后，列表的空间不足，所以又额外分配了可以存储 4 个元素的空间 上面的例子，大概描述了列表空间分配的过程。我们可以看到，为了减小每次增加 / 删减操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。 但是对于元组，情况就不同了。元组长度大小固定，元素不可变，所以存储空间固定。 在数据量小的情况下，这样的差异可以忽略不计。但是当数据量很大时，比如列表和元组存储元素的个数是一亿，十亿甚至更大数量级时，这种差异就不能忽视了。 列表和元组的性能通过上面列表和元组存储方式的差异的学习，我们可以得出结论：元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。 另外，Python 会在后台，对静态数据做一些资源缓存（resource caching）。通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python 就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。 但是对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。 下面的例子，是计算初始化一个相同元素的列表和元组分别所需的时间。我们可以看到，元组的初始化速度，要比列表快 5 倍。 1234python -m timeit 'x=(1,2,3,4,5,6)'20000000 loops, best of 5: 9.97 nsec per looppython -m timeit 'x=[1,2,3,4,5,6]'5000000 loops, best of 5: 50.1 nsec per loop 但如果是索引操作的话，两者的速度差别非常小，几乎可以忽略不计。 1234python -m timeit -s 'x=[1,2,3,4,5,6]' 'y=x[3]'10000000 loops, best of 5: 22.2 nsec per looppython -m timeit -s 'x=(1,2,3,4,5,6)' 'y=x[3]'10000000 loops, best of 5: 21.9 nsec per loop 当然，如果你想要增加、删减或者改变元素，那么列表显然更优。原因你现在肯定知道了，那就是对于元组，你必须得通过新建一个元组来完成。 列表和元组的使用场景那么列表和元组到底用哪一个呢？根据上面所说的特性，我们具体情况具体分析。 1. 如果存储的数据和数量不变，比如你有一个函数，需要返回的是一个地点的经纬度，然后直接传给前端渲染，那么肯定选用元组更合适。 123def get_location(): ..... return (longitude, latitude) 2. 如果存储的数据或数量是可变的，比如社交平台上的一个日志功能，是统计一个用户在一周之内看了哪些用户的帖子，那么则用列表更合适。 1234viewer_owner_id_list = [] # 里面的每个元素记录了这个 viewer 一周内看过的所有 owner 的 idrecords = queryDB(viewer_id) # 索引数据库，拿到某个 viewer 一周内的日志for record in records: viewer_owner_id_list.append(record.id) 总结 列表和元组都是有序的，可以存储任意数据类型的集合。 列表是动态的，长度可变，可以随意增加、删减、改变元素。 元组是静态的，长度大小固定，不可对元素进行增加、删减、改变操作。 列表的存储空间略大于元组，性能略逊于元组。元组相对列表更轻量级。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"列表","slug":"列表","permalink":"http://www.chenhanpeng.com/tags/列表/"},{"name":"元组","slug":"元组","permalink":"http://www.chenhanpeng.com/tags/元组/"}]},{"title":"Python从小白到攻城狮(2)——数据类型和变量","slug":"python_series/python_2_数据类型和变量","date":"2019-08-06T13:31:03.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-2-data-type-variable/","link":"","permalink":"http://www.chenhanpeng.com/python-2-data-type-variable/","excerpt":"","text":"本系列Python文章基于Python3版本，关于python的安装和配置自行百度，这里不做详细介绍。 接下来将介绍Python基础——数据类型和变量。 数据类型在Python中，能够直接处理的数据类型有以下几种： 整型Python中可以处理任意大的整数，包括负整数。支持二进制（如0b100，换算成十进制是4）、八进制（0o100，换算成十进制是64）、十六进制（0x100，换算成十进制为256）的表示法。 浮点型浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是完全相等的。浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型字符串是以单引号 &#39;或双引号&quot;括起来的任意文本，比如’Hello’或”Hello”。字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 如果字符串内部既包括 &#39; 又包括 &quot; ，可以用转义字符 \\ 来标识。 转义字符可以转义很多字符，比如 \\n 表示换行， \\t表示制表符，字符\\ 本身也要转义，所以\\\\表示字符就是\\。 123a = 'I\\'m \\\"OK\\\"!' # 表示： I'm \"OK\"!print(a)print('\\\\\\n\\\\\\t\\\\') 布尔型布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。 12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False 复数型形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。 空值空值是Python一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量命名变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头。 变量的使用123456789101112131415161718192021222324252627282930a = 123b = 14print(a + b)print(a - b)\"\"\"使用input()函数获取键盘输入使用int()进行类型转换用占位符格式化输出的字符串\"\"\"a = int(input('a = '))b = int(input('b = '))print('%d * %d = %d' % (a, b, a * b))print('%d / %d = %f' % (a, b, a / b))print('%d // %d = %d' % (a, b, a // b))\"\"\"使用type()检查变量的类型\"\"\"a = 100b = 12.345c = 1 + 5jd = 'hello, world'e = Trueprint(type(a))print(type(b))print(type(c))print(type(d))print(type(e)) 在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 运算符Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ &#124; 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= &#124;= ^= &gt;&gt;= &lt;&lt;= （复合）赋值运算符 说明： 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。 运算符的使用123456789101112131415161718192021222324252627\"\"\"运算符的使用\"\"\"a = 5b = 10c = 3d = 4e = 5a += ba -= ca *= da /= eprint(\"a = \", a)flag1 = 3 &gt; 2flag2 = 2 &lt; 1flag3 = flag1 and flag2flag4 = flag1 or flag2flag5 = not flag1print(\"flag1 = \", flag1)print(\"flag2 = \", flag2)print(\"flag3 = \", flag3)print(\"flag4 = \", flag4)print(\"flag5 = \", flag5)print(flag1 is True)print(flag2 is not False)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"}]},{"title":"Python从小白到攻城狮(1)——python环境搭建","slug":"python_series/python_1_python环境搭建","date":"2019-08-06T12:31:03.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-1-env/","link":"","permalink":"http://www.chenhanpeng.com/python-1-env/","excerpt":"","text":"Python介绍 Python是Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言，1991年发布第一版。 Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。 Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。 Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。 Python 是交互式语言： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。 Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。 Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 Python的应用领域目前Python在Web应用开发、云基础设施、DevOps、网络爬虫开发、数据分析挖掘、机器学习等领域都有着广泛的应用，因此也产生了Web后端开发、数据接口开发、自动化运维、自动化测试、科学计算和可视化、数据分析、量化交易、机器人开发、图像识别和处理等一系列的职位。 Python环境搭建 对于刚开始学习Python的新手，建议安装Anaconda。win 下安装包的时候用 anaconda 比 pip 安装要好一些，pip 有时候会因为一些依赖导致安装失败，这时候anaconda就体现出它对新手的友好。 搜索Anaconda进入官网或点击下方官网链接进入 https://www.anaconda.com/distribution/ 在页面我们可以看到windows、macOS、linux对应的安装包。 如果是初学者，建议下载Python3.X版本，而不是Python2.X。因为python的2和3版本的语法是有差异的，Python2.X将在2020年4月后不再进行任何维护。 下载安装包，双击安装。 划重点：安装过程中最好将下图所示的添加到环境变量的选项勾上。 安装之后可能程序没有自动配置anaconda环境变量，你需要手动配置！！！ 找到刚才安装的anaconda的目录，找到Scripts，打开，复制路径： 路径示例：D:\\ProgramData\\Anaconda3\\Scripts。 配置环境变量： 在Path后面添加刚才复制的路径，注意与前一个要用英文分号隔开。点击多个确定完成配置。 打开cmd 输入python，看到下面的画面，说明安装成功。 看到提示符&gt;&gt;&gt;就表示我们已经在Python交互式环境中了，可以输入任何Python代码，回车后会立即得到执行结果。输入exit()并回车，就退出Python交互模式。 第一个Python程序 Python交互模式在Python交互式环境中输入以下代码1print('Hello world!') 命令行模式通过python xxx.py运行一个.py文件 创建一个hello.py文件，文件中输入如下代码：1print('Hello World!!!') cmd的当前目录切换到hello.py所在的目录下，我的目录在 E:\\workspace\\python-learning\\1-环境搭建 ，执行下面命令可以进入到相应目录中。 1234567C:\\Users\\chenhp&gt;E:E:\\&gt;cd workspaceE:\\workspace&gt;cd python-learningE:\\workspace\\python-learning&gt;cd 1-环境搭建 在命令行中执行python hello.py，可以得到下面的执行结果： 以上内容主要介绍了windows上的环境搭建。关于macOS的环境搭建，可以百度一下安装教程，作为一个没用过mac的人就不在这里就瞎掰了。 文中示例代码： python-learning 未完待续，持续更新中……","categories":[{"name":"Python","slug":"Python","permalink":"http://www.chenhanpeng.com/categories/Python/"}],"tags":[{"name":"python教程","slug":"python教程","permalink":"http://www.chenhanpeng.com/tags/python教程/"},{"name":"python环境搭建","slug":"python环境搭建","permalink":"http://www.chenhanpeng.com/tags/python环境搭建/"}]},{"title":"带你一起用人脸识别技术判断参加美国大选的是不是吴恩达","slug":"machine_learning/带你一起用人脸识别技术判断参加美国大选的是不是吴恩达","date":"2019-07-31T03:19:50.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"face-recognition-Andrew-Ng/","link":"","permalink":"http://www.chenhanpeng.com/face-recognition-Andrew-Ng/","excerpt":"","text":"What！吴恩达去参加美国大选了？最近几周，想必很多人都有看到这新闻，是不是在想吴恩达老师是不是有个双胞胎兄弟去参加美国大选了？？？ 答案都不是，参选的是杨安泽，两人不仅长得像，英文名都叫Andrew，Andrew Yang（杨安泽）、Andrew Ng（吴恩达），下面是两个人的照片: 是不是分不清啊？没关系，接下来带你一起，用人脸识别技术判断是不是同一个人。 在上一篇文章中，我们介绍了实现人脸检测的两种方法，接下来要介绍的是人脸识别，通过对比两张人脸，计算其特征相似度，来判断是否是同一个人。 人脸识别模型使用基于NN4改造的CNN模型训练和提取特征nn4.small2.v1是FaceNet论文中描述的NN4模型的变体，在OpenFace的模型列表中有nn4.small2详细介绍，具体内容点击下方链接查看https://cmusatyalab.github.io/openface/models-and-accuracies/#model-definitions 模型列表 Model Number of Parameters nn4.small2 3733968 nn4.small1 5579520 nn4 6959088 nn2 7472144 本文使用Keras版本中的一种实现，模型定义在model.pyKeras版本的github地址：https://github.com/krasserm/face-recognition Retrain人脸识别模型工作流程1、加载训练数据集2、人脸检测、对齐和提取（使用OpenFace的人脸对齐工具AlignDlib）3、人脸特征向量学习（使用预训练的nn4.small1.v1模型）4、人脸分类（使用KNN或SVM） 加载训练数据集训练集组织形式images目录中有3张图像，两张吴恩达(Andrew Ng)的照片，一张杨安泽(Andrew Yang)照片，放一起看两个人还是很像的。 最好是1:1比例，如果原图不是1:1比例，提取后的人脸会进行拉伸变换，仅支持.jpg和.jpeg两种格式。 1234567891011121314151617181920212223242526272829303132# 加载训练数据集import numpy as npimport cv2import os.pathclass IdentityMetadata(): def __init__(self, base, file): self.base = base # 数据集根目录 # self.name = name # 目录名 self.file = file # 图像文件名 def __repr__(self): return self.image_path() def image_path(self): return os.path.join(self.base, self.file) def load_metadata(path): metadata = [] for f in os.listdir(path): # 检查文件名后缀，仅支持 jpg 和 jpeg 两种文件格式 ext = os.path.splitext(f)[1] if ext == '.jpg' or ext == '.jpeg': metadata.append(IdentityMetadata(path, f)) return np.array(metadata)def load_image(path): img = cv2.imread(path, 1) # OpenCV 默认使用 BGR 通道加载图像，转换为 RGB 图像 return img[...,::-1]metadata = load_metadata('images') 人脸检测、对齐和提取从原图提取96*96RGB人脸图像。 123456789101112131415161718192021222324252627282930313233# 人脸检测、对齐和提取import matplotlib.pyplot as pltimport matplotlib.patches as patchesfrom align import AlignDlib# 初始化 OpenFace 人脸对齐工具，使用 Dlib 提供的 68 个关键点alignment = AlignDlib('landmarks.dat')# 加载一张训练图像img = load_image(metadata[0].image_path())# 检测人脸并返回边框bb = alignment.getLargestFaceBoundingBox(img)# 使用指定的人脸关键点转换图像并截取 96x96 的人脸图像aligned_img = alignment.align(96, img, bb, landmarkIndices=AlignDlib.OUTER_EYES_AND_NOSE)# 绘制原图plt.figure(1)plt.subplot(131)plt.imshow(img)plt.xticks([])plt.yticks([])# 绘制带人脸边框的原图plt.subplot(132)plt.imshow(img)plt.gca().add_patch(patches.Rectangle((bb.left(), bb.top()), bb.width(), bb.height(), fill=False, color='red'))plt.xticks([])plt.yticks([])# 绘制对齐后截取的 96x96 人脸图像plt.subplot(133)plt.imshow(aligned_img)plt.xticks([])plt.yticks([])plt.show() 人脸检测、对齐和提取的结果如下图所示 加载预训练模型nn4.small2.v1我们从 OpenFace 提供的 预训练模型 中选择 nn4.small2.v1。 这些模型使用公开数据集 FaceScrub 和 CASIA-WebFace进行训练。Keras-OpenFace 项目将这些模型文件转换为 csv 文件，然后我们将其转换为 Keras h5 模型文件 nn4.small2.v1.h5。 预训练模型 Model alignment landmarkIndices nn4.v1 openface.AlignDlib.INNER_EYES_AND_BOTTOM_LIP nn4.v2 openface.AlignDlib.OUTER_EYES_AND_NOSE nn4.small1.v1 openface.AlignDlib.OUTER_EYES_AND_NOSE nn4.small2.v1 openface.AlignDlib.OUTER_EYES_AND_NOSE nn4.small2.v1.h5、model.py、align.py这些文件可以从下面github仓库获取：https://github.com/krasserm/face-recognition 1234567891011121314151617181920# 加载预训练模型nn4.small2.v1from model import create_modelnn4_small2_pretrained = create_model()nn4_small2_pretrained.load_weights('models/nn4.small2.v1.h5')def align_image(img): return alignment.align(96, img, alignment.getLargestFaceBoundingBox(img), landmarkIndices=AlignDlib.OUTER_EYES_AND_NOSE)embedded = np.zeros((metadata.shape[0], 128))for i, m in enumerate(metadata): img = load_image(m.image_path()) img = align_image(img) # 数据规范化 img = (img / 255.).astype(np.float32) # 人脸特征向量 embedded[i] = nn4_small2_pretrained.predict(np.expand_dims(img, axis=0))[0] 计算人脸特征的欧式距离，计算相似度Squared L2 Distance(欧式距离)，计算两个向量之间的距离。 在上一步，我们获得所有测试人脸的特征向量，我们可以通过计算其之间的距离，来判断人脸的相似度，距离越小，相似度越高。 123456789101112131415161718192021222324# Squared L2 Distancedef distance(emb1, emb2): return np.sum(np.square(emb1 - emb2))count = 0def show_pair(idx1, idx2): global count count += 1 plt.figure(num=count, figsize=(8,3)) plt.suptitle(f'Distance = &#123;distance(embedded[idx1], embedded[idx2]):.2f&#125;') plt.subplot(121) plt.imshow(load_image(metadata[idx1].image_path())) plt.xticks([]) plt.yticks([]) plt.subplot(122) plt.imshow(load_image(metadata[idx2].image_path())) plt.xticks([]) plt.yticks([])show_pair(0, 1)show_pair(0, 2)show_pair(1, 2)plt.show() 从上面三张结果图我们可以看到，两个吴恩达的照片人脸特征的欧式距离为0.09，吴恩达跟杨安泽的距离为0.33。 如何利用获得的距离来判断两个张照片上的人是否是同一个人？如果距离值低于某一阈值，则认为是同一个人。 如何确定阈值，一般通过大量已标记的测试值，阈值从小到大取值，计算获得识别的准确率，取准确率比较高阈值。 我们这里阈值取0.3，则可以判断测试的人脸1、2为同一个人，3为另一个人，但两个人长得很像。 完整代码：https://github.com/Hanpeng-Chen/tensorflow-learning","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.chenhanpeng.com/categories/机器学习/"}],"tags":[{"name":"face_recognition","slug":"face-recognition","permalink":"http://www.chenhanpeng.com/tags/face-recognition/"},{"name":"人脸识别","slug":"人脸识别","permalink":"http://www.chenhanpeng.com/tags/人脸识别/"},{"name":"FaceNet","slug":"FaceNet","permalink":"http://www.chenhanpeng.com/tags/FaceNet/"}]},{"title":"20行代码实现人脸检测","slug":"machine_learning/20行代码实现人脸检测","date":"2019-07-22T23:27:50.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"20-lines-of-code-face-recognition/","link":"","permalink":"http://www.chenhanpeng.com/20-lines-of-code-face-recognition/","excerpt":"","text":"如今，“刷脸”已经成为人们生活中的日常，刷脸支付、人脸解锁、门禁等，都运用了人脸识别技术。人脸识别技术已广泛应用于金融、司法、公安、教育、医疗等诸多领域，同时也涌现出如：旷视科技、商汤科技等一批优秀的企业。 人脸识别算法主要分为三个流程： 人脸检测（Face Detection） 人脸对齐（Face Alignment） 人脸特征表征（Feature Representation） 本文我们主要针对人脸检测这一部分，利用OpenCV和face_recognition库分别实现图片中的人脸检测。 开发环境 Windows 10(x64) OpenCV 4.1.0.25 face_recognition 1.2.3 使用OpenCV进行人脸检测OpenCV实现人脸检测的主要思路为： 将图片转换成灰度图（降为一维的灰度，减低计算强度） 使用训练分类器查找人脸 图片上画矩形 图片转为灰度图使用OpenCV的cvtColor()方法转换图片颜色1gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) 使用训练分类器查找人脸在使用OpenCV的人脸检测之前，需要一个人脸训练模型，格式为xml。 我们这里使用OpenCV提供好的人脸分类模型xml，下载地址如下：https://github.com/opencv/opencv/tree/master/data/haarcascades 图片上画矩形使用OpenCV的rectangle()绘制矩形 检测结果 完整代码123456789101112131415161718192021222324252627282930# 使用OpenCV进行人脸检测import cv2from matplotlib import pyplot as pltimagePath = './test_face_detection.jpg'# 引入OpenCV提供的人脸分类模型xmlcascPath = './haarcascade_frontalface_default.xml'# Create the haar cascadefaceCascade = cv2.CascadeClassifier(cascPath)# 读取图像并转为灰度图image = cv2.imread(imagePath)gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)# 检测图片中的人脸faces = faceCascade.detectMultiScale( gray, scaleFactor=1.1, minNeighbors=4, minSize=(30, 30))color = (0, 255, 0)# 用矩形框将人脸框出来for (x, y, w, h) in faces: cv2.rectangle(image, (x, y), (x+w, y+h), color, 2)plt.title(\"Found &#123;0&#125; faces!\".format(len(faces)))plt.axis(\"off\")plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))plt.show() 参数说明 gray：转换的灰度图 scaleFactor：图像缩放比例，可理解为相机的x倍镜 minNeighbors：对特征检测点周边多少有效点同时检测，这样可避免因选取的特征检测点太小而导致遗漏 minSize：特征检测点的最小尺寸 使用face_recognition库进行人脸检测face_recognition库是使用Dlib最先进的面部识别功能构建而成，具有深度学习功能。该模型在LFW上的准确率为99.38%。 检测结果 从上面的结果来看，face_recognition库的检测准确率比OpenCV的高。 完整代码1234567891011121314151617181920# 使用face_recognition库进行人脸检测import face_recognitionimport cv2from matplotlib import pyplot as pltimagePath = './test_face_detection.jpg'# 使用face_recognition加载图片,并检测人脸image = face_recognition.load_image_file(imagePath)#检测图片中所有人脸face_locations = face_recognition.face_locations(image)# 用矩形框框出检测到的人脸for (top, right, bottom, left) in face_locations: cv2.rectangle(image, (left, top), (right, bottom), (0, 255, 0), 2)plt.title(\"Found &#123;0&#125; faces!\".format(len(face_locations)))plt.axis(\"off\")plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))plt.show() 识别人脸关键点调用face_recognition.face_landmarks()方法即可得到人脸特征点, 返回一个字典, 下图是返回的数据, 包括chin(下巴), left_eye(左眼)等。1&#123;&apos;chin&apos;: [(184, 182), (187, 198), (191, 213), (196, 229), (202, 243), (211, 256), (223, 266), (236, 275), (251, 277), (267, 273), (281, 263), (295, 251), (304, 236), (308, 219), (309, 201), (311, 184), (311, 167)], &apos;left_eyebrow&apos;: [(192, 170), (199, 163), (210, 162), (220, 163), (231, 166)], &apos;right_eyebrow&apos;: [(246, 163), (258, 158), (269, 155), (281, 155), (291, 160)], &apos;nose_bridge&apos;: [(240, 177), (240, 187), (240, 197), (241, 208)], &apos;nose_tip&apos;: [(233, 217), (238, 218), (243, 219), (248, 217), (254, 215)], &apos;left_eye&apos;: [(205, 181), (211, 177), (219, 177), (226, 180), (219, 183), (211, 183)], &apos;right_eye&apos;: [(258, 177), (264, 172), (272, 172), (279, 174), (273, 178), (265, 178)], &apos;top_lip&apos;: [(228, 242), (234, 236), (240, 231), (245, 232), (250, 230), (258, 233), (267, 238), (263, 238), (251, 237), (246, 238), (241, 238), (232, 242)], &apos;bottom_lip&apos;: [(267, 238), (259, 243), (252, 247), (247, 248), (241, 248), (235, 246), (228, 242), (232, 242), (241, 239), (246, 239), (251, 238), (263, 238)]&#125; 人脸关键点检测结果 完整代码12345678910111213141516171819# 调用face_recognition.face_landmarks()方法得到人脸特征点import face_recognitionimport cv2from matplotlib import pyplot as pltimagePath = './test_face_landmarks.jpg'image = face_recognition.load_image_file(imagePath)face_landmarks_list = face_recognition.face_landmarks(image)for each in face_landmarks_list: for i in each.keys(): for any in each[i]: image = cv2.circle(image, any, 2, (0, 255, 0), 1)plt.title(\"Face landmarks\")plt.axis(\"off\")plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))plt.show() 本文只是使用OpenCV和face_recognition库进行实现简单的人脸检测，基于此我们还可以进行许多好玩的事情，比如：脸部轮廓绘制、数字化妆、头像特效合成等等。 上述人脸检测demo的github地址：https://github.com/Hanpeng-Chen/tensorflow-learning/tree/master/face_detection","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.chenhanpeng.com/categories/机器学习/"}],"tags":[{"name":"人脸检测","slug":"人脸检测","permalink":"http://www.chenhanpeng.com/tags/人脸检测/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.chenhanpeng.com/tags/OpenCV/"},{"name":"face_recognition","slug":"face-recognition","permalink":"http://www.chenhanpeng.com/tags/face-recognition/"}]},{"title":"你还在用二分法求2个鸡蛋100层楼的问题吗？","slug":"interview/2个鸡蛋100层楼","date":"2019-07-10T15:56:13.000Z","updated":"2020-08-10T02:19:13.721Z","comments":true,"path":"2-eggs-100-storeys/","link":"","permalink":"http://www.chenhanpeng.com/2-eggs-100-storeys/","excerpt":"","text":"题目2个鸡蛋，100层楼，如何用最少的试验次数得到在鸡蛋落下不碎的最高层数？这一据说曾被谷歌纳入校园招聘题库的经典面试题，想必许多人都曾遇到过，又有多少人与我一样，不加思索就直接回答用二分法查找的？ 但是，二分法真的是最优试验方法吗？接下来我们来分析几种解法。 首先我们先认真看一下完整的题目(之前做过这道题的同学可以跳过这一步)： 原题：两个软硬程度一样但未知的鸡蛋，它们有可能都在一楼扔下来就摔碎，也有可能从100层楼上扔下来也没事。有座100层的楼，要你用这两个鸡蛋确定哪一层是鸡蛋可以安全落下的最高位置。可以摔碎两个鸡蛋，在最坏情况下，如何用最少的试验次数得到鸡蛋落下不会被摔碎的最高层数？ 解法最笨的方法：遍历查找把其中的一个鸡蛋，从第1层开始往下扔。如果第一层没碎，换到第2层扔；如果第2层没碎，换到第3层扔…假设第50层没碎，第51层碎了，说明鸡蛋落下不会摔碎的最高层数为第50层。 这个方法在最坏情况下，需要扔99次。 二分法采用二分查找的方法： 把第一个鸡蛋从一半楼层(50层)扔下。 如果鸡蛋碎了，则第二个鸡蛋就从第1层开始扔，一层一层增长，直到49层。 如果第一枚鸡蛋在50层没有被摔碎，则继续使用二分法，从剩余的楼层的一半(75层)开始往下扔… 在最坏情况下，这种二分法需要进行50次试验0。 平方根法如何让第一个鸡蛋和第二个鸡蛋的尝试次数尽可能均衡？我们做一个平方根运算，100的平方根为10。 因此我们第一个鸡蛋每10层扔一次，第一次从第10层扔，没碎的话再加10层，即从20层扔….一直扔到100层。 第二个鸡蛋从第一个鸡蛋碎掉的n层往下9层，即n-9层开始一层一层往上试。 这种方法最好的情况为：第一个鸡蛋在第10层碎掉，尝试次数 1 + 9 = 10 次。 最坏的情况为：第一个鸡蛋在第100层碎掉，尝试次数为 10 + 9 = 19 次。 这样子看来平方根的方法算是比较好的方法，那么还有更好的方法吗？ 反向思考我们反向思考一下这个题目：假设题目存在最优解，这个最优解的最坏情况尝试x次，那么我们第一次扔要选择在第几层？ 假设第一次扔在x+1层：如果第一个鸡蛋碎了，那么第二个鸡蛋就只能从第1层开始一层一层扔，一直扔到第x层。这样总共尝试了x+1次，与最优解的尝试x次相悖。 假设第一次在x-1层：如果第一个鸡蛋碎了，那么第2个鸡蛋就要从第1层开始扔，一直到x-2层，共尝试了x-2+1=x-1次，虽然没有超出假设次数，但似乎有些过于保守。 假设第一次扔在第x层： 如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-1层。这样，我们总共尝试了x-1+1 = x次，刚刚好没有超出假设次数。 恰恰是从第x层开始扔，选择高一层或第一层都不合适。 如果第一个鸡蛋没碎，问题就变成了：在100-x层楼往下扔，要求尝试次数不超过x-1次。 那么第二次的尝试次数的上限变为x-1次，所以第2次试验的楼层跨度为x-1层，真实层数为x+x-1层。 以此类推我们可以列出楼层的方程式： x + (x - 1) + (x - 2) + … + 1 = 100 接下来就是求解方程式，我们将这种方法称为解方程法： 解方程法x + (x - 1) + (x - 2) + … + 1 = 100 =&gt; (x + 1) * x / 2 = 100 向上取整得到x=14 即最优解的最坏尝试次数为14次，第1个鸡蛋开始扔的层数也为14层。 第一个鸡蛋没碎的情况下，所尝试的楼层为：14， 27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100 假设鸡蛋不会被摔碎的最高楼层为55层，那么第一个鸡蛋尝试的楼层为14，27,39,50,60，在第60层碎了； 第二个鸡蛋从51层开始， 51,52,53,54,55,56，第56层碎了，则尝试次数为5 + 6 = 11 &lt; 14 这道面试题的解法到此到一段落，现在你还会认为二分法是这道题的最优解吗？ 其实这道题还可以衍生下面的问题：总共有M层楼，N个鸡蛋，要找到鸡蛋不被摔碎的最高楼层，需要尝试几次？ 这个问题就不在这里展开讨论了，大家可以自行尝试求解。","categories":[{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.chenhanpeng.com/tags/面试/"},{"name":"2个鸡蛋100层楼","slug":"2个鸡蛋100层楼","permalink":"http://www.chenhanpeng.com/tags/2个鸡蛋100层楼/"}]},{"title":"微信小程序使用otp算法踩坑总结","slug":"bug_summary/微信小程序使用otp算法踩坑总结","date":"2019-07-09T14:13:05.000Z","updated":"2020-08-10T02:19:13.721Z","comments":true,"path":"wechat-miniprogram-otp-use-summary/","link":"","permalink":"http://www.chenhanpeng.com/wechat-miniprogram-otp-use-summary/","excerpt":"","text":"背景前两天项目有个类似动态口令的功能要实现，团队最终决定使用OTP算法来实现：前端先向后端请求获取用户的密钥(secret)，将之保存在缓存中，之后前端根据该secret，使用OTP算法中的TOTP方式生成6位动态密码，将6位动态密码传到后台验证。 OTP1.1 简介OTP(One-Time-Password)：一次性密码，也称为动态口令。是使用密码技术实现的在客户端和服务端之间通过共享密钥的一种认证技术，是一种强认证技术，是增强目前静态密码口令认证的一种非常方便的技术手段，是一种重要的双因素认证技术。 1.2 OTP认证原理动态口令的基本认证原理是在认证双方共享密钥，也称种子密钥，并使用同一个种子密钥对某一个事件计数、或时间值、或异步挑战数进行密码算法计算，使用的算法有对称算法、HASH、HMAC，之后比较计算值是否一致进行认证。可以做到一次一个动态口令，使用后作废，口令长度通常为6-8个数字，使用方便，与通常的静态口令认证方式类似。 1.3 OTP实现方式 时间同步(TOTP) 事件同步(HOTP) 挑战/应答(OCRA) 本文内容主要是小程序使用OTP算法踩坑总结，不对OTP算法的三种实现方式的工作原理进行详细介绍，有兴趣的朋友自行查找相关资料。 踩坑记录2.1 后端使用的otp库说明opt算法有许多现成的库可以直接调用，后端使用的是aerogear-otp-java这个库，问题不在后端，这里就不对这个库进行讲解，有兴趣的朋友可以自己查看：github地址： https://github.com/aerogear/aerogear-otp-java 2.2 踩坑前提我们的微信小程序项目目前不支持引用第三方的npm包，所以要使用第三方的js库，需要将其js文件下载放到小程序目录中，通过require去引入。还有一点就是小程序项目还不支持node.js，如果js库有相关的node.js代码，还需要做一些改造。以上两点背景给我挖了一个大坑往里跳。 2.3 跳入第一个坑我们先找可用的otp的js库，上github一搜，还是很多的，先选一个start数量比较的的：https://github.com/yeojz/otplib。 我们现在node.js环境上对 otplib 这个进行测试：123456const authenticator = require(&apos;otplib/authenticator&apos;);const crypto = require(&apos;crypto&apos;);authenticator.options = &#123; crypto &#125;;const secret = &apos;BYYHJ5R6C3DNZJX3&apos;const token = authenticator.generate(secret);console.log(token); 执行上面的代码，可以获得6位动态密码，拿到后端验证，验证不通过…各种尝试和排查后，放弃了，这个库和后端的aerogear-otp-java不兼容，尴尬。。。 2.4 跳入第二个坑又到github上一通找，各种尝试，终于找到一个可以与aerogear-otp-java兼容的js库：node-lib-otpgithub地址： https://github.com/JCloudYu/node-lib-otp 12345const otp = require( &apos;lib-otp&apos; );let otpObj = otp(&#123; secret:&apos;BYYHJ5R6C3DNZJX3&apos;&#125;);console.log(otpObj.totp(6)); 将生成的6位动态密码传到后台验证，通过。 心想终于找到能用的了，有种胜利就在眼前的喜悦，马不停蹄下载相关js，着手修改其中的node.js代码，改到一半发现该库引用了太多node.js的写法和库，短时间内无法完成修改并保证可用，放弃该库了。。。 2.5 出坑在github上搜索许久仍旧未找到合适的js库，突然灵光一闪上码云找一下，搜索结果第一个superzlc/otp有写小程序，尝试一下。地址：https://gitee.com/superzlc/otp/tree/master下载js，引入该库生成动态密码1234const otp = require(&apos;./libs/otp&apos;)const TOTP = otp.TOTPconst token = new TOTP(&apos;BYYHJ5R6C3DNZJX3&apos;, 3, 30).gen()console.log(token) 验证通过，还不用修改代码，终于爬出坑了。 总结OTP算法中的TOTP方式生成6位动态密码可用库如下： 后端java ： https://github.com/aerogear/aerogear-otp-java node.js: https://github.com/JCloudYu/node-lib-otp 小程序纯js：https://gitee.com/superzlc/otp/tree/master 注意点：前后端的计数值应一致，否则无法验证通过","categories":[{"name":"问题总结","slug":"问题总结","permalink":"http://www.chenhanpeng.com/categories/问题总结/"}],"tags":[{"name":"otp算法","slug":"otp算法","permalink":"http://www.chenhanpeng.com/tags/otp算法/"},{"name":"小程序","slug":"小程序","permalink":"http://www.chenhanpeng.com/tags/小程序/"}]},{"title":"PDF.js实现在线展示pdf文件","slug":"vue_series/PDFJS实现在线展示PDF文件","date":"2019-06-27T16:03:24.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"PDF.js-use/","link":"","permalink":"http://www.chenhanpeng.com/PDF.js-use/","excerpt":"","text":"背景现在很多项目开发过程中都会碰到PDF在线预览的需求，对于PC端浏览器，一般直接提供PDF文件，iframe一下就可以直接预览。但在移动端要预览PDF则较为麻烦，有些浏览器检测到文件流，就会直接下载，无法实现预览功能。 PDFJS就是解决这一问题比较好用的一款插件。 PDF.jsPDF.js是一个使用HTML5构建的可移植文档格式库。 PDF.js官网：http://mozilla.github.io/pdf.js/ 官网给出的使用方法是将PDF.js下载到项目静态资源目录中，在html文件中引入pdf.js去使用，但这样会导致最后项目编译打包后的资源包比较大。 pdfjs-dist这一node库这好可以解决我们的问题。pdfjs-dist是pdf.js源代码的预构建版本，我们直接在项目中引入该库即可使用，接下来我们介绍如何使用。 需要预览的PDF一般是后台接口返回的base64编码数据或者是本地上传获取到文件，接下来我们在vue工程上实现本地上传PDF文件，获取文件的base64编码，利用pdf.js实现预览效果。 基于Vue工程实现PDF在线预览1、安装pdfjs-dist依赖1npm install pdfjs-dist 2、初始化PDF，核心代码123456789101112131415161718192021222324252627282930313233343536373839previewPDF() &#123; // 引入pdf.js的字体 let CMAP_URL = &apos;https://unpkg.com/pdfjs-dist@2.0.943/cmaps/&apos; //读取base64的pdf流文件 let loadingTask = pdfJS.getDocument(&#123; data: this.pdfData, // PDF base64编码 cMapUrl: CMAP_URL, cMapPacked: true &#125;) loadingTask.promise.then((pdf) =&gt; &#123; this.loadFinished = true let numPages = pdf.numPages let pageNumber = 1 this.getPage(pdf, pageNumber, numPages) &#125;)&#125;,getPage(pdf, pageNumber, numPages) &#123; let _this = this pdf.getPage(pageNumber) .then((page) =&gt; &#123; // 获取DOM中为预览PDF准备好的canvasDOM对象 let canvas = this.$refs.myCanvas let viewport = page.getViewport(_this.scale) canvas.height = viewport.height canvas.width = viewport.width let ctx = canvas.getContext(&apos;2d&apos;) let renderContext = &#123; canvasContext: ctx, viewport: viewport &#125; page.render(renderContext).then(() =&gt; &#123; pageNumber += 1 if (pageNumber &lt;= numPages) &#123; _this.getPage(pdf, pageNumber, numPages) &#125; &#125;) &#125;)&#125; 3、效果 4、注意点当PDF文件中有中文的情况下，在引用pdfjs过程中可能会出现中文不显示问题，在console中会报下面的错误，1Warning: The CMap &quot;baseUrl&quot; parameter must be specified, ensure that the &quot;cMapUrl&quot; and &quot;cMapPacked&quot; API parameters are provided. 主要原因是有pdf不支持的字体格式，可以通过引入pdf.js的字体来解决该问题。12345678// 引入pdf.js的字体let CMAP_URL = &apos;https://unpkg.com/pdfjs-dist@2.0.943/cmaps/&apos;//读取base64的pdf流文件let loadingTask = pdfJS.getDocument(&#123; data: this.pdfData, // PDF base64编码 cMapUrl: CMAP_URL, cMapPacked: true&#125;) 完整代码获取：https://github.com/Hanpeng-Chen/hampton-demo-repo/tree/master/example-project","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"}],"tags":[{"name":"pdf.js","slug":"pdf-js","permalink":"http://www.chenhanpeng.com/tags/pdf-js/"},{"name":"在线预览PDF文件","slug":"在线预览PDF文件","permalink":"http://www.chenhanpeng.com/tags/在线预览PDF文件/"}]},{"title":"利用TensorFlow Object Detection API实现图片和视频物体检测","slug":"machine_learning/利用TensorFlow_Object_Detection_API实现图片和视频物体检测","date":"2019-06-21T15:50:14.000Z","updated":"2021-01-12T07:04:17.408Z","comments":true,"path":"Tensorflow-Object-Detection-image-video/","link":"","permalink":"http://www.chenhanpeng.com/Tensorflow-Object-Detection-image-video/","excerpt":"","text":"TensorFlow Object Detection API介绍物体检测是检测图片或视频中所出现的全部物体，并用矩形进行标注，物体的类别可以包括多种，比如：人、车、动物等等，即正确的答案可以是多个。 TensorFlow提供了用于检测图片或视频中所包含物体的接口(Object Detection API)，具体详情可参考下面链接：https://github.com/tensorflow/models/tree/master/research/object_detection 这个API是用COCO数据集 (http://cocodataset.org/#home) 训练出来的，是一个大型的、丰富的物体检测，分割和字幕数据集,大约有30万张图像、90种最常见物体。 这个API提供了多种不同的，使用者可以通过设置不同检测边界范围来平衡运行速度和准确率。 图中的mAP（平均精度）是检测边界框的准确率和召回率的乘积。这是一个很好的混合测度，在评价模型对目标物体的敏锐度和它是否能很好避免虚假目标中非常好用。mAP值越高，模型的准确度越高，但运行速度会相应下降。 实现物体检测环境本文代码运行环境：Python3.6、jupyter notebook 首先安装相关依赖包1234567pip install jupyterpip install tensorflowpip install pillow pip install lxmlpip install matplotlibpip install numpypip install opencv-python 图片物体检测:1、加载库1234import numpy as npimport tensorflow as tfimport matplotlib.pyplot as pltfrom PIL import Image 2、从utils模块引入label_map_util和visualization_utilslabel_map_util用于后面获取图像标签和类别，visualization_utils用于可视化12from utils import label_map_utilfrom utils import visualization_utils as vis_util 3、加载预训练好的模型模型下载地址：https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md这里我们选用最轻量级的模型(ssd_mobilenet_v1_coco)。1234567891011PATH_TO_CKPT = &apos;ssd_mobilenet_v1_coco_2018_01_28/frozen_inference_graph.pb&apos;PATH_TO_LABELS = &apos;data/mscoco_label_map.pbtxt&apos;NUM_CLASSES = 90detection_graph = tf.Graph()with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(PATH_TO_CKPT, &apos;rb&apos;) as fid: od_graph_def.ParseFromString(fid.read()) tf.import_graph_def(od_graph_def, name=&apos;&apos;) 4、加载分类标签数据123label_map = label_map_util.load_labelmap(PATH_TO_LABELS)categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=True)category_index = label_map_util.create_category_index(categories) 5、核心代码：一个将图片转为数组的辅助函数，以及测试图片路径，使用模型进行物体检测：123456789101112131415161718192021222324def load_image_into_numpy_array(image): (im_width, im_height) = image.size return np.array(image.getdata()).reshape((im_height, im_width, 3)).astype(np.uint8)TEST_IMAGE_PATHS = [&apos;test_data/image1.jpg&apos;]with detection_graph.as_default(): with tf.Session(graph=detection_graph) as sess: image_tensor = detection_graph.get_tensor_by_name(&apos;image_tensor:0&apos;) detection_boxes = detection_graph.get_tensor_by_name(&apos;detection_boxes:0&apos;) detection_scores = detection_graph.get_tensor_by_name(&apos;detection_scores:0&apos;) detection_classes = detection_graph.get_tensor_by_name(&apos;detection_classes:0&apos;) num_detections = detection_graph.get_tensor_by_name(&apos;num_detections:0&apos;) for image_path in TEST_IMAGE_PATHS: image = Image.open(image_path) image_np = load_image_into_numpy_array(image) image_np_expanded = np.expand_dims(image_np, axis=0) (boxes, scores, classes, num) = sess.run( [detection_boxes, detection_scores, detection_classes, num_detections], feed_dict=&#123;image_tensor: image_np_expanded&#125;) vis_util.visualize_boxes_and_labels_on_image_array(image_np, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), category_index, use_normalized_coordinates=True, line_thickness=8) plt.figure(figsize=[12, 8]) plt.imshow(image_np) plt.show() 检测结果如下： 视频物体检测使用cv2读取视频并获取每一帧图片，然后将检测后的每一帧写入新的视频文件。 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import numpy as npimport tensorflow as tfimport cv2from utils import label_map_utilfrom utils import visualization_utils as vis_utilcap = cv2.VideoCapture(&apos;test_data/test_video.mp4&apos;)ret, image_np = cap.read()out = cv2.VideoWriter(&apos;output_video.mp4&apos;, -1, cap.get(cv2.CAP_PROP_FPS), (image_np.shape[1], image_np.shape[0]))PATH_TO_CKPT = &apos;ssd_mobilenet_v1_coco_2018_01_28/frozen_inference_graph.pb&apos;PATH_TO_LABELS = &apos;data/mscoco_label_map.pbtxt&apos;NUM_CLASSES = 90detection_graph = tf.Graph()with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(PATH_TO_CKPT, &apos;rb&apos;) as fid: od_graph_def.ParseFromString(fid.read()) tf.import_graph_def(od_graph_def, name=&apos;&apos;) label_map = label_map_util.load_labelmap(PATH_TO_LABELS)categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=True)category_index = label_map_util.create_category_index(categories)with detection_graph.as_default(): with tf.Session(graph=detection_graph) as sess: image_tensor = detection_graph.get_tensor_by_name(&apos;image_tensor:0&apos;) detection_boxes = detection_graph.get_tensor_by_name(&apos;detection_boxes:0&apos;) detection_scores = detection_graph.get_tensor_by_name(&apos;detection_scores:0&apos;) detection_classes = detection_graph.get_tensor_by_name(&apos;detection_classes:0&apos;) num_detections = detection_graph.get_tensor_by_name(&apos;num_detections:0&apos;) while cap.isOpened(): ret, image_np = cap.read() if len((np.array(image_np)).shape) == 0: break image_np = cv2.cvtColor(image_np, cv2.COLOR_BGR2RGB) image_np_expanded = np.expand_dims(image_np, axis=0) (boxes, scores, classes, num) = sess.run([detection_boxes, detection_scores, detection_classes, num_detections], feed_dict=&#123;image_tensor: image_np_expanded&#125;) vis_util.visualize_boxes_and_labels_on_image_array(image_np, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), category_index, use_normalized_coordinates=True, line_thickness=8) out.write(cv2.cvtColor(image_np, cv2.COLOR_RGB2BGR)) cap.release()out.release()cv2.destroyAllWindows() 检测效果 至此我们利用tensorflow提供的物体检测API，实现了图片和视频的物体检测。 完整的代码和检测后的视频，请至github查看：https://github.com/Hanpeng-Chen/tensorflow-learning","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.chenhanpeng.com/categories/机器学习/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://www.chenhanpeng.com/tags/TensorFlow/"},{"name":"物体检测","slug":"物体检测","permalink":"http://www.chenhanpeng.com/tags/物体检测/"}]},{"title":"TensorFlow基础概念","slug":"machine_learning/TensorFlow基础概念","date":"2019-06-11T15:25:14.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"Basic-concepts-of-TensorFlow/","link":"","permalink":"http://www.chenhanpeng.com/Basic-concepts-of-TensorFlow/","excerpt":"","text":"TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。 TensorFlow 是Google第二代大规模分布式深度学习框架。 灵活通用的深度学习库 端云结合的人工智能引擎 高性能的基础平台软件 跨平台的机器学习系统 应用场景： 行人检测、人脸检测、行为识别、身份证自动输入与人脸图像比较、OCR+自动化审核 TensorFlow 数据流图介绍TensorFlow数据流图是一种声明式编程范式 声明式编程与命令式编程的多角度对比 数据流图由有向边和节点组成 数据流图的优势：快 并行计算快 分布式计算快(CPUs,GPUs,TPUs) 预编译优化(XLA) 可移植性好(Language-independent representation) 张量(Tensor)在数学里，张量是一种几何实体，广义上表示任意形式的“数据”。张量可以理解为0阶（rank）标量、1阶向量和2阶矩阵在高维度空间上的推广，张量的阶描述它表示数据的最大维度。 在TensorFlow中，张量表示某种相同的数据类型的多维数组因此，张量有两个重要的属性： 1、数据类型，如浮点型、整型、字符串 2、数组形状： 各个维度的大小 TensorFlow张量是什么可以总结为一下几点： 张量是用来表示多维数据的 张量是执行操作时的输入或输出数据 用户通过执行操作来创建或计算张量 张量的形状不一定在编译时确定，可以在运行时通过形状推断计算得到 几类比较特别的张量，由以下操作产生：123tf.constant // 常量tf.placeholder // 占位符tf.Variable // 变量 变量(Variable)变量Variable是一种特殊的张量，主要作用是维护特定节点的状态，如深度学习或机器学习的模型参数。 tf.Variable方法是操作，返回值是变量（特殊张量） 通过tf.Variable方法创建的变量，与张量一样，可以作为操作的输入和输出。 不同之处： 张量的生命周期通常随依赖的计算完成而结束，内存也随即释放 变量则常驻内存，在每一步训练时不断更新值，以实现模型参数的更新。 TensorFlow变量使用流程 操作(Operation)TensorFlow用数据流图表示算法模型。数据流图由节点和有向边组成，每个节点均对应一个具体的操作。因此，操作是模型功能的实际载体。 数据流图中的节点按照功能不同可以分为3种： 存储节点：有状态的变量操作，通常用来存储模型参数 计算节点：无状态的计算或控制操作，主要负责算法逻辑表达或流程控制。 数据节点：数据的占位符操作，用于描述图外输入数据的属性。 操作的输入和输出是张量或操作（函数式编程） TensorFlow典型计算和控制操作 TensorFlow占位符操作tensorflow 使用占位符操作表示图外输入的数据，如训练数据和测试数据。 TensorFlow数据流图描述了算法模型的计算拓扑，其中的各个操作(节点)都是抽象的函数映射或数学表达式。 换句话说，数据流图本身是一个具有计算拓扑和内部结构的“壳”。在用户向数据流图填充数据前，图中并没有真正执行任何计算。 会话(Session)会话提供了估算张量和执行操作的运行环境，它是发放计算任务的客户端，所有计算任务都由它连接的执行引擎完成。一个会话的典型使用流程分为以下3步：1234567# 1、创建会话# target:会话连接的执行引擎 graph:会话加载的数据流图 config:会话启动时的配置项sess = tf.Session(target=..., graph=..., config=...)# 2、估算张量或执行操作sess.run(...)# 3、关闭会话sess.close() 会话执行获取张量值的另外两种方法：估算张量(Tensor.eval)与执行操作(Operation.run) 12345678910import tensorflow as tf# 创建数据流图：y=w * x + b, 其中w和b为存储节点，x为数据节点x = tf.placeholder(tf.float32)w = tf.Variable(1.0)b = tf.Variable(1.0)y = w * x + bwith tf.Session() as sess: tf.global_variables_initializer().run() # Operation.run fetch = y.eval(feed_dict=&#123;x: 3.0&#125;) # Tensor.eval print(fetch) # fetch = 1.0 * 3.0 + 1.0 会话执行原理当我们调用sess.run(train_op)语句执行训练操作时： 首先，程序内部提取操作依赖的所有前置操作。这些操作的节点共同组成一幅子图。 然后，程序会将子图中的计算节点、存储节点和数据节点按照各自的执行设备分类，相同设备上的节点组成了一幅局部图 最后，每个设备上的局部图在实际执行时，根据节点间的依赖关系将各个节点有序地加载到设备上执行。 优化器(Optimizer)优化器是实现优化算法的载体。 一次典型的迭代优化应该分为以下3个步骤： 1、计算梯度：调用compute_gradients方法; 2、处理梯度：用户按照自己需求处理梯度值，如梯度裁剪和梯度加权等。 3、应用梯度：调用apply_gradients方法，将处理后的梯度值应用到模型参数。 TensorFlow内置优化器：","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.chenhanpeng.com/categories/机器学习/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://www.chenhanpeng.com/tags/TensorFlow/"}]},{"title":"CF-基于协同过滤的推荐算法","slug":"big_data/CF-基于协同过滤的推荐算法","date":"2019-05-13T15:05:11.000Z","updated":"2020-08-10T02:19:13.721Z","comments":true,"path":"CF-Recommendation-algorithm/","link":"","permalink":"http://www.chenhanpeng.com/CF-Recommendation-algorithm/","excerpt":"","text":"概述上一篇文章我们介绍了CB推荐算法，本篇文章我们将介绍另外一种推荐算法——基于协同过滤的推荐算法(Collaborative Filtering Recommendations)，下文我们统一简称为CF算法。 协同过滤推荐算法作为推荐算法中最经典的类型，包括在线的协同和离线的过滤两部分。在线协同是指通过在线数据找到用户可能喜欢的物品，离线过滤则是过滤掉一些不值得推荐的数据，比如推荐评分低的，或者推荐评分高但用户已经购买过的数据。 CF算法的数据源是基于用户历史行为和物品的矩阵数据，即UI（User-Item）矩阵数据。CF算法一般可以分为基于用户（User-Based）的协同过滤和基于物品（item-based）的协同过滤。 算法原理1、 User-Based CF假设： 用户喜欢跟他过去喜欢的物品相似的物品 历史上相似的物品在未来也相似 方法： 给定用户u，找到他过去喜欢的物品的集合R(u) 把和R(u)相似的物品推荐给u 2、 Item-Based CF假设： 用户喜欢跟他过去喜欢的物品相似的物品 历史上相似的物品在未来也相似 方法： 给定用户u，找到他过去喜欢的物品的集合R(u) 把和R(u)相似的物品推荐给u CF算法优缺点优点： 充分利用群体智慧 推荐精度高于CB 利于挖掘隐含的相关性 缺点： 推荐结果解释性较差 对时效性强的Item不适用 冷启动问题 算法处理过程1、数据准备用户user_id,物品item_id，打分score（score可以是用户对某件物品的评分，或是根据用户行为计算出的偏好度得分，比如曝光、点击、收藏的加权得分，具体权重可以参考漏斗模型），数据如下： user_id item_id score id1 item1 3 id1 item2 2 id2 item1 4 id2 item2 3 2、计算相似性矩阵CF算法的关键在于计算获得user或item的相似度矩阵，即UU矩阵和II矩阵。 User-Based： 用户之间的相似度计算，是基于对相同的物品打过分，可以将各个分值联合起来作为一个向量，然后计算余弦相似度： Item-Based： 计算各个Item之间的相似度矩阵，即对两个Item都打过分的id的打分情况作为向量，同理得到item的相似度矩阵。 3、推荐根据相似度矩阵，选择与目标用户相似度最高的几位用户，在第一张表中选取各自打分较高的物品，形成一个推荐候选集合，准备推荐给目标用户。 User-Based CF和Item-Based CF区别通过两种方法，我们发现两种的分数不一样，那么该用哪个呢，哪个真实，其实这个不重要，生活中我们一般是基于用户给用户推荐Top问题，而不是打分情况，即只要排好序就可以，工作这个分数其实还是有用的，一般我们有这么个准则，哪个维度小用哪个，电商网站物品的矩阵远大于用户矩阵，规模太大有时候造成一些慢，相反一样 那么我们来看一下这两个对比不同 User-Based Item-Based 性能 适用用户较少场合，如果用户多，计算用户相似矩阵代价太大 适用于物品数明显小于用户数的场合，如果物品很多，计算物品相似度矩阵代价很大 领域 时效性强，用户个性化兴趣不太明显的领域 长尾物品丰富，用户个性化需求强烈的领域 实时性 用户有新行为，不一定造成推荐结果立即变化 用户有新行为，一定会导致推荐结果的实时变化 冷启动 在新用户对很少的物品产生行为后，不能立即对他进行个性化推荐，因为用户相似度表是每隔一段时间离线计算的 新物品上线后一段时间，一旦有用户对物品产生行为，就可以将新物品推荐给对它产生行为的用户兴趣相似的其他用户 新用户只要对一个物品产生行为，就可以给他推荐和该物品相关的其他物品 但没有办法在不离线更新物品相似度表的情况下将新物品推荐给用户 推荐理由 很难提供令用户信服的推荐解释 利用用户的历史行为给用户做推荐解释，可以令用户比较信服","categories":[{"name":"大数据","slug":"大数据","permalink":"http://www.chenhanpeng.com/categories/大数据/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"http://www.chenhanpeng.com/tags/推荐算法/"},{"name":"大数据","slug":"大数据","permalink":"http://www.chenhanpeng.com/tags/大数据/"}]},{"title":"CB-基于内容的推荐算法","slug":"big_data/CB-基于内容的推荐算法","date":"2019-05-07T15:57:25.000Z","updated":"2020-08-10T02:19:13.721Z","comments":true,"path":"CB-Recommendation-algorithm/","link":"","permalink":"http://www.chenhanpeng.com/CB-Recommendation-algorithm/","excerpt":"","text":"在推荐系统领域，一般主要有两种推荐任务：评分预测和Top-N推荐。下面我们简单介绍一下这两种推荐任务： 评分预测：我们以音乐推荐系统为例，首先用户A和用户B都对某几首歌进行喜欢程度打分，假设两个用户对周杰伦的《稻香》和陈奕迅的《好久不见》有相同的喜欢程度，且打分都不低，那么我们是否可以预测这两个用户有相同的爱好，那么我们可以将用户A喜欢的《青花瓷》这首歌推荐给用户B。 Top-N推荐假设用户A喜欢的音乐列表里有《十年》、《好久不见》、《稻香》，用户B喜欢的音乐列表里有《同桌的你》、《三国杀》、《逆战》，假设用户C刚开始使用该系统，并将《稻香》添加到喜欢的音乐中，那么我们是不是可以先推荐与用户C喜好相近的用户A喜欢的音乐给用户C，再推荐用户B喜欢的音乐。先推荐关联性高的，将关联性低的放在后面，这就是Top-N推荐。 基于内容的推荐算法(CB)今天要介绍的CB(Content-Based Recommendations)算法是众多推荐推荐算法中的一种，也是比较早被使用的一种推荐算法。 1、引入Item属性的基于内容的推荐用户喜欢歌曲A(item)，现在有一首新歌曲B，如何确定是否要推荐给用户？ 首先我们对所有的音乐进行内容分析和item内容属性索引，即进行特征建立和建模，音乐的特征有：作者、年代、音乐风格等等。 然后我们去计算歌曲A和歌曲B两者的相关性，如何相关性高，则将歌曲B推荐给用户。 这类推荐算法有以下优缺点： 优点： 提升推荐结果的相关性 结果可解释 推荐结果容易被用户感知 缺点： 无个性化 依赖于对item的深度分析 2、引入User属性的基于内容的推荐引入User属性的基于内容推荐算法加入了用户行为分析和建立用户兴趣模型。假设用户在过去的一段时间里听了爵士乐、DJ、周杰伦的歌，我们可以根据这几个历史标签进行数据建模，建立历史标签的正排倒排的内容分析。与上面不同的是这方面是基于用户的历史行为作分析，我们将其存到数据库，以后为用户推荐音乐时，先查库，然后进行相关的推荐。 这类推荐算法有以下优缺点： 优点： 用户模型刻画了用户兴趣需求 推荐形式多样，具有个性化 结果可解释 缺点： 推荐精度低 马太效应 用户行为稀疏导致覆盖率低","categories":[{"name":"大数据","slug":"大数据","permalink":"http://www.chenhanpeng.com/categories/大数据/"}],"tags":[{"name":"推荐算法","slug":"推荐算法","permalink":"http://www.chenhanpeng.com/tags/推荐算法/"},{"name":"大数据","slug":"大数据","permalink":"http://www.chenhanpeng.com/tags/大数据/"}]},{"title":"Vue-CLI3 环境变量和模式","slug":"vue_series/vue-cli3-环境变量和模式","date":"2019-04-29T14:46:30.000Z","updated":"2021-04-21T01:17:31.961Z","comments":true,"path":"Vue-Cli3-mode-and-env/","link":"","permalink":"http://www.chenhanpeng.com/Vue-Cli3-mode-and-env/","excerpt":"","text":"前段时间工作中用Vue-CLI3构建的Vue工程一些静态资源，比如静态H5页面、图片、图标等等，我们一般放在固定的一些服务器上，链接前缀一般相对固定，但我们打包发布一般要区分测试环境和生产环境，此时的静态资源路径也需要区分测试和生产，如果每次打包都要根据部署的环境去修改路径十分麻烦，这时候vue-cli的模式和环境变量则能够很好地解决这个麻烦。 模式模式是Vue CLI项目中一个重要的概念。默认情况下，一个Vue CLI项目有三个模式： development 模式用于vue-cli-service serve production 模式用于vue-cli-service build和vue-cli-service test:e2e test 模式用于vue-cli-service test:unit 模式不同于NODE_ENV，一个模式可以包含多个环境变量。每个模式都会将NODE_ENV的值设置为模式的名称，比如：development模式下NODE_ENV的值会被设置为development 当然，我们也可以通过为.env文件增加后缀来设置某个模式下特有的环境变量。 示例：test模式我们在项目根目录下创建一个名为.env.test和.env的文件 12// .env文件：VUE_APP_TITLE=VUE-CLI3-DEMO 123// .env.test文件NODE_ENV=productionVUE_APP_TITLE=VUE-CLI3-DEMO(test) vue-cli-service build 会加载可能存在的 .env、.env.production 和 .env.production.local 文件然后构建出生产环境应用； vue-cli-service build –mode test 会在 staging 模式下加载可能存在的 .env、.env.test 和 .env.test.local 文件然后构建出生产环境应用。 这两种情况下，根据 NODE_ENV，构建出的应用都是生产环境应用，但是在 test 版本中，process.env.VUE_APP_TITLE 被覆写成了另一个值。 我们在vue.config.js文件中添加console.log(process.env.VUE_APP_TITLE) 在package.json文件中添加”build-test”: “vue-cli-service build –mode test” 执行npm run build和npm run build-test 通过查看控制台打印出的分别是VUE-CLI3-DEMO和VUE-CLI3-DEMO(test)，由此可见不同模式下的环境变量不同。 环境变量只有以VUE_APP_开头的变量才会被webpack.DefinePlugin静态嵌入到客户端侧的包中，我们可以在代码中以下面的方式访问：process.env.VUE_APP_TITLE 除了VUE_APP_*变量外，还有两个始终可用的特殊变量： NODE_ENV 值为development、productin、test中的一个。 BASE_URL 与vue.config.js中的publicPath相符，即应用部署的基础路径 回到我们最开始的关于静态资源在不同环境下的路径问题，我们可以分别创建.env.test和.env.production两个文件，在文件中添加变量VUE_APP_STATIC_BASE_URL，根据不同环境赋予不同的值，在代码中用到静态资源的时候通过process.env.VUE_APP_STATIC_BASE_URL + 静态资源后续具体路径，再package.json中添加相应的模式打包命令，这样就可以比较好解决我们最开始提出的问题了。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.chenhanpeng.com/categories/前端/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://www.chenhanpeng.com/categories/前端/Vue/"}],"tags":[{"name":"Vue-CLI3","slug":"Vue-CLI3","permalink":"http://www.chenhanpeng.com/tags/Vue-CLI3/"},{"name":"模式","slug":"模式","permalink":"http://www.chenhanpeng.com/tags/模式/"},{"name":"环境变量","slug":"环境变量","permalink":"http://www.chenhanpeng.com/tags/环境变量/"}]},{"title":"中文分词Python库介绍","slug":"machine_learning/中文分词Python库介绍","date":"2019-04-21T09:05:40.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"python-packages-for-Chinese-word-segmentation/","link":"","permalink":"http://www.chenhanpeng.com/python-packages-for-Chinese-word-segmentation/","excerpt":"","text":"在前面的文章《中文分词》一文中，我们简单介绍了中文分词及其常用的分词方法，本文将介绍几个比较有代表性的支持中文分词的python库。本文所有实例均基于python3.6环境运行。 jieba结巴分词：使用较为广泛的一款python分词工具，专用于分词的python库，分词效果较好。 GitHub： https://github.com/fxsjy/jieba 特点： 支持三种分词模式：1、精确模式：试图将句子最精确地切开，适合文本分析2、全模式：把句子中所有的可以成词的词语都扫描出来，速度非常快，但是不能解决歧义3、搜索引擎模式：在精确模式下，对长词再次切分，提高召回率，适合用于搜索引擎分词 支持繁体分词 支持自定义词典 算法： 基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG) 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合 对于未登录词，采用了基于汉字成词能力的 HMM 模型，使用了 Viterbi 算法 用法实例：下面我们通过简单的代码来看一下精确模式、全模式、搜索引擎模式三种分词模式的分词效果。代码如下：1234567891011121314# -*- coding: utf-8 -*-import jiebastring = &apos;话说天下大势，分久必合，合久必分。周末七国分争，并入于秦。及秦灭之后，楚、汉分争，又并入于汉。汉朝自高祖斩白蛇而起义，一统天下，后来光武中兴，传至献帝，遂分为三国。推其致乱之由，殆始于桓、灵二帝。桓帝禁锢善类，崇信宦官。及桓帝崩，灵帝即位，大将军窦武、太傅陈蕃共相辅佐。时有宦官曹节等弄权，窦武、陈蕃谋诛之，机事不密，反为所害，中涓自此愈横。&apos;# 精确模式default_result = jieba.cut(string)print(&apos;精确模式：&apos; + &apos;/&apos;.join(default_result))# 全模式full_result = jieba.cut(string, cut_all=True)print(&apos;全模式：&apos; + &apos;/&apos;.join(full_result))# 搜索引擎模式search_result = jieba.cut_for_search(string)print(&apos;搜索引擎模式：&apos; + &apos;/&apos;.join(search_result)) 结果：12345精确模式：话/说/天下/大势/，/分久必合/，/合久必分/。/周末/七/国/分争/，/并入/于/秦/。/及/秦灭/之后/，/楚/、/汉/分争/，/又/并入/于汉/。/汉朝/自/高祖/斩/白蛇/而/起义/，/一统天下/，/后来/光武/中兴/，/传至/献帝/，/遂/分为/三国/。/推其致/乱/之/由/，/殆/始于/桓/、/灵/二帝/。/桓帝/禁锢/善类/，/崇信/宦官/。/及桓帝/崩/，/灵帝/即位/，/大将军/窦武/、/太傅陈/蕃/共/相/辅佐/。/时有/宦官/曹节/等/弄权/，/窦武/、/陈蕃/谋/诛/之/，/机事不密/，/反为/所害/，/中/涓/自此/愈横/。全模式：话/说/天下/大势///分久必合///合久必分///周末/七国/国分/分争///并入/于/秦///及/秦/灭/之后///楚///汉/分争///又/并入/于/汉///汉朝/自/高祖/斩/白蛇/而/起义///一统/一统天下/天下///后来/光/武/中兴///传/至/献帝///遂/分为/三国///推/其/致/乱/之/由///殆/始于/桓///灵/二帝///桓/帝/禁锢/善类///崇信/宦官///及/桓/帝/崩///灵/帝/即位///大将/大将军/将军/窦/武///太傅/太傅陈/蕃/共相/相辅/辅佐///时/有/宦官/曹/节/等/弄权///窦/武///陈/蕃/谋/诛/之///机事不密///反为/所/害///中/涓/自此/愈/横//搜索引擎模式：话/说/天下/大势/，/分久必合/，/合久必分/。/周末/七/国/分争/，/并入/于/秦/。/及/秦灭/之后/，/楚/、/汉/分争/，/又/并入/于汉/。/汉朝/自/高祖/斩/白蛇/而/起义/，/一统/天下/一统天下/，/后来/光武/中兴/，/传至/献帝/，/遂/分为/三国/。/推其致/乱/之/由/，/殆/始于/桓/、/灵/二帝/。/桓帝/禁锢/善类/，/崇信/宦官/。/及桓帝/崩/，/灵帝/即位/，/大将/将军/大将军/窦武/、/太傅/太傅陈/蕃/共/相/辅佐/。/时有/宦官/曹节/等/弄权/，/窦武/、/陈蕃/谋/诛/之/，/机事不密/，/反为/所害/，/中/涓/自此/愈横/。 从上面的结果来看，分词效果还不错。 jieba还提供了下面几个功能，具体实现代码可以自行到github上查看，这里不再详细介绍。 添加自定义词典：开发者还可以指定自己自定义的词典，以便包含jieba词库中没有的词。 关键词提取： 基于TF-IDF算法的关键词抽取(jieba.analyse) 基于TextRank算法的关键词抽取(jieba.analyse.textrank) THULACTHULAC（THU Lexical Analyzer for Chinese）由清华大学自然语言处理与社会人文计算实验室研制推出的一套中文词法分析工具包，具有中文分词和词性标注功能。 GitHub：https://github.com/thunlp/THULAC-Python 特点THULAC具有如下几个特点： 能力强。利用我们集成的目前世界上规模最大的人工分词和词性标注中文语料库（约含5800万字）训练而成，模型标注能力强大。 准确率高。该工具包在标准数据集Chinese Treebank（CTB5）上分词的F1值可达97.3％，词性标注的F1值可达到92.9％，与该数据集上最好方法效果相当。 速度较快。同时进行分词和词性标注速度为300KB/s，每秒可处理约15万字。只进行分词速度可达到1.3MB/s。 用法实例下面我们开看下THULAC的分词效果，代码如下：123456789101112# -*- coding: utf-8 -*-import thulac# 默认模式，有词性标注thu1 = thulac.thulac()thu1_result = thu1.cut(string, text=True)print(&apos;thu1_result：&apos; + thu1_result)# 只分词，不进行词性标注thu2 = thulac.thulac(seg_only=True)thu2_result = thu2.cut(string, text=True)print(&apos;thu2_result：&apos; + thu2_result) 分词结果：123thu1_result：话_n 说_v 天下_n 大势_n ，_w 分久必合_id ，_w 合久必分_id 。_w 周末_t 七国分争_id ，_w 并入_v 于_p 秦_g 。_w 及_c 秦灭_v 之后_f ，_w 楚_j 、_w 汉_g 分争_v ，_w 又_c 并入_v 于_p 汉_g 。_w 汉朝_t 自_r 高_a 祖斩_n 白蛇_n 而_c 起义_v ，_w 一统天下_id ，_w 后_f 来_v 光武_ns 中兴_nz ，_w 传_v 至_d 献_v 帝_g ，_w 遂_d 分为_v 三_m 国_n 。_w 推_v 其_r 致乱_v 之_u 由_g ，_w 殆始_v 于_p 桓_g 、_w 灵二帝_id 。_w 桓帝_np 禁锢_v 善类_n ，_w 崇信_v 宦官_n 。_w 及_c 桓帝崩_n ，_w 灵帝_n 即位_n ，_w 大将军_n 窦武_v 、_w 太傅_n 陈蕃_np 共_d 相_d 辅佐_v 。_w 时_g 有_v 宦官_n 曹节_np 等_u 弄权_n ，_w 窦武_np 、_w 陈蕃_np 谋诛_v 之_u ，_w 机事不密_i ，_w 反_d 为_v 所_u 害_v ，_w 中_j 涓_j 自此_d 愈_d 横_a 。_wthu2_result：话 说 天下 大势 ， 分久必合 ， 合久必分 。 周末 七国分争 ， 并入 于 秦 。 及 秦灭 之后 ， 楚 、 汉分 争 ， 又 并入 于汉 。 汉朝 自 高祖斩白蛇而起义 ， 一统天下 ， 后 来 光武 中兴 ， 传 至 献帝 ， 遂 分为 三 国 。 推 其 致乱 之 由 ， 殆始 于 桓 、 灵二帝 。 桓帝 禁锢善类 ， 崇信 宦官 。 及 桓帝崩 ， 灵帝 即位 ， 大将 军窦武 、 太 傅陈蕃 共 相辅佐 。 时 有 宦官 曹节 等 弄权 ， 窦武 、 陈蕃 谋诛之 ， 机事不密 ， 反 为 所 害 ， 中涓 自此 愈横 。 PKUSegPKUSeg是由北京大学语言计算与机器学习研究组研制推出的一套全新的中文分词工具包。它简单易用，支持多领域分词，在不同领域的数据上都大幅提高了分词的准确率。 GitHub: https://github.com/lancopku/pkuseg-python 特点pkuseg有如下几个特点： 多领域分词 更高的分词准确率 支持用户自训练模型 支持词性标注 用法实例分词代码：12345import pkuseg# 使用默认配置进行分词seg = pkuseg.pkuseg()text = seg.cut(string)print(text) 分词结果：1[&apos;话说&apos;, &apos;天下&apos;, &apos;大势&apos;, &apos;，&apos;, &apos;分久必合&apos;, &apos;，&apos;, &apos;合久必分&apos;, &apos;。&apos;, &apos;周末&apos;, &apos;七&apos;, &apos;国&apos;, &apos;分争&apos;, &apos;，&apos;, &apos;并入&apos;, &apos;于&apos;, &apos;秦&apos;, &apos;。&apos;, &apos;及&apos;, &apos;秦灭&apos;, &apos;之后&apos;, &apos;，&apos;, &apos;楚&apos;, &apos;、&apos;, &apos;汉分&apos;, &apos;争&apos;, &apos;，&apos;, &apos;又&apos;, &apos;并入&apos;, &apos;于汉&apos;, &apos;。&apos;, &apos;汉朝&apos;, &apos;自&apos;, &apos;高&apos;, &apos;祖斩&apos;, &apos;白蛇而起义&apos;, &apos;，&apos;, &apos;一统天下&apos;, &apos;，&apos;, &apos;后来&apos;, &apos;光武&apos;, &apos;中兴&apos;, &apos;，&apos;, &apos;传至&apos;, &apos;献帝&apos;, &apos;，&apos;, &apos;遂&apos;, &apos;分为&apos;, &apos;三国&apos;, &apos;。&apos;, &apos;推&apos;, &apos;其&apos;, &apos;致乱&apos;, &apos;之&apos;, &apos;由&apos;, &apos;，&apos;, &apos;殆始于桓&apos;, &apos;、&apos;, &apos;灵二帝&apos;, &apos;。&apos;, &apos;桓帝&apos;, &apos;禁锢&apos;, &apos;善类&apos;, &apos;，&apos;, &apos;崇信&apos;, &apos;宦官&apos;, &apos;。&apos;, &apos;及&apos;, &apos;桓帝崩&apos;, &apos;，&apos;, &apos;灵帝&apos;, &apos;即位&apos;, &apos;，&apos;, &apos;大将军&apos;, &apos;窦武&apos;, &apos;、&apos;, &apos;太傅&apos;, &apos;陈&apos;, &apos;蕃共&apos;, &apos;相&apos;, &apos;辅佐&apos;, &apos;。&apos;, &apos;时有&apos;, &apos;宦官&apos;, &apos;曹节&apos;, &apos;等&apos;, &apos;弄权&apos;, &apos;，&apos;, &apos;窦武&apos;, &apos;、&apos;, &apos;陈&apos;, &apos;蕃谋&apos;, &apos;诛之&apos;, &apos;，&apos;, &apos;机事不密&apos;, &apos;，&apos;, &apos;反为所害&apos;, &apos;，&apos;, &apos;中&apos;, &apos;涓&apos;, &apos;自此&apos;, &apos;愈&apos;, &apos;横&apos;, &apos;。&apos;] 三个库比较pkuseg在开源时对其进行测评，pkuseg的作者们选择 THULAC、结巴分词等国内代表分词工具包与 pkuseg 做性能比较。他们选择 Linux 作为测试环境，在新闻数据（MSRA）和混合型文本（CTB8）数据上对不同工具包进行了准确率测试。此外，测试使用的是第二届国际汉语分词评测比赛提供的分词评价脚本。评测结果如下： 我们可以看到，最广泛使用的结巴分词准确率最低，清华的THULAC分词准确率也低于PKUSeg。当然，pkuseg 是在这些数据集上训练的，因此它在这些任务上的准确率也会更高一些，也由此在其开源后对于其高准确率曾引起一些质疑和争议，有兴趣的朋友可以自行百度或点击下面链接查看：https://github.com/lancopku/pkuseg-python/issues/9 更多python中文分词库上面都只是简单介绍了jieba、THULAC和pkuseg三个分词python库，更多用法和参数请到相应的github上查阅。 还有一些中文分词的python库，这里只提供其github地址，就不一一介绍，有兴趣的朋友自行查看研究。 SnowNLP https://github.com/isnowfy/snownlp NLPIR https://github.com/NLPIR-team/NLPIR FoolNLTK https://github.com/rockyzhengwu/FoolNLTK LTP https://github.com/HIT-SCIR/pyltp","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.chenhanpeng.com/categories/机器学习/"}],"tags":[{"name":"中文分词","slug":"中文分词","permalink":"http://www.chenhanpeng.com/tags/中文分词/"}]},{"title":"推荐系统介绍","slug":"big_data/推荐系统介绍","date":"2019-04-15T16:29:20.000Z","updated":"2020-08-10T02:19:13.721Z","comments":true,"path":"recommendation-system-introduce/","link":"","permalink":"http://www.chenhanpeng.com/recommendation-system-introduce/","excerpt":"","text":"一、背景随着互联网的快速发展，我们进入一个信息爆炸的时代。互联网的发展，为我们提供了越来越多的服务平台，比如购物平台、视频播放网站、音乐播放器、社交网婚恋网等等，提供的物品种类也越来越多样。如何更好地满足客户的需求，成了企业的难题。 在这个信息爆炸的时代，无论是消费者还是信息生产者都遇到了很大的挑战：作为消费者，如何从大量信息中找到自己感兴趣的信息是一件非常困难的事情；作为信息生产者，如何让自己生产的信息脱颖而出，受到广大用户的关注，也是一件非常困难的事情。推荐系统就是解决这一矛盾的重要工具。 二、什么是推荐系统推荐系统是一项工程技术解决方案，通过利用机器学习等技术，在用户使用产品进行浏览交互的过程中，系统主动用户展示可能会喜欢的物品，从而促进物品的消费，节省用户时间，提升用户体验，做到资源的优化配置。 要将推荐系统落地到业务上需要大量的工程开发：涉及到日志打点、日志收集、ETL、分布式计算、特征工程、推荐算法建模、数据存储、提供接口服务、UI展示和交互、推荐效果评估等。 推荐系统的本质是在用户需求不明确的情况下，从海量的信息中为用户寻找其感兴趣的信息的技术手段。 推荐系统的任务就是联系用户和信息(物品)，一方面帮助用户发现对自己有价值的信息，另一方面让信息能够展现在对它感兴趣的用户面前，从而实现信息消费者和信息生产者的双赢。 推荐系统很好满足了用户、平台、内容提供商三方的需求。以淘宝为例：用户及在淘宝上购物的买家，平台即淘宝网站，网站上众多的店主就是内容提供方。通过推荐系统可以更好将商品曝光给要购买的用户，提升社会资源的配置效率。 三、推荐系统应用领域推荐系统应用场景正在不断被挖掘和创造，只要存在大量供用户消费的产品，就有推荐系统发挥价值的地方。 推荐系统主要应用的领域有如下几类： 电子商务：淘宝、京东、苏宁易购、亚马逊等 视频：腾讯视频、优酷、抖音等 音乐：网易云音乐、QQ音乐等 生活服务类：美团、携程 资讯类：头条、一点资讯等 社交类：陌陌、珍爱网等 四、常用推荐算法接下来我们简单介绍一些推荐系统常用的算法： 1、基于内容的推荐前面我们提到过推荐系统通过技术将用户和物品关联起来，物品本身包含很多属性，用户通过与物品的交互产生行为日志，这些日志可以作为衡量用户对物品偏好的标签，通过这些标签为用户做推荐，这就是基于内容的推荐算法。以音乐播放器推荐歌曲为例，歌曲有歌名、演唱者、类型、年代等标签信息，假设某个用户经常听张杰的歌，或者用户收藏的歌单中大部分都是张杰的歌曲，那么我们可以根据这些兴趣特征为用户推荐张杰的歌。 2、基于协同过滤的推荐用户与物品的交互留下了用户的标记，我们可以通过“物以类聚，人以群分”的思想为用户提供个性化推荐。 “物以类聚”具体来说就是：如果有许多用户对两个物品有相似的偏好，说明这两个物品是“相似”的，通过推荐与用户喜欢过的物品相似的物品的方法为用户提供个性化推荐，这就是基于物品的协同过滤推荐算法。 “人以群分”简单来说就是：找到与用户兴趣相同的人，将这些兴趣相同的用户浏览过的物品推荐给用户，这就是基于用户的协同过滤推荐算法。 五、推荐系统的价值接下来我们简单介绍一下推荐系统的价值： 从用户角度来说，推荐系统可以让用户快速从海量信息中找到自己感兴趣的物品，节省了用户时间，提升用户的使用体验。从平台角度来看：精准的推荐可以提升用户对平台的粘性，让用户喜欢上平台。平台整体营销收入提升，发现用户更多需求，满足其需求销售更多相关服务，获取更多利润。从内容提供商角度来看，提升物品被卖出去的概率，提升提供商的销量。 文章参考来源：https://mp.weixin.qq.com/s/DofYtvZCe-7RTicLqYtL4A","categories":[{"name":"大数据","slug":"大数据","permalink":"http://www.chenhanpeng.com/categories/大数据/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://www.chenhanpeng.com/tags/大数据/"},{"name":"推荐系统","slug":"推荐系统","permalink":"http://www.chenhanpeng.com/tags/推荐系统/"}]},{"title":"中文分词","slug":"machine_learning/中文分词","date":"2019-04-09T02:52:01.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"Chinese-word-segmentation/","link":"","permalink":"http://www.chenhanpeng.com/Chinese-word-segmentation/","excerpt":"","text":"中文分词(Chinese Word Segmentation)：是指将一个汉字序列切分为一个个单独的词。中文分词是中文自然语言处理的一个最基本的环节。中文分词与英文分词有很大的不同，对英文而言，一个单词就是一个词，而汉语是以字为基本的书写单位，词语之间没有明显的区分标记，需要人为切分。 根据中文分词的特点，可以把中文分词算法分为四大类： 基于规则的分词方法 基于统计的分词方法 基于语义的分词方法 基于理解的分词方法 基于规则的分词方法该分词方法又称为机械分词方法、基于字典的分词方法。它是按照一定的策略将待分析的汉字串与一个“充分大的”机器词典中的词条进行匹配。若在词典中找到某个字符串，则匹配成功。 该方法有三个要素：分词词典、文本扫描顺序和匹配原则。文本的扫描顺序有正向扫描、逆向扫描和双向扫描。匹配原则主要有最大匹配、最小匹配、逐词匹配和最佳匹配。 最大匹配法（MM）：基本思想是：假设自动分词词典中的最长词条所含汉字的个数为 i，则取被处理材料当前字符串序列中的前 i 个字符作为匹配字段，查找分词词典，若词典中有这样一个 i 字词，则匹配成功，匹配字段作为一个词被切分出来；若词典中找不到这样的一个 i 字词，则匹配失败，匹配字段去掉最后一个汉字，剩下的字符作为新的匹配字段，再进行匹配，如此进行下去，直到匹配成功为止。 逆向最大匹配法（RMM）：该方法的分词过程与 MM 法相同，不同的是从句子（或文章）末尾开始处理，每次匹配不成功时去掉的是前面的一个汉字。 逐词遍历法：把词典中的词按照由长到短递减的顺序逐字搜索整个待处理的材料，一直到把全部的词切分出来为止。不论分词词典多大，被处理的材料多么小，都得把这个分词词典匹配一遍。 设立切分标志法：切分标志有自然和非自然之分。自然切分标志是指文章中出现的非文字符号，如标点符号等；非自然标志是利用词缀和不构成词的词（包 括单音词、复音节词以及象声词等）。设立切分标志法首先收集众多的切分标志，分词时先找出切分标志，把句子切分为一些较短的字段，再用 MM、RMM 或其它的方法进行细加工。这种方法并非真正意义上的分词方法，只是自动分词的一种前处理方式而已，它要额外消耗时间扫描切分标志，增加存储空间存放那些非 自然切分标志。 最佳匹配法（OM）：此法分为正向的最佳匹配法和逆向的最佳匹配法，其出发点是：在词典中按词频的大小顺序排列词条，以求缩短对分词词典的检索时 间，达到最佳效果，从而降低分词的时间复杂度，加快分词速度。实质上，这种方法也不是一种纯粹意义上的分词方法，它只是一种对分词词典的组织方式。OM 法的分词词典每条词的前面必须有指明长度的数据项，所以其空间复杂度有所增加，对提高分词精度没有影响，分词处理的时间复杂度有所降低。 基于规则的分词方法的优点是简单，易于实现。但缺点有很多：匹配速度慢；存在交集型和组合型歧义切分问题；词本身没有一个标准的定义，没有统一标准的词集；不同词典产生的歧义也不同；缺乏自学习的智能性。 基于统计的分词方法基于统计的分词方法是在给定大量已经分词的文本情况下，利用统计机器学习模型学习词语切分的规律，从而实现对未知文本的切分。 该方法的主要思想：词是稳定的组合，在上下文中，相邻的字同时出现的次数越多，越有可能构成一个词。因此字与字相邻出现的概率能较好反映词的可信度。可以对训练文本中相邻出现的各个字的组合的频度进行统计，计算它们之间的互现信息。互现信息体现了汉字之间结合关系的紧密程度。当紧密程 度高于某一个阈值时，便可以认为此字组可能构成了一个词。该方法又称为无字典分词。 该方法应用的主要统计模型有：N元文法模型(N-gram)、隐马尔科夫模型(Hiden Markov Model, HMM)、最大熵模型(ME)、条件随机场模型(Conditional Random Fields, CRF)等。 在实际的应用中，这种分词方法都需要使用分词词典来进行字符串匹配分词，同时使用统计方法识别一些新词，即将字符串频率统计和字符串匹配结合起来，既发挥匹配分词切分速度快、效率高的特点，又利用了无词典分词结合上下文识别生词、自动消除歧义的优点。 基于语义的分词方法语义分词法引入了语义分析，对自然语言自身的语言信息进行更多的处理，如扩充转移网络法、知识分词语义分析法、邻接约束法、综合匹配法、后缀分词法、特征词库法、矩阵约束法、语法分析法等。 扩充转移网络法：该方法以有限状态机概念为基础。有限状态机只能识别正则语言，对有限状态机作的第一次扩充使其具有递归能力，形成递归转移网络 （RTN）。在RTN 中，弧线上的标志不仅可以是终极符（语言中的单词）或非终极符（词类），还可以调用另外的子网络名字分非终极符（如字或字串的成词条件）。这样，计算机在 运行某个子网络时，就可以调用另外的子网络，还可以递归调用。词法扩充转移网络的使用， 使分词处理和语言理解的句法处理阶段交互成为可能，并且有效地解决了汉语分词的歧义。 矩阵约束法：其基本思想是：先建立一个语法约束矩阵和一个语义约束矩阵， 其中元素分别表明具有某词性的词和具有另一词性的词相邻是否符合语法规则， 属于某语义类的词和属于另一词义类的词相邻是否符合逻辑，机器在切分时以之约束分词结果。 基于理解的分词方法基于理解的分词方法是通过让计算机模拟人对句子的理解，达到识别词的效果。其基本思想就是在分词的同时进行句法、语义分析，利用句法信息和语义信息来处理歧义现象。它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断，即它模拟了人对句子的理解过程。这种分词方法需要使用大量的语言知识和信息。目前基于理解的分词方法主要有专家系统分词法和神经网络分词法等。 专家系统分词法：从专家系统角度把分词的知识（包括常识性分词知识与消除歧义切分的启发性知识即歧义切分规则）从实现分词过程的推理机中独立出来，使知识库的维护与推理机的实现互不干扰，从而使知识库易于维护和管理。它还具有发现交集歧义字段和多义组合歧义字段的能力和一定的自学习功能。 神经网络分词法：该方法是模拟人脑并行，分布处理和建立数值计算模型工作的。它将分词知识所分散隐式的方法存入神经网络内部，通过自学习和训练修改内部权值，以达到正确的分词结果，最后给出神经网络自动分词结果，如使用 LSTM、GRU 等神经网络模型等。 神经网络专家系统集成式分词法：该方法首先启动神经网络进行分词，当神经网络对新出现的词不能给出准确切分时，激活专家系统进行分析判断，依据知识库进行推理，得出初步分析，并启动学习机制对神经网络进行训练。该方法可以较充分发挥神经网络与专家系统二者优势，进一步提高分词效率。 参考来源：https://cuiqingcai.com/5844.html","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.chenhanpeng.com/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.chenhanpeng.com/tags/机器学习/"},{"name":"中文分词","slug":"中文分词","permalink":"http://www.chenhanpeng.com/tags/中文分词/"}]},{"title":"文本挖掘预处理之TF-IDF","slug":"machine_learning/TF-IDF-1","date":"2019-03-25T14:10:10.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"TF-IDF-1/","link":"","permalink":"http://www.chenhanpeng.com/TF-IDF-1/","excerpt":"","text":"TF-IDF（Term Frequency-Inverse Document Frequency）即“词频-反文档频率”，主要由TF和IDF两部分组成。TF-IDF是一种用于资讯检索与资讯探勘的常用加权技术，是一种统计方法，用于评估一个词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要程度与它在文件中出现的次数成正比，但同时与它在语料库中出现的频率成反比。 TF——词频：一个词在文章中出现的次数。 在计算词频时，需要注意停用词的过滤。什么是停用词：在文章中出现次数最多的“的”、“是”、“在”等最常用词，但对结果毫无帮助，必须过滤的词。 TF计算有两种方式，具体公式如下： IDF——反文档频率：一个词在所有文章中出现的频率。如果包含这个词的文章越少，IDF越大，则说明词具有很好的类别区分能力。计算公式如下： 将TF和IDF相乘，就得到一个词的TF-IDF值，某个词对文章的重要性越高，该值越大，于是排在前面的几个词，就是这篇文章的关键词。 TF-IDF总结：优点：简单快速，结果比较符合实际情况。 缺点：单纯以“词频”做衡量标准，不够全面，有时重要的词可能出现的次数不多。 用python实现TF-IDF的计算将下图所示的已经分好词的文章作为语料库，计算101it.seg.cln.txt中的TF-IDF。 具体python代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# -*- coding: utf-8 -*-import osimport math # 要计算TF-IDF的文章路径file_path = './data/101it.seg.cln.txt'# 语料库目录路径data_dir_path = './data' # 获取文章内容def read_content(file): content = open(file, 'r', encoding='UTF-8') return content # 计算IDFdef calculate_idf(dir_path): all_word_set = set() article_list = [] article_count = 0 for fd in os.listdir(dir_path): article_count += 1 file = dir_path + '/' + fd content = read_content(file) content_set = set() for line in content: word_tmp = line.strip().split(' ') for word in word_tmp: word = word.strip() all_word_set.add(word) content_set.add(word) article_list.append(content_set) idf_dict = &#123;&#125; for word in all_word_set: count = 0 for article in article_list: if word in article: count += 1 idf_dict[word] = math.log(float(article_count)/(float(count) + 1.0)) return idf_dict # 计算TFdef calculate_tf(file): content = read_content(file) word_set = set() word_dict = &#123;&#125; word_count = 0 # 计算词频和文章总词数 for line in content: word_tmp = line.strip().split(' ') for word in word_tmp: word = word.strip() if word not in word_dict: word_dict[word] = 1 else: word_dict[word] += 1 word_count += 1 word_set.add(word) # 计算TF for tmp in word_set: word_dict[tmp] = float(word_dict[tmp])/float(word_count) return word_dict if __name__ == \"__main__\": idf_dict = calculate_idf(data_dir_path) tf_dict = calculate_tf(file_path) tfidf_dict = &#123;&#125; for key in tf_dict: tfidf_dict[key] = tf_dict[key] * idf_dict[key] print(tfidf_dict) TF-IDF应用：TF-IDF有下面几个应用，具体的实现后续文章再给大家介绍： 提取文章的关键词 TF-IDF结合余弦相似度找相似文章 给文章自动生成摘要","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.chenhanpeng.com/categories/机器学习/"}],"tags":[{"name":"TF-IDF","slug":"TF-IDF","permalink":"http://www.chenhanpeng.com/tags/TF-IDF/"}]},{"title":"K-近邻(KNN)算法","slug":"machine_learning/knn","date":"2019-03-21T09:04:17.000Z","updated":"2020-08-10T02:19:13.737Z","comments":true,"path":"knn/","link":"","permalink":"http://www.chenhanpeng.com/knn/","excerpt":"","text":"K-近邻（KNN，K-Nearest Neighbor）算法是一种基本分类与回归方法，在机器学习分类算法中占有相当大的地位，既是最简单的机器学习算法之一，也是基于实例的学习方法中最基本的，又是最好的文本分类算法之一。 我们本篇文章只讨论分类问题的KNN算法。 KNN算法概述KNN是通过测量不同特征值之间的距离进行分类。 KNN算法思路：如果一个样本在特征空间中的k各最相似（即特征空间中最近邻）的样本中的大多数属于某一个类别，则该样本也属于该类别。其中k一个是不大于20的整数。KNN算法中，所选择的邻居都是已经正确分类的对象。 KNN算法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。 KNN算法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的模型。k值的选择、距离度量和分类决策规则是KNN算法的三个基本要素。 KNN算法工作原理KNN算法工作原理可描述为：1、假设有一个带有标签的训练样本集，其中包含每条数据与所属分类的对应关系。 2、输入没有带标签的新数据后，计算新数据与训练样本集中每条数据的距离。 3、对求得的所有距离进行升序排序。 4、选取k个与新数据距离最小的训练数据。 5、确定k个训练数据所在类别出现的频率。 6、返回k个训练数据中出现频率最高的类别作为新数据的分类。 KNN算法距离计算方式在KNN中，通过计算对象间距离来作为各个对象之间的相似性指标，这里的距离计算一般采用欧式距离或者是曼哈顿距离，两种距离的计算公式如下图所示： KNN算法特点： 优点：精度高、对异常值不敏感、无数据输入假定 缺点：计算复杂度高、空间复杂度高 适用数据范围：数值型和标称型 KNN算法demo实例python（python3.6）实现一个KNN算法的简单demo 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import numpy as npfrom collections import Counterimport os # 创建样本数据集def createDataSet(): group = np.array([[1.0, 1.1], [1.0, 1.0], [0, 0.1], [0.1, 0]]) labels = ['A', 'A', 'B', 'B'] return group, labels # 近邻算法def classify0 (inX, dataSet, labels, k): diffMat = np.tile(inX,(dataSet.shape[0],1)) - dataSet #待分类的输入向量与每个训练数据做差 distance = ((diffMat ** 2).sum(axis=1)) ** 0.5 #欧氏距离 sortDistanceIndices = distance.argsort() #从小到大的顺序，返回对应索引值 votelabel = [] for i in range(k): votelabel.append(labels[sortDistanceIndices[i]]) Xlabel = Counter(votelabel).most_common(1) return Xlabel[0][0] if __name__ == \"__main__\": # # 创建数据集和 k-近邻算法 group, labels = createDataSet() # 新数据为[0, 0], k=3 label = classify0([0, 0], group, labels, 3) print(label) 执行上面代码，在控制台打印输出 B，即为数据[0, 0]的分类。 方法说明上面python代码中有几个方法在这里简单说明一下： Counter(votelabel).most_common(1)：求votelabel中出现次数最多的元素 np.tile(A,B)：若B为int型：在列方向上将A重复B次 若B为元组(m,n):将A在列方向上重复n次，在行方向上重复m次 sum(axis=1)：函数的axis参数，axis=0:按列相加；axis=1:按行的方向相加，即每行数据求和 argsort：将数组的值按从小到大排序后，输出索引值","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.chenhanpeng.com/categories/机器学习/"}],"tags":[{"name":"KNN","slug":"KNN","permalink":"http://www.chenhanpeng.com/tags/KNN/"},{"name":"机器学习","slug":"机器学习","permalink":"http://www.chenhanpeng.com/tags/机器学习/"},{"name":"分类算法","slug":"分类算法","permalink":"http://www.chenhanpeng.com/tags/分类算法/"}]}]}