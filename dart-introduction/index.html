<!DOCTYPE HTML>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="代码视界">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://www.chenhanpeng.com">
    <script data-ad-client="ca-pub-1437849089810081" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!--SEO-->

<meta name="keywords" content="Dart语法">


<meta name="description" content="Dart在静态语法方面和Java非常相似，如类型定义、函数声明、泛型等，而在动态特性方面又和JavaScript很想，如函数式特性、异步支持等。除了融合Java和JavaScript语言的长处外...">


<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->

<title>
    
    Flutter | 2-Dart语言简介 |
    
    代码视界
</title>

<link rel="alternate" href="/atom.xml" title="代码视界" type="application/atom+xml">


<link rel="icon" href="/img/site_logo.jpg">

    

<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
    

<script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?494af80fa01e8939bec179cfddf660d5";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>


<script>
(function(i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function() {
        (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-142577364-1', 'auto');
ga('send', 'pageview');
</script>


    
<meta name="baidu-site-verification" content="rGeweWgWoh">


<script>
(function() {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</head></html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://image.chenhanpeng.com/static/images/web_static_image/banner.jpg)"
     >
    <div class="main-header-box">
        <!-- <a class="header-avatar" href="/" title='Hanpeng Chen'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a> -->
        <a href="/" class="header-title">
            <h1> 代码视界 </h1>
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <h2>
                Hanpeng Chen的个人博客
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://www.chenhanpeng.com">
                        代码视界</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                文章列表</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/"><i class="fa "></i>
                                文章分类</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/tags/"><i class="fa "></i>
                                文章标签</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/links/"><i class="fa "></i>
                                友链</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/about/"><i class="fa "></i>
                                关于作者</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Flutter | 2-Dart语言简介">
            
            Flutter | 2-Dart语言简介
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/前端/">前端</a> <a class="category-link" href="/categories/前端/Flutter/">Flutter</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/Dart语法/">Dart语法</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2019/12/23</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
        <p class="fa fa-exclamation-triangle warning">
            本文于<strong>
                1067</strong>
            天之前发表，文中内容可能已经过时。
        </p>
        
    </div>
    
    
    <div class="post-body post-content">
        <p>Dart在静态语法方面和Java非常相似，如类型定义、函数声明、泛型等，而在动态特性方面又和JavaScript很想，如函数式特性、异步支持等。除了融合Java和JavaScript语言的长处外，Dart也具有一些其他具有表现力的语法，如可选命名参数、..(联级运算符)和 ?. （条件成员访问运算符）以及 ?? （判空赋值运算符）。</p>
<p>Flutter是采用Dart语言进行开发的，所以我们来学习一下Dart在Flutter开发中常用的语法特性。</p>
<p>下面例子可以在DartPad上面进行运行校验：<a href="https://dartpad.cn/" target="_blank" rel="noopener">https://dartpad.cn/</a></p>
<h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><h2 id="1-var"><a href="#1-var" class="headerlink" title="1. var"></a>1. var</h2><p>类似于JavaScript中var，它可以接收任何类型的变量，但和JavaScript最大的不同在于：Dart中var变量一单赋值，类型便会确定，不能在改变其类型。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> t;</span><br><span class="line">  t = <span class="string">"hello world!"</span>;</span><br><span class="line">  t = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码在JavaScript是没有问题的，前端开发者需要注意一下，之所以有此差异是因为Dart本身是一个强类型语言，任何变量都是有确定类型的，在Dart中，当用var声明一个变量后，Dart在编译时会根据第一次赋值数据的类型来推断其类型，编译结束后其类型就已经被确定，而JavaScript是纯粹的弱类型脚本语言，var只是变量的声明方式而已。</p>
<h2 id="2-dynamic和Object"><a href="#2-dynamic和Object" class="headerlink" title="2. dynamic和Object"></a>2. dynamic和Object</h2><p>Object是Dart所有对象的根基类，也就是说所有类型都是Object子类（包括Function和Null），所以任何类型的数据都可以赋值给Object声明的对象。dynamic和var一样都是关键词，声明的变量可以赋值任何对象。而dynamic和Object相同之处在于：他们声明的变量可以在后期改变赋值类型。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">dynamic</span> user;</span><br><span class="line">  <span class="built_in">Object</span> system;</span><br><span class="line">  user = <span class="string">'zhangsan'</span>;</span><br><span class="line">  system = <span class="string">'dart'</span>;</span><br><span class="line">  <span class="built_in">print</span>(user);</span><br><span class="line">  <span class="built_in">print</span>(system);</span><br><span class="line">  user = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'zhangsan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br><span class="line">  &#125;;</span><br><span class="line">  system = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">print</span>(user);</span><br><span class="line">  <span class="built_in">print</span>(system);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dynamic与Object不同的是,dynamic声明的对象编译器会提供所有可能的组合, 而Object声明的对象只能使用Object的属性与方法, 否则编译器会报错。如:<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">dynamic</span> user;</span><br><span class="line">  <span class="built_in">Object</span> system;</span><br><span class="line">  user = <span class="string">'zhangsan'</span>;</span><br><span class="line">  system = <span class="string">'dart'</span>;</span><br><span class="line">  <span class="built_in">print</span>(user.length);</span><br><span class="line">  <span class="built_in">print</span>(system.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变量user不会报错, 变量system编译器会报错</p>
<p>dynamic的这个特性与Objective-C中的id作用很像. dynamic的这个特点使得我们在使用它时需要格外注意,这很容易引入一个运行时错误.</p>
<h2 id="3-final-和-const"><a href="#3-final-和-const" class="headerlink" title="3. final 和 const"></a>3. final 和 const</h2><p>如果你从未打算更改一个变量，那么使用final或const，不是var，也不是一个类型。一个final变量只能被设置一次，两者区别在于：const变量是一个编译时常量，final变量在第一次使用时被初始化。被final或者const修饰的变量，变量类型可以省略。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> str = <span class="string">'hello world!'</span>;</span><br><span class="line">  <span class="keyword">const</span> str1 = <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Dart是一种真正的面向对象的语言，所以即使是函数也是对象，并且有一个类型Function。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征。</p>
<h2 id="1、函数声明"><a href="#1、函数声明" class="headerlink" title="1、函数声明"></a>1、函数声明</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dart函数声明如果没有显式声明返回值类型是会默认当做dynamic处理，注意，函数返回值没有类型推断：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">bool</span> CALLBACK();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不指定返回类型，此时默认为dynamic，不是bool</span></span><br><span class="line">isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test(CALLBACK cb)&#123;</span><br><span class="line">   <span class="built_in">print</span>(cb()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错，isNoble不是bool类型</span></span><br><span class="line">test(isNoble);</span><br></pre></td></tr></table></figure></p>
<h2 id="2、对于只包含一个表达式的函数，可以使用简写语法"><a href="#2、对于只包含一个表达式的函数，可以使用简写语法" class="headerlink" title="2、对于只包含一个表达式的函数，可以使用简写语法"></a>2、对于只包含一个表达式的函数，可以使用简写语法</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble (<span class="built_in">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3、函数作为变量"><a href="#3、函数作为变量" class="headerlink" title="3、函数作为变量"></a>3、函数作为变量</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> say = (str) &#123;</span><br><span class="line">  <span class="built_in">print</span>(str)</span><br><span class="line">&#125;;</span><br><span class="line">say(<span class="string">'hello world!'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="4、函数作为参数传递"><a href="#4、函数作为参数传递" class="headerlink" title="4、函数作为参数传递"></a>4、函数作为参数传递</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> execute(<span class="keyword">var</span> callback) &#123;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line">execute(() =&gt; <span class="built_in">print</span>(<span class="string">'hello world'</span>));</span><br></pre></td></tr></table></figure>
<h2 id="5、可选的位置参数"><a href="#5、可选的位置参数" class="headerlink" title="5、可选的位置参数"></a>5、可选的位置参数</h2><p>包装一组函数参数，用[]标记为可选的位置参数，并放在参数列表的最后面：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'<span class="subst">$result</span> with a <span class="subst">$device</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个不带可选参数调用这个函数的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say(&apos;iphoneX&apos;, &apos;system error&apos;);</span><br></pre></td></tr></table></figure></p>
<p>下面是用第三个参数调用这个函数的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say(&apos;iphoneX&apos;, &apos;system error&apos;, &apos;signal&apos;);</span><br></pre></td></tr></table></figure></p>
<h2 id="6、可选的命名参数"><a href="#6、可选的命名参数" class="headerlink" title="6、可选的命名参数"></a>6、可选的命名参数</h2><p>定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置[bold]和[hidden]标志</span><br><span class="line">void enableFlags(&#123;bool bold, bool hidden&#125;) &#123;</span><br><span class="line">    // ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用函数时，可以使用指定命名参数。例如：paramName: value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: true, hidden: false);</span><br></pre></td></tr></table></figure></p>
<p>可选命名参数在Flutter中使用非常多。</p>
<blockquote>
<p>注意，不能同时使用可选的位置参数和可选的命名参数</p>
</blockquote>
<h1 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h1><p>Dart类库有非常多返回Future或者Stream对象的函数。这些函数被称为<strong>异步函数</strong>：它们只会在设置好一些耗时操作之后返回，比如像IO操作。而不是等到这个操作完成。</p>
<p><code>async</code>和 <code>await</code>关键词支持了异步编程，允许您写出和同步代码很像的异步代码。</p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>Future</code>与JavaScript中的<code>Promise</code>非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。一个Future只会对应一个结果，要么成功，要么失败。</p>
<p>由于本身功能较多，这里我们只介绍其常用的API及特性。还有，请记住，Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用。</p>
<h3 id="Future-then"><a href="#Future-then" class="headerlink" title="Future.then"></a>Future.then</h3><p>下面我们利用Future.delayed 创建一个延时任务来模拟请求远程接口返回。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), ()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;).then((data) &#123;</span><br><span class="line">  <span class="built_in">print</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Future-catchError"><a href="#Future-catchError" class="headerlink" title="Future.catchError"></a>Future.catchError</h3><p>如果异步任务发生错误，我们可以在catchError中捕获错误，我们将上面示例改为：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), ()&#123;</span><br><span class="line">  <span class="keyword">throw</span> AssertionError(<span class="string">"Error"</span>);</span><br><span class="line">&#125;).then((data) &#123;</span><br><span class="line">  <span class="built_in">print</span>(data);</span><br><span class="line">&#125;).catchError((e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在上面的示例中，我们在异步任务中抛出了一个异常，then的回调函数将不会被执行，取而代之的是 catchError回调函数将被调用；但是，并不是只有 catchError回调才能捕获错误，then方法还有一个可选参数onError，我们也可以它来捕获异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future.delayed(new Duration(seconds: 3), ()&#123;</span><br><span class="line">  throw AssertionError(&quot;Error&quot;);</span><br><span class="line">&#125;).then((data) &#123;</span><br><span class="line">  print(data);</span><br><span class="line">&#125;, onError: (e) &#123;</span><br><span class="line">  print(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Future-whenComplete"><a href="#Future-whenComplete" class="headerlink" title="Future.whenComplete"></a>Future.whenComplete</h3><p>有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在then或catch中关闭一下对话框，第二种就是使用Future的whenComplete回调，我们将上面示例改一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Future.delayed(new Duration(seconds: 3), ()&#123;</span><br><span class="line">  throw AssertionError(&quot;Error&quot;);</span><br><span class="line">&#125;).then((data) &#123;</span><br><span class="line">  print(data);</span><br><span class="line">&#125;).catchError((e) &#123;</span><br><span class="line">  print(e);</span><br><span class="line">&#125;).whenComplete(()&#123;</span><br><span class="line">  // 无论成功或失败都会走到这里</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Future-wait"><a href="#Future-wait" class="headerlink" title="Future.wait"></a>Future.wait</h3><p>有些时候，我们需要等待多个异步任务都执行结束后才进行一些操作，比如我们有一个界面，需要先分别从两个网络接口获取数据，获取成功后，我们需要将两个接口数据进行特定的处理后再显示到UI界面上，应该怎么做？答案是Future.wait，它接受一个Future数组参数，只有数组中所有Future都执行成功后，才会触发then的成功回调，只要有一个Future执行失败，就会触发错误回调。下面，我们通过模拟Future.delayed 来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Future.wait([</span><br><span class="line">  // 2秒后返回结果  </span><br><span class="line">  Future.delayed(new Duration(seconds: 2), () &#123;</span><br><span class="line">    return &quot;hello&quot;;</span><br><span class="line">  &#125;),</span><br><span class="line">  // 4秒后返回结果  </span><br><span class="line">  Future.delayed(new Duration(seconds: 4), () &#123;</span><br><span class="line">    return &quot; world&quot;;</span><br><span class="line">  &#125;)</span><br><span class="line">]).then((results)&#123;</span><br><span class="line">  print(results[0]+results[1]);</span><br><span class="line">&#125;).catchError((e)&#123;</span><br><span class="line">  print(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>执行上面代码，4秒后你会在控制台中看到“hello world”。</p>
<h2 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h2><p>如果代码中有大量异步逻辑，并且出现大量异步任务依赖其他异步任务的结果时，必然会出现<code>Future.then</code>回调中套回调情况。举个例子，比如有个场景是用户需要先登录，登录成功后获得用户Id，然后根据用户ID去请求个人信息，成功获取信息后将其缓存在本地文件系统中。代码示例如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先分别定义各个异步任务</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; login(<span class="built_in">String</span> userName, <span class="built_in">String</span> pwd)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//用户登录</span></span><br><span class="line">&#125;;</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getUserInfo(<span class="built_in">String</span> id)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取用户信息 </span></span><br><span class="line">&#125;;</span><br><span class="line">Future saveUserInfo(<span class="built_in">String</span> userInfo)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 保存用户信息 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来执行整个流程：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">login(<span class="string">"alice"</span>,<span class="string">"******"</span>).then((id)&#123;</span><br><span class="line"> <span class="comment">//登录成功后通过，id获取用户信息    </span></span><br><span class="line"> getUserInfo(id).then((userInfo)&#123;</span><br><span class="line">    <span class="comment">//获取用户信息后保存 </span></span><br><span class="line">    saveUserInfo(userInfo).then(()&#123;</span><br><span class="line">       <span class="comment">//保存用户信息，接下来执行其它操作</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>可以感受一下，如果业务逻辑中有大量异步依赖的情况，将会出现上面这种在回调里面套回调的情况，过多的嵌套会导致的代码可读性下降以及出错率提高，并且非常难维护，这个问题被形象的称为<strong>回调地狱（Callback Hell）</strong>。回调地狱问题在之前JavaScript中非常突出，也是JavaScript被吐槽最多的点，但随着ECMAScript6和ECMAScript7标准发布后，这个问题得到了非常好的解决，而解决回调地狱的两大神器正是ECMAScript6引入了<code>Promise</code>，以及ECMAScript7中引入的<code>async/await</code>。 而在Dart中几乎是完全平移了JavaScript中的这两者：Future相当于Promise，而async/await连名字都没改。接下来我们看看通过<code>Future</code>和<code>async/await</code>如何消除上面示例中的嵌套问题。</p>
<h3 id="使用Future消除Callback-Hell"><a href="#使用Future消除Callback-Hell" class="headerlink" title="使用Future消除Callback Hell"></a>使用Future消除Callback Hell</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">login(<span class="string">"alice"</span>,<span class="string">"******"</span>).then((id)&#123;</span><br><span class="line">      <span class="keyword">return</span> getUserInfo(id);</span><br><span class="line">&#125;).then((userInfo)&#123;</span><br><span class="line">    <span class="keyword">return</span> saveUserInfo(userInfo);</span><br><span class="line">&#125;).then((e)&#123;</span><br><span class="line">   <span class="comment">//执行接下来的操作 </span></span><br><span class="line">&#125;).catchError((e)&#123;</span><br><span class="line">  <span class="comment">//错误处理  </span></span><br><span class="line">  <span class="built_in">print</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>正如上文所述， Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用” ，如果在then中返回的是一个Future的话，该future会执行，执行结束后会触发后面的then回调，这样依次向下，就避免了层层嵌套。</p>
<h3 id="使用async-await消除callback-hell"><a href="#使用async-await消除callback-hell" class="headerlink" title="使用async/await消除callback hell"></a>使用async/await消除callback hell</h3><p>通过Future回调中再返回Future的方式虽然能避免层层嵌套，但是还是有一层回调，有没有一种方式能够让我们可以像写同步代码那样来执行异步任务而不使用回调的方式？答案是肯定的，这就要使用async/await了，下面我们先直接看代码，然后再解释，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task() async &#123;</span><br><span class="line">   try&#123;</span><br><span class="line">    String id = await login(&quot;alice&quot;,&quot;******&quot;);</span><br><span class="line">    String userInfo = await getUserInfo(id);</span><br><span class="line">    await saveUserInfo(userInfo);</span><br><span class="line">    //执行接下来的操作   </span><br><span class="line">   &#125; catch(e)&#123;</span><br><span class="line">    //错误处理   </span><br><span class="line">    print(e);   </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>async</code>用来表示函数是异步的，定义的函数会返回一个Future对象，可以使用then方法添加回调函数。</li>
<li><code>await</code> 后面是一个Future，表示等待该异步任务完成，异步完成后才会往下走；await必须出现在 async 函数内部。</li>
</ul>
<p>可以看到，我们通过async/await将一个异步流用同步的代码表示出来了。</p>
<blockquote>
<p>其实，无论是在JavaScript还是Dart中，async/await都只是一个语法糖，编译器或解释器最终都会将其转化为一个Promise（Future）的调用链。</p>
</blockquote>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Stream也是用于接收异步事件数据，和Future不同的是，它可以接收多个异步操作的结果（成功或失败）。也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Stream.fromFutures([</span><br><span class="line">  // 1秒后返回结果</span><br><span class="line">  Future.delayed(new Duration(seconds: 1), () &#123;</span><br><span class="line">    return &quot;hello 1&quot;;</span><br><span class="line">  &#125;),</span><br><span class="line">  // 抛出一个异常</span><br><span class="line">  Future.delayed(new Duration(seconds: 2),()&#123;</span><br><span class="line">    throw AssertionError(&quot;Error&quot;);</span><br><span class="line">  &#125;),</span><br><span class="line">  // 3秒后返回结果</span><br><span class="line">  Future.delayed(new Duration(seconds: 3), () &#123;</span><br><span class="line">    return &quot;hello 3&quot;;</span><br><span class="line">  &#125;)</span><br><span class="line">]).listen((data)&#123;</span><br><span class="line">   print(data);</span><br><span class="line">&#125;, onError: (e)&#123;</span><br><span class="line">   print(e.message);</span><br><span class="line">&#125;,onDone: ()&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>执行上面代码依次输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello 1</span><br><span class="line">Error</span><br><span class="line">hello 3</span><br></pre></td></tr></table></figure></p>

    </div>
    <div class="wechat">
        
            <strong> 欢迎关注微信公众号： 『前端极客技术』『代码视界』 </strong>
            <img class="wechat-image" src="https://image.chenhanpeng.com/static/images/web_static_image/article-gzh-qrcode.png" />
        
    </div>
    
    <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            <span class="reward-type">
                <img class="alipay" src="https://image.chenhanpeng.com/static/images/web_static_image/donate/alipay_qrcode.png"><b>支付宝打赏</b>
            </span>
            
            
            <span class="reward-type">
                <img class="wechat" src="https://image.chenhanpeng.com/static/images/web_static_image/donate/weixin_pay_qrcode.png"><b>微信打赏</b>
            </span>
            
        </div>
    </div>
    <p class="reward-tip">
        赞赏是不耍流氓的鼓励
    </p>
</div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">代码视界</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/create-first-flutter-app/" class="pre-post btn btn-default" title='Flutter | 3-创建第一个Flutter应用'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            Flutter | 3-创建第一个Flutter应用</span>
    </a>
    
    
    <a href="/start-learn-flutter/" class="next-post btn btn-default" title='Flutter | 1-了解Flutter'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            Flutter | 1-了解Flutter</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<!-- google广告 -->
<!-- <ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-1437849089810081"
     data-ad-slot="9946365914"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script> -->


    <div id="comments">
        
<link rel="stylesheet" href="https://cdn.bootcss.com/gitalk/1.7.2/gitalk.min.css">
<script src="//cdn.bootcss.com/gitalk/1.7.2/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.9.0/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
var gitalk = new Gitalk({
    // Gitalk配置
    language: "zh-CN",
    clientID: "fb80658382dee5240195",
    clientSecret: "66663a08264192222ba993f20dd7c0a27c1e6fa5",
    repo: "blog-comments",
    owner: "Hanpeng-Chen",
    admin: ["Hanpeng-Chen"],
    id: md5(location.pathname),
    distractionFreeMode: true,
    proxy: "https://cloudflare-cors-anywhere.hanpengchen.workers.dev/?https://github.com/login/oauth/access_token"
});
gitalk.render('gitalk-container');
</script>

    </div>

                </main>
                
                    <div class="col-md-4">
<!-- 方形 -->
<!-- <ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-1437849089810081"
     data-ad-slot="2426112279"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script> -->
</div>
<aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#变量声明"><span class="toc-text">变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-var"><span class="toc-text">1. var</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-dynamic和Object"><span class="toc-text">2. dynamic和Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-final-和-const"><span class="toc-text">3. final 和 const</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、函数声明"><span class="toc-text">1、函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、对于只包含一个表达式的函数，可以使用简写语法"><span class="toc-text">2、对于只包含一个表达式的函数，可以使用简写语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、函数作为变量"><span class="toc-text">3、函数作为变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、函数作为参数传递"><span class="toc-text">4、函数作为参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、可选的位置参数"><span class="toc-text">5、可选的位置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、可选的命名参数"><span class="toc-text">6、可选的命名参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步支持"><span class="toc-text">异步支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Future"><span class="toc-text">Future</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-then"><span class="toc-text">Future.then</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-catchError"><span class="toc-text">Future.catchError</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-whenComplete"><span class="toc-text">Future.whenComplete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-wait"><span class="toc-text">Future.wait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Async-await"><span class="toc-text">Async/await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Future消除Callback-Hell"><span class="toc-text">使用Future消除Callback Hell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用async-await消除callback-hell"><span class="toc-text">使用async/await消除callback hell</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream"><span class="toc-text">Stream</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2019
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
                
                    <span> | </span>
                    <span>
                        <a href="//beian.miit.gov.cn/" target="_blank" rel="nofollow">
                            闽ICP备19010134号-1
                        </a>
                    </span>
                
                
                    <span> | </span>
                    <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=35020302033449" rel="nofollow">
                        <img src="https://image.chenhanpeng.com/static/images/web_static_image/beian_icon.png" width="20">
                        <span>闽公网安备 35020302033449号</span>
                    </a>
                         
            </div>
        </div>
    </div>
</div>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/app.js?rev=@@hash"></script>
</body>
</html>